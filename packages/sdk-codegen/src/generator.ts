import { OssaAgent } from '@bluefly/openstandardagents';

export type SdkLanguage = 'typescript' | 'python';

/**
 * SDK Generator
 *
 * Generates type-safe SDK clients for OSSA Agents.
 * This class uses the OSSA Agent Manifest as the source of truth for:
 * 1. Client Identity (Name, Description)
 * 2. Available Tools (Methods)
 * 3. Messaging Commands (Methods)
 *
 * It adheres to the API-First principle by treating the Manifest as the formal contract.
 */
export class SdkGenerator {
  /**
   * Generate SDK code for a given OSSA Agent Manifest
   * @param manifest The valid OSSA Agent Manifest
   * @param language Target language for the SDK
   * @returns Generated source code as a string
   */
  public generate(manifest: OssaAgent, language: SdkLanguage): string {
    switch (language) {
      case 'typescript':
        return this.generateTypeScript(manifest);
      case 'python':
        return this.generatePython(manifest);
      default:
        throw new Error(`Unsupported language: ${language}`);
    }
  }

  /**
   * Generates a TypeScript class extending the base AgentClient.
   * Uses JSDoc for IDE support and IntelliSense.
   */
  private generateTypeScript(manifest: OssaAgent): string {
    const name = this.toPascalCase(manifest.metadata?.name || 'Agent');
    const description = manifest.metadata?.description || '';
    const tools = manifest.spec?.tools || [];
    const messages = manifest.spec?.messaging?.commands || [];

    // Map tools and commands to class methods
    const methods = [
      ...tools.map((t) => this.generateTsToolMethod(t)),
      ...messages.map((m) => this.generateTsCommandMethod(m)),
    ].join('\n\n');

    return `
/**
 * ${name} SDK
 * ${description}
 *
 * Auto-generated by OSSA SDK Codegen.
 * DO NOT EDIT.
 */

import { AgentClient, AgentConfig } from '@bluefly/ossa-client';

export class ${name} extends AgentClient {
  constructor(config: AgentConfig) {
    super(config);
  }

  ${methods}
}
`;
  }

  private generateTsToolMethod(tool: {
    name?: string;
    description?: string;
    [key: string]: unknown;
  }): string {
    const toolName = this.toCamelCase(tool.name || 'tool');
    const desc = tool.description || `Execute tool: ${tool.name}`;

    return `  /**
   * ${desc}
   * @param params Tool parameters
   */
  public async ${toolName}(params: Record<string, unknown>): Promise<unknown> {
    return this.executeTool('${tool.name}', params);
  }`;
  }

  private generateTsCommandMethod(command: {
    name?: string;
    description?: string;
    [key: string]: unknown;
  }): string {
    const cmdName = this.toCamelCase(command.name || 'command');
    const desc = command.description || `Send command: ${command.name}`;

    return `  /**
   * ${desc}
   * @param payload Command payload
   */
  public async ${cmdName}(payload: Record<string, unknown>): Promise<unknown> {
    return this.sendCommand('${command.name}', payload);
  }`;
  }

  /**
   * Generates a Python class extending the base AgentClient.
   * Uses Type Hints and Docstrings for IDE support.
   */
  private generatePython(manifest: OssaAgent): string {
    const name = this.toPascalCase(manifest.metadata?.name || 'Agent');
    const description = manifest.metadata?.description || '';
    const tools = manifest.spec?.tools || [];
    const messages = manifest.spec?.messaging?.commands || [];

    const methods = [
      ...tools.map((t) => this.generatePyToolMethod(t)),
      ...messages.map((m) => this.generatePyCommandMethod(m)),
    ].join('\n\n');

    return `
"""
${name} SDK
${description}

Auto-generated by OSSA SDK Codegen.
DO NOT EDIT.
"""

from ossa.client import AgentClient, AgentConfig
from typing import Any, Dict

class ${name}(AgentClient):
    """
    Client for interacting with the ${name} agent.
    """
    def __init__(self, config: AgentConfig):
        super().__init__(config)

${methods}
`;
  }

  private generatePyToolMethod(tool: {
    name?: string;
    description?: string;
    [key: string]: unknown;
  }): string {
    const toolName = this.toSnakeCase(tool.name || 'tool');
    const desc = tool.description || `Execute tool: ${tool.name}`;

    return `    def ${toolName}(self, params: Dict[str, Any]) -> Any:
        """
        ${desc}
        """
        return self.execute_tool('${tool.name}', params)`;
  }

  private generatePyCommandMethod(command: {
    name?: string;
    description?: string;
    [key: string]: unknown;
  }): string {
    const cmdName = this.toSnakeCase(command.name || 'command');
    const desc = command.description || `Send command: ${command.name}`;

    return `    def ${cmdName}(self, payload: Dict[str, Any]) -> Any:
        """
        ${desc}
        """
        return self.send_command('${command.name}', payload)`;
  }

  // --- Utility Methods ---

  private toPascalCase(str: string): string {
    return str.replace(/(^\w|-\w)/g, (g) => g.replace('-', '').toUpperCase());
  }

  private toCamelCase(str: string): string {
    return str.replace(/-\w/g, (g) => g[1].toUpperCase());
  }

  private toSnakeCase(str: string): string {
    return str.replace(/-/g, '_').toLowerCase();
  }
}
