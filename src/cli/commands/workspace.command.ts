/**
 * OSSA Workspace Command - Two-Tier Architecture Management
 *
 * Subcommands:
 *   ossa workspace init          - Initialize .agents-workspace/ structure
 *   ossa workspace list          - List agents in workspace registry
 *   ossa workspace policy check  - Validate agent against workspace policies
 *   ossa workspace policy list   - List allowed/denied tools
 *   ossa workspace discover      - Auto-discover project agents
 *   ossa workspace sync          - Sync registry with discovered agents
 */

import { Command } from 'commander';
import chalk from 'chalk';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';
import { glob } from 'glob';
import { getVersion } from '../../utils/version.js';
import { outputJSON, handleCommandError } from '../utils/index.js';

export const workspaceCommand = new Command('workspace')
  .description('Manage .agents-workspace/ (two-tier architecture governance)');

// ============================================================================
// Subcommand: workspace init
// ============================================================================
workspaceCommand
  .command('init')
  .description('Initialize .agents-workspace/ directory structure')
  .option('-f, --force', 'Overwrite existing workspace')
  .option('--name <name>', 'Workspace name', 'my-workspace')
  .action(async (options) => {
    try {
      const workspaceDir = path.resolve(process.cwd(), '.agents-workspace');

      if (fs.existsSync(workspaceDir) && !options.force) {
        console.log(chalk.yellow('⚠ .agents-workspace/ already exists'));
        console.log(chalk.gray('  Use --force to overwrite'));
        process.exit(1);
      }

      console.log(chalk.blue('Initializing .agents-workspace/...'));

      // Create directory structure
      const dirs = [
        'registry',
        'policies',
        'orchestration',
        'shared-context',
        'logs',
      ];

      for (const dir of dirs) {
        const dirPath = path.join(workspaceDir, dir);
        fs.mkdirSync(dirPath, { recursive: true });
        console.log(chalk.gray(`  Created ${dir}/`));
      }

      // Create registry/index.yaml
      const registryContent = yaml.stringify({
        apiVersion: 'ossa.dev/v1',
        kind: 'AgentRegistry',
        metadata: {
          name: options.name.replace(/[^a-zA-Z0-9-_]/g, '-'),
          version: getVersion(),
          description: `Agent registry for ${options.name.replace(/[^a-zA-Z0-9-_]/g, '-')}`,
        },
        agents: [],
        discovery: {
          strategy: 'filesystem',
          refresh: 'on-demand',
          patterns: [
            '.agents/**/*.ossa.yaml',
            '.agents/**/manifest.ossa.yaml',
          ],
        },
      });
      fs.writeFileSync(
        path.join(workspaceDir, 'registry', 'index.yaml'),
        `# OSSA Agent Registry\n# Auto-generated by ossa workspace init\n\n${registryContent}`
      );
      console.log(chalk.gray('  Created registry/index.yaml'));

      // Create policies/tool-allowlist.yaml
      const policyContent = yaml.stringify({
        apiVersion: 'ossa.dev/v1',
        kind: 'ToolPolicy',
        metadata: {
          name: `${options.name}-policy`,
          version: '1.0.0',
        },
        spec: {
          mcp_servers: {
            allowed: [
              {
                name: 'filesystem',
                uri: 'npx -y @modelcontextprotocol/server-filesystem',
                trust: 'high',
                scope: ['read', 'write'],
                directories: ['./src', './docs'],
              },
              {
                name: 'memory',
                uri: 'npx -y @modelcontextprotocol/server-memory',
                trust: 'high',
                scope: ['read', 'write'],
              },
            ],
            denied: [
              {
                pattern: '*shell*',
                reason: 'Direct shell access prohibited',
              },
            ],
          },
          risk_tiers: {
            high: { requires: 'human-approval', audit: 'full' },
            medium: { requires: 'workspace-policy', audit: 'summary' },
            low: { requires: 'none', audit: 'none' },
          },
          boundaries: {
            global_never: [
              '**/.env',
              '**/.env.*',
              '**/secrets/**',
              '**/*.key',
              '**/*.pem',
            ],
          },
        },
      });
      fs.writeFileSync(
        path.join(workspaceDir, 'policies', 'tool-allowlist.yaml'),
        `# OSSA Tool Policy - MCP Server Allowlist\n# Auto-generated by ossa workspace init\n\n${policyContent}`
      );
      console.log(chalk.gray('  Created policies/tool-allowlist.yaml'));

      // Create shared-context/README.md
      const sharedContextContent = `# Shared Context

Global conventions and standards that apply to all agents in this workspace.

## Coding Standards
- Follow project-specific linter rules
- Use TypeScript for new code
- Write tests for new functionality

## Security Guidelines
- Never commit secrets
- Use environment variables for configuration
- Follow OWASP Top 10 guidelines

## Documentation
- Update AGENTS.md for agent changes
- Keep manifests in sync with capabilities
`;
      fs.writeFileSync(
        path.join(workspaceDir, 'shared-context', 'README.md'),
        sharedContextContent
      );
      console.log(chalk.gray('  Created shared-context/README.md'));

      console.log('');
      console.log(chalk.green('✓ Workspace initialized'));
      console.log('');
      console.log(chalk.blue('Next steps:'));
      console.log(chalk.gray('  1. Run `ossa workspace discover` to find project agents'));
      console.log(chalk.gray('  2. Edit policies/tool-allowlist.yaml to configure allowed tools'));
      console.log(chalk.gray('  3. Run `ossa agent init` in each project to create .agents/'));

      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace list
// ============================================================================
workspaceCommand
  .command('list')
  .description('List agents in workspace registry')
  .option('--json', 'Output as JSON')
  .action(async (options) => {
    try {
      const registryPath = path.resolve(process.cwd(), '.agents-workspace/registry/index.yaml');

      if (!fs.existsSync(registryPath)) {
        console.log(chalk.yellow('⚠ No workspace registry found'));
        console.log(chalk.gray('  Run `ossa workspace init` first'));
        process.exit(1);
      }

      const content = fs.readFileSync(registryPath, 'utf-8');
      const registry = yaml.parse(content);

      if (options.json) {
        outputJSON(registry);
        process.exit(0);
      }

      console.log(chalk.blue(`Workspace: ${registry.metadata?.name || 'unnamed'}`));
      console.log(chalk.gray('─'.repeat(50)));

      const agents = registry.agents || [];
      if (agents.length === 0) {
        console.log(chalk.yellow('No agents registered'));
        console.log(chalk.gray('  Run `ossa workspace discover` to find agents'));
      } else {
        for (const project of agents) {
          console.log(`\n${chalk.cyan(project.project || project.name)}`);
          console.log(chalk.gray(`  Path: ${project.path}`));

          if (project.agents) {
            for (const agent of project.agents) {
              console.log(`  • ${agent.name}`);
              if (agent.capabilities) {
                console.log(chalk.gray(`    Capabilities: ${agent.capabilities.join(', ')}`));
              }
            }
          } else if (project.capabilities) {
            console.log(chalk.gray(`  Capabilities: ${project.capabilities.join(', ')}`));
          }
        }
      }

      console.log('');
      console.log(chalk.gray(`Total: ${agents.length} project(s)`));
      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace discover
// ============================================================================
workspaceCommand
  .command('discover')
  .description('Auto-discover project agents in workspace')
  .option('--depth <number>', 'Max directory depth to search', '3')
  .option('--dry-run', 'Show what would be discovered without updating registry')
  .action(async (options) => {
    try {
      const cwd = process.cwd();

      console.log(chalk.blue('Discovering agents...'));

      // Find all .agents directories
      const patterns = [
        '**/.agents/manifest.ossa.yaml',
        '**/.agents/*.ossa.yaml',
        '**/agents/*.ossa.yaml',
      ];

      const found: Array<{
        project: string;
        path: string;
        agents: Array<{
          name: string;
          manifest: string;
          capabilities: string[];
          kind?: string;
        }>;
      }> = [];

      for (const pattern of patterns) {
        const files = await glob(pattern, {
          cwd,
          ignore: ['node_modules/**', '**/node_modules/**', 'dist/**', '.agents-workspace/**'],
          maxDepth: parseInt(options.depth, 10),
        });

        for (const file of files) {
          const fullPath = path.resolve(cwd, file);
          const content = fs.readFileSync(fullPath, 'utf-8');
          const manifest = yaml.parse(content);

          if (!manifest?.metadata?.name) continue;

          const projectDir = path.dirname(path.dirname(fullPath));
          const projectName = path.basename(projectDir);
          const relativePath = path.dirname(path.relative(cwd, fullPath));

          // Find or create project entry
          let projectEntry = found.find(p => p.path === relativePath);
          if (!projectEntry) {
            projectEntry = {
              project: projectName,
              path: `./${relativePath}`,
              agents: [],
            };
            found.push(projectEntry);
          }

          // Extract capabilities
          const capabilities: string[] = [];
          if (manifest.spec?.capabilities) {
            for (const cap of manifest.spec.capabilities) {
              if (typeof cap === 'string') {
                capabilities.push(cap);
              } else if (cap.name) {
                capabilities.push(cap.name);
              }
            }
          }

          projectEntry.agents.push({
            name: manifest.metadata.name,
            manifest: `./${path.basename(file)}`,
            capabilities: capabilities.slice(0, 3), // Top 3
            kind: manifest.kind,
          });
        }
      }

      if (found.length === 0) {
        console.log(chalk.yellow('No agents discovered'));
        console.log(chalk.gray('  Create agents with `ossa agent init`'));
        process.exit(0);
      }

      console.log(chalk.gray('─'.repeat(50)));
      console.log(`Found ${chalk.cyan(found.length)} project(s) with agents:\n`);

      for (const project of found) {
        console.log(chalk.cyan(project.project));
        console.log(chalk.gray(`  Path: ${project.path}`));
        for (const agent of project.agents) {
          const kindBadge = agent.kind && agent.kind !== 'Agent'
            ? chalk.yellow(` [${agent.kind}]`)
            : '';
          console.log(`  • ${agent.name}${kindBadge}`);
        }
        console.log('');
      }

      if (options.dryRun) {
        console.log(chalk.yellow('DRY RUN: Registry not updated'));
        process.exit(0);
      }

      // Update registry
      const registryPath = path.resolve(cwd, '.agents-workspace/registry/index.yaml');
      if (!fs.existsSync(path.dirname(registryPath))) {
        console.log(chalk.yellow('⚠ No workspace found'));
        console.log(chalk.gray('  Run `ossa workspace init` first'));
        process.exit(1);
      }

      const registryContent = fs.readFileSync(registryPath, 'utf-8');
      const registry = yaml.parse(registryContent);
      registry.agents = found;

      fs.writeFileSync(
        registryPath,
        `# OSSA Agent Registry\n# Updated by ossa workspace discover\n\n${yaml.stringify(registry)}`
      );

      console.log(chalk.green('✓ Registry updated'));
      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace policy
// ============================================================================
const policyCommand = workspaceCommand
  .command('policy')
  .description('Manage workspace policies');

policyCommand
  .command('list')
  .description('List allowed and denied tools')
  .option('--json', 'Output as JSON')
  .action(async (options) => {
    try {
      const policyPath = path.resolve(
        process.cwd(),
        '.agents-workspace/policies/tool-allowlist.yaml'
      );

      if (!fs.existsSync(policyPath)) {
        console.log(chalk.yellow('⚠ No policy file found'));
        console.log(chalk.gray('  Run `ossa workspace init` first'));
        process.exit(1);
      }

      const content = fs.readFileSync(policyPath, 'utf-8');
      const policy = yaml.parse(content);

      if (options.json) {
        outputJSON(policy);
        process.exit(0);
      }

      console.log(chalk.blue('Workspace Tool Policy'));
      console.log(chalk.gray('─'.repeat(50)));

      const allowed = policy.spec?.mcp_servers?.allowed || [];
      const denied = policy.spec?.mcp_servers?.denied || [];

      console.log(chalk.green('\nAllowed MCP Servers:'));
      for (const server of allowed) {
        const trustColor =
          server.trust === 'high' ? chalk.green :
          server.trust === 'medium' ? chalk.yellow :
          chalk.red;
        console.log(`  ${chalk.cyan(server.name)} ${trustColor(`[${server.trust}]`)}`);
        console.log(chalk.gray(`    Scope: ${(server.scope || []).join(', ')}`));
      }

      console.log(chalk.red('\nDenied Patterns:'));
      for (const pattern of denied) {
        console.log(`  ${chalk.yellow(pattern.pattern)}`);
        console.log(chalk.gray(`    Reason: ${pattern.reason}`));
      }

      const never = policy.spec?.boundaries?.global_never || [];
      if (never.length > 0) {
        console.log(chalk.red('\nGlobal Never (blocked paths):'));
        for (const p of never) {
          console.log(`  ${chalk.gray(p)}`);
        }
      }

      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

policyCommand
  .command('check <project>')
  .description('Validate project agent against workspace policies')
  .action(async (project: string) => {
    try {
      const policyPath = path.resolve(
        process.cwd(),
        '.agents-workspace/policies/tool-allowlist.yaml'
      );

      if (!fs.existsSync(policyPath)) {
        console.log(chalk.yellow('⚠ No policy file found'));
        process.exit(1);
      }

      // Find project manifest
      const manifestPatterns = [
        path.join(project, '.agents', 'manifest.ossa.yaml'),
        path.join(project, '.agents', '*.ossa.yaml'),
        `.agents/${project}.ossa.yaml`,
      ];

      let manifestPath: string | null = null;
      for (const pattern of manifestPatterns) {
        const matches = await glob(pattern, { cwd: process.cwd() });
        if (matches.length > 0) {
          manifestPath = path.resolve(process.cwd(), matches[0]);
          break;
        }
      }

      if (!manifestPath || !fs.existsSync(manifestPath)) {
        console.log(chalk.red(`✗ No manifest found for project: ${project}`));
        process.exit(1);
      }

      const policy = yaml.parse(fs.readFileSync(policyPath, 'utf-8'));
      const manifest = yaml.parse(fs.readFileSync(manifestPath, 'utf-8'));

      console.log(chalk.blue(`Checking: ${manifest.metadata?.name || project}`));
      console.log(chalk.gray('─'.repeat(50)));

      const errors: string[] = [];
      const warnings: string[] = [];

      // Check tool references
      const allowedTools = (policy.spec?.mcp_servers?.allowed || []).map(
        (s: { name: string }) => s.name
      );
      const deniedPatterns = (policy.spec?.mcp_servers?.denied || []).map(
        (d: { pattern: string }) => d.pattern
      );

      const requestedTools = manifest.spec?.tools?.allowed || [];
      for (const tool of requestedTools) {
        const toolName = typeof tool === 'string' ? tool : tool.name;

        // Check if denied
        for (const pattern of deniedPatterns) {
          const regex = new RegExp(pattern.replace('*', '.*'));
          if (regex.test(toolName)) {
            errors.push(`Tool "${toolName}" matches denied pattern "${pattern}"`);
          }
        }

        // Check if allowed
        if (!allowedTools.includes(toolName)) {
          warnings.push(`Tool "${toolName}" not in workspace allowlist`);
        }
      }

      // Check boundaries
      const globalNever = policy.spec?.boundaries?.global_never || [];
      const agentBoundaries = manifest.spec?.boundaries || {};

      for (const boundary of [...(agentBoundaries.read || []), ...(agentBoundaries.write || [])]) {
        for (const never of globalNever) {
          // Simple glob match
          if (boundary.includes(never.replace('**/', '').replace('*', ''))) {
            errors.push(`Boundary "${boundary}" conflicts with global_never "${never}"`);
          }
        }
      }

      // Output results
      if (errors.length === 0 && warnings.length === 0) {
        console.log(chalk.green('✓ Agent passes all policy checks'));
        process.exit(0);
      }

      if (errors.length > 0) {
        console.log(chalk.red(`\n✗ Errors (${errors.length}):`));
        errors.forEach(e => console.log(`  ${chalk.red('•')} ${e}`));
      }

      if (warnings.length > 0) {
        console.log(chalk.yellow(`\n⚠ Warnings (${warnings.length}):`));
        warnings.forEach(w => console.log(`  ${chalk.yellow('•')} ${w}`));
      }

      process.exit(errors.length > 0 ? 1 : 0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace sync
// ============================================================================
workspaceCommand
  .command('sync')
  .description('Sync workspace registry with discovered agents')
  .action(async () => {
    // Just run discover without dry-run
    const discover = workspaceCommand.commands.find(c => c.name() === 'discover');
    if (discover) {
      await discover.parseAsync(['discover'], { from: 'user' });
    }
  });
