/**
 * OSSA Workspace Command - Two-Tier Architecture Management
 *
 * Subcommands:
 *   ossa workspace init          - Initialize .agents-workspace/ structure
 *   ossa workspace list          - List agents in workspace registry
 *   ossa workspace policy check  - Validate agent against workspace policies
 *   ossa workspace policy list   - List allowed/denied tools
 *   ossa workspace discover      - Auto-discover project agents
 *   ossa workspace sync          - Sync registry with discovered agents
 */

import { Command } from 'commander';
import chalk from 'chalk';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';
import { glob } from 'glob';
import { getVersion } from '../../utils/version.js';
import { outputJSON, handleCommandError } from '../utils/index.js';

export const workspaceCommand = new Command('workspace')
  .description('Manage .agents-workspace/ (two-tier architecture governance)');

// ============================================================================
// Subcommand: workspace init
// ============================================================================
workspaceCommand
  .command('init')
  .description('Initialize .agents-workspace/ directory structure')
  .option('-f, --force', 'Overwrite existing workspace')
  .option('--name <name>', 'Workspace name', 'my-workspace')
  .action(async (options) => {
    try {
      const workspaceDir = path.resolve(process.cwd(), getDefaultWorkspaceDir());

      if (fs.existsSync(workspaceDir) && !options.force) {
        console.log(chalk.yellow('âš  .agents-workspace/ already exists'));
        console.log(chalk.gray('  Use --force to overwrite'));
        process.exit(1);
      }

      console.log(chalk.blue('Initializing .agents-workspace/...'));

      // Create directory structure
      const dirs = [
        'registry',
        'policies',
        'orchestration',
        'shared-context',
        'logs',
      ];

      for (const dir of dirs) {
        const dirPath = path.join(workspaceDir, dir);
        fs.mkdirSync(dirPath, { recursive: true });
        console.log(chalk.gray(`  Created ${dir}/`));
      }

      // Create registry file
      const registryPath = getWorkspaceRegistryPath();
      const registryContent = yaml.stringify({
        apiVersion: 'ossa.dev/v1',
        kind: 'AgentRegistry',
        metadata: {
          name: options.name.replace(/[^a-zA-Z0-9-_]/g, '-'),
          version: getVersion(),
          description: `Agent registry for ${options.name.replace(/[^a-zA-Z0-9-_]/g, '-')}`,
        },
        agents: [],
        discovery: {
          strategy: 'filesystem',
          refresh: 'on-demand',
          patterns: [
            '.agents/**/*.ossa.yaml',
            '.agents/**/manifest.ossa.yaml',
          ],
        },
      });
      fs.writeFileSync(
        path.join(workspaceDir, 'registry', 'index.yaml'),
        `# OSSA Agent Registry\n# Auto-generated by ossa workspace init\n\n${registryContent}`
      );
      console.log(chalk.gray(`  Created ${getWorkspaceRegistryPath()}`));

      // Create policy file
      const policyPath = path.join(workspaceDir, getWorkspacePolicyPath());
      const policyContent = yaml.stringify({
        apiVersion: 'ossa.dev/v1',
        kind: 'ToolPolicy',
        metadata: {
          name: `${options.name}-policy`,
          version: '1.0.0',
        },
        spec: {
          mcp_servers: {
            allowed: [
              {
                name: 'filesystem',
                uri: 'npx -y @modelcontextprotocol/server-filesystem',
                trust: 'high',
                scope: ['read', 'write'],
                directories: ['./src', './docs'],
              },
              {
                name: 'memory',
                uri: 'npx -y @modelcontextprotocol/server-memory',
                trust: 'high',
                scope: ['read', 'write'],
              },
            ],
            denied: [
              {
                pattern: '*shell*',
                reason: 'Direct shell access prohibited',
              },
            ],
          },
          risk_tiers: {
            high: { requires: 'human-approval', audit: 'full' },
            medium: { requires: 'workspace-policy', audit: 'summary' },
            low: { requires: 'none', audit: 'none' },
          },
          boundaries: {
            global_never: [
              '**/.env',
              '**/.env.*',
              '**/secrets/**',
              '**/*.key',
              '**/*.pem',
            ],
          },
        },
      });
      fs.writeFileSync(
        path.join(workspaceDir, 'policies', 'tool-allowlist.yaml'),
        `# OSSA Tool Policy - MCP Server Allowlist\n# Auto-generated by ossa workspace init\n\n${policyContent}`
      );
      console.log(chalk.gray(`  Created ${policyFilePath}`));

      // Create shared-context/README.md
      const sharedContextContent = `# Shared Context

Global conventions and standards that apply to all agents in this workspace.

## Coding Standards
- Follow project-specific linter rules
- Use TypeScript for new code
- Write tests for new functionality

## Security Guidelines
- Never commit secrets
- Use environment variables for configuration
- Follow OWASP Top 10 guidelines

## Documentation
- Update AGENTS.md for agent changes
- Keep manifests in sync with capabilities
`;
      fs.writeFileSync(
        path.join(workspaceDir, 'shared-context', 'README.md'),
        sharedContextContent
      );
      console.log(chalk.gray('  Created shared-context/README.md'));

      console.log('');
      console.log(chalk.green('âœ“ Workspace initialized'));
      console.log('');
      console.log(chalk.blue('Next steps:'));
      console.log(chalk.gray('  1. Run `ossa workspace discover` to find project agents'));
      console.log(chalk.gray('  2. Edit policies/tool-allowlist.yaml to configure allowed tools'));
      console.log(chalk.gray('  3. Run `ossa agent init` in each project to create .agents/'));

      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace list
// ============================================================================
workspaceCommand
  .command('list')
  .description('List agents in workspace registry')
  .option('--json', 'Output as JSON')
  .action(async (options) => {
    try {
      const registryPath = path.resolve(process.cwd(), getDefaultWorkspaceDir(), getWorkspaceRegistryPath());

      if (!fs.existsSync(registryPath)) {
        console.log(chalk.yellow('âš  No workspace registry found'));
        console.log(chalk.gray('  Run `ossa workspace init` first'));
        process.exit(1);
      }

      const content = fs.readFileSync(registryPath, 'utf-8');
      const registry = yaml.parse(content);

      if (options.json) {
        outputJSON(registry);
        process.exit(0);
      }

      console.log(chalk.blue(`Workspace: ${registry.metadata?.name || 'unnamed'}`));
      console.log(chalk.gray('â”€'.repeat(50)));

      const agents = registry.agents || [];
      if (agents.length === 0) {
        console.log(chalk.yellow('No agents registered'));
        console.log(chalk.gray('  Run `ossa workspace discover` to find agents'));
      } else {
        for (const project of agents) {
          console.log(`\n${chalk.cyan(project.project || project.name)}`);
          console.log(chalk.gray(`  Path: ${project.path}`));

          if (project.agents) {
            for (const agent of project.agents) {
              console.log(`  â€¢ ${agent.name}`);
              if (agent.capabilities) {
                console.log(chalk.gray(`    Capabilities: ${agent.capabilities.join(', ')}`));
              }
            }
          } else if (project.capabilities) {
            console.log(chalk.gray(`  Capabilities: ${project.capabilities.join(', ')}`));
          }
        }
      }

      console.log('');
      console.log(chalk.gray(`Total: ${agents.length} project(s)`));
      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace discover
// ============================================================================
workspaceCommand
  .command('discover')
  .description('Auto-discover project agents in workspace')
  .option('--depth <number>', 'Max directory depth to search', '3')
  .option('--dry-run', 'Show what would be discovered without updating registry')
  .action(async (options) => {
    try {
      const cwd = process.cwd();

      console.log(chalk.blue('Discovering agents...'));

      // Find all .agents directories
      const patterns = [
        '**/.agents/manifest.ossa.yaml',
        '**/.agents/*.ossa.yaml',
        '**/agents/*.ossa.yaml',
      ];

      const found: Array<{
        project: string;
        path: string;
        agents: Array<{
          name: string;
          manifest: string;
          capabilities: string[];
          kind?: string;
        }>;
      }> = [];

      for (const pattern of patterns) {
        const files = await glob(pattern, {
          cwd,
          ignore: ['node_modules/**', '**/node_modules/**', 'dist/**', `${getDefaultWorkspaceDir()}/**`],
          maxDepth: parseInt(options.depth, 10),
        });

        for (const file of files) {
          const fullPath = path.resolve(cwd, file);
          const content = fs.readFileSync(fullPath, 'utf-8');
          const manifest = yaml.parse(content);

          if (!manifest?.metadata?.name) continue;

          const projectDir = path.dirname(path.dirname(fullPath));
          const projectName = path.basename(projectDir);
          const relativePath = path.dirname(path.relative(cwd, fullPath));

          // Find or create project entry
          let projectEntry = found.find(p => p.path === relativePath);
          if (!projectEntry) {
            projectEntry = {
              project: projectName,
              path: `./${relativePath}`,
              agents: [],
            };
            found.push(projectEntry);
          }

          // Extract capabilities
          const capabilities: string[] = [];
          if (manifest.spec?.capabilities) {
            for (const cap of manifest.spec.capabilities) {
              if (typeof cap === 'string') {
                capabilities.push(cap);
              } else if (cap.name) {
                capabilities.push(cap.name);
              }
            }
          }

          projectEntry.agents.push({
            name: manifest.metadata.name,
            manifest: `./${path.basename(file)}`,
            capabilities: capabilities.slice(0, 3), // Top 3
            kind: manifest.kind,
          });
        }
      }

      if (found.length === 0) {
        console.log(chalk.yellow('No agents discovered'));
        console.log(chalk.gray('  Create agents with `ossa agent init`'));
        process.exit(0);
      }

      console.log(chalk.gray('â”€'.repeat(50)));
      console.log(`Found ${chalk.cyan(found.length)} project(s) with agents:\n`);

      for (const project of found) {
        console.log(chalk.cyan(project.project));
        console.log(chalk.gray(`  Path: ${project.path}`));
        for (const agent of project.agents) {
          const kindBadge = agent.kind && agent.kind !== 'Agent'
            ? chalk.yellow(` [${agent.kind}]`)
            : '';
          console.log(`  â€¢ ${agent.name}${kindBadge}`);
        }
        console.log('');
      }

      if (options.dryRun) {
        console.log(chalk.yellow('DRY RUN: Registry not updated'));
        process.exit(0);
      }

      // Update registry
      const registryPath = path.resolve(cwd, getDefaultWorkspaceDir(), getWorkspaceRegistryPath());
      if (!fs.existsSync(path.dirname(registryPath))) {
        console.log(chalk.yellow('âš  No workspace found'));
        console.log(chalk.gray('  Run `ossa workspace init` first'));
        process.exit(1);
      }

      const registryContent = fs.readFileSync(registryPath, 'utf-8');
      const registry = yaml.parse(registryContent);
      registry.agents = found;

      fs.writeFileSync(
        registryPath,
        `# OSSA Agent Registry\n# Updated by ossa workspace discover\n\n${yaml.stringify(registry)}`
      );

      console.log(chalk.green('âœ“ Registry updated'));
      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace policy
// ============================================================================
const policyCommand = workspaceCommand
  .command('policy')
  .description('Manage workspace policies');

policyCommand
  .command('list')
  .description('List allowed and denied tools')
  .option('--json', 'Output as JSON')
  .action(async (options) => {
    try {
      const policyPath = path.resolve(
        process.cwd(),
        path.join(getDefaultWorkspaceDir(), getWorkspacePolicyPath())
      );

      if (!fs.existsSync(policyPath)) {
        console.log(chalk.yellow('âš  No policy file found'));
        console.log(chalk.gray('  Run `ossa workspace init` first'));
        process.exit(1);
      }

      const content = fs.readFileSync(policyPath, 'utf-8');
      const policy = yaml.parse(content);

      if (options.json) {
        outputJSON(policy);
        process.exit(0);
      }

      console.log(chalk.blue('Workspace Tool Policy'));
      console.log(chalk.gray('â”€'.repeat(50)));

      const allowed = policy.spec?.mcp_servers?.allowed || [];
      const denied = policy.spec?.mcp_servers?.denied || [];

      console.log(chalk.green('\nAllowed MCP Servers:'));
      for (const server of allowed) {
        const trustColor =
          server.trust === 'high' ? chalk.green :
          server.trust === 'medium' ? chalk.yellow :
          chalk.red;
        console.log(`  ${chalk.cyan(server.name)} ${trustColor(`[${server.trust}]`)}`);
        console.log(chalk.gray(`    Scope: ${(server.scope || []).join(', ')}`));
      }

      console.log(chalk.red('\nDenied Patterns:'));
      for (const pattern of denied) {
        console.log(`  ${chalk.yellow(pattern.pattern)}`);
        console.log(chalk.gray(`    Reason: ${pattern.reason}`));
      }

      const never = policy.spec?.boundaries?.global_never || [];
      if (never.length > 0) {
        console.log(chalk.red('\nGlobal Never (blocked paths):'));
        for (const p of never) {
          console.log(`  ${chalk.gray(p)}`);
        }
      }

      process.exit(0);
    } catch (error) {
      handleCommandError(error);
    }
  });

policyCommand
  .command('check <project>')
  .description('Validate project agent against workspace policies')
  .action(async (project: string) => {
    try {
      const policyPath = path.resolve(
        process.cwd(),
        path.join(getDefaultWorkspaceDir(), getWorkspacePolicyPath())
      );

      if (!fs.existsSync(policyPath)) {
        console.log(chalk.yellow('âš  No policy file found'));
        process.exit(1);
      }

      // Find project manifest
      const manifestPatterns = [
        path.join(project, '.agents', 'manifest.ossa.yaml'),
        path.join(project, '.agents', '*.ossa.yaml'),
        `.agents/${project}.ossa.yaml`,
      ];

      let manifestPath: string | null = null;
      for (const pattern of manifestPatterns) {
        const matches = await glob(pattern, { cwd: process.cwd() });
        if (matches.length > 0) {
          manifestPath = path.resolve(process.cwd(), matches[0]);
          break;
        }
      }

      if (!manifestPath || !fs.existsSync(manifestPath)) {
        console.log(chalk.red(`âœ— No manifest found for project: ${project}`));
        process.exit(1);
      }

      const policy = yaml.parse(fs.readFileSync(policyPath, 'utf-8'));
      const manifest = yaml.parse(fs.readFileSync(manifestPath, 'utf-8'));

      console.log(chalk.blue(`Checking: ${manifest.metadata?.name || project}`));
      console.log(chalk.gray('â”€'.repeat(50)));

      const errors: string[] = [];
      const warnings: string[] = [];

      // Check tool references
      const allowedTools = (policy.spec?.mcp_servers?.allowed || []).map(
        (s: { name: string }) => s.name
      );
      const deniedPatterns = (policy.spec?.mcp_servers?.denied || []).map(
        (d: { pattern: string }) => d.pattern
      );

      const requestedTools = manifest.spec?.tools?.allowed || [];
      for (const tool of requestedTools) {
        const toolName = typeof tool === 'string' ? tool : tool.name;

        // Check if denied
        for (const pattern of deniedPatterns) {
          const regex = new RegExp(pattern.replace('*', '.*'));
          if (regex.test(toolName)) {
            errors.push(`Tool "${toolName}" matches denied pattern "${pattern}"`);
          }
        }

        // Check if allowed
        if (!allowedTools.includes(toolName)) {
          warnings.push(`Tool "${toolName}" not in workspace allowlist`);
        }
      }

      // Check boundaries
      const globalNever = policy.spec?.boundaries?.global_never || [];
      const agentBoundaries = manifest.spec?.boundaries || {};

      for (const boundary of [...(agentBoundaries.read || []), ...(agentBoundaries.write || [])]) {
        for (const never of globalNever) {
          // Simple glob match
          if (boundary.includes(never.replace('**/', '').replace('*', ''))) {
            errors.push(`Boundary "${boundary}" conflicts with global_never "${never}"`);
          }
        }
      }

      // Output results
      if (errors.length === 0 && warnings.length === 0) {
        console.log(chalk.green('âœ“ Agent passes all policy checks'));
        process.exit(0);
      }

      if (errors.length > 0) {
        console.log(chalk.red(`\nâœ— Errors (${errors.length}):`));
        errors.forEach(e => console.log(`  ${chalk.red('â€¢')} ${e}`));
      }

      if (warnings.length > 0) {
        console.log(chalk.yellow(`\nâš  Warnings (${warnings.length}):`));
        warnings.forEach(w => console.log(`  ${chalk.yellow('â€¢')} ${w}`));
      }

      process.exit(errors.length > 0 ? 1 : 0);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace sync
// ============================================================================
workspaceCommand
  .command('sync')
  .description('Sync workspace registry with discovered agents')
  .action(async () => {
    // Just run discover without dry-run
    const discover = workspaceCommand.commands.find(c => c.name() === 'discover');
    if (discover) {
      await discover.parseAsync(['discover'], { from: 'user' });
    }
  });

// ============================================================================
// Subcommand: workspace audit
// ============================================================================
workspaceCommand
  .command('audit')
  .description('Comprehensive workspace audit')
  .option('--json', 'Output as JSON')
  .option('--strict', 'Fail on warnings')
  .action(async (options) => {
    try {
      const cwd = process.cwd();
      const workspaceDir = path.resolve(cwd, '.agents-workspace');

      console.log(chalk.blue('Running workspace audit...'));
      console.log(chalk.gray('â”€'.repeat(50)));

      const auditResults: Array<{
        category: string;
        check: string;
        status: 'pass' | 'fail' | 'warning' | 'info';
        message: string;
        remediation?: string;
      }> = [];

      // Check 1: Workspace structure exists
      if (!fs.existsSync(workspaceDir)) {
        auditResults.push({
          category: 'Structure',
          check: 'Workspace Directory',
          status: 'fail',
          message: `${getDefaultWorkspaceDir()}/ directory does not exist`,
          remediation: 'Run `ossa workspace init` to create workspace structure',
        });
      } else {
        auditResults.push({
          category: 'Structure',
          check: 'Workspace Directory',
          status: 'pass',
          message: `${getDefaultWorkspaceDir()}/ directory exists`,
        });

        // Check required subdirectories
        const requiredDirs = getRequiredWorkspaceDirs();
        for (const dir of requiredDirs) {
          const dirPath = path.join(workspaceDir, dir);
          if (fs.existsSync(dirPath)) {
            auditResults.push({
              category: 'Structure',
              check: `${dir}/ Directory`,
              status: 'pass',
              message: `${dir}/ directory exists`,
            });
          } else {
            auditResults.push({
              category: 'Structure',
              check: `${dir}/ Directory`,
              status: 'warning',
              message: `${dir}/ directory missing`,
              remediation: `Create ${dir}/ directory: mkdir -p ${getDefaultWorkspaceDir()}/${dir}`,
            });
          }
        }
      }

      // Check 2: Registry exists and is valid
      const registryPath = path.resolve(workspaceDir, getWorkspaceRegistryPath());
      if (fs.existsSync(registryPath)) {
        try {
          const content = fs.readFileSync(registryPath, 'utf-8');
          const registry = yaml.parse(content);

          auditResults.push({
            category: 'Registry',
            check: 'Registry File',
            status: 'pass',
            message: `${getWorkspaceRegistryPath()} exists and is valid YAML`,
          });

          // Check registry structure
          if (registry.apiVersion && registry.kind === 'AgentRegistry') {
            auditResults.push({
              category: 'Registry',
              check: 'Registry Schema',
              status: 'pass',
              message: 'Registry follows OSSA schema',
            });
          } else {
            auditResults.push({
              category: 'Registry',
              check: 'Registry Schema',
              status: 'warning',
              message: 'Registry may not follow OSSA schema',
              remediation: 'Ensure registry has apiVersion and kind: AgentRegistry',
            });
          }

          // Check agent count
          const agentCount = Array.isArray(registry.agents) ? registry.agents.length : 0;
          if (agentCount > 0) {
            auditResults.push({
              category: 'Registry',
              check: 'Agent Discovery',
              status: 'pass',
              message: `Registry contains ${agentCount} agent(s)`,
            });
          } else {
            auditResults.push({
              category: 'Registry',
              check: 'Agent Discovery',
              status: 'warning',
              message: 'Registry is empty',
              remediation: 'Run `ossa workspace discover` to find agents',
            });
          }
        } catch (error: any) {
          auditResults.push({
            category: 'Registry',
            check: 'Registry File',
            status: 'fail',
            message: `Failed to parse registry: ${error.message}`,
            remediation: `Check YAML syntax in ${getWorkspaceRegistryPath()}`,
          });
        }
      } else {
        auditResults.push({
          category: 'Registry',
          check: 'Registry File',
          status: 'fail',
          message: `${getWorkspaceRegistryPath()} does not exist`,
          remediation: 'Run `ossa workspace init` to create registry',
        });
      }

      // Check 3: Policies exist
      const policyPath = path.resolve(workspaceDir, getWorkspacePolicyPath());
      if (fs.existsSync(policyPath)) {
        try {
          const content = fs.readFileSync(policyPath, 'utf-8');
          const policy = yaml.parse(content);

          auditResults.push({
            category: 'Policies',
            check: 'Policy File',
            status: 'pass',
            message: `${getWorkspacePolicyPath()} exists and is valid`,
          });

          // Check policy structure
          if (policy.spec?.mcp_servers) {
            const allowed = policy.spec.mcp_servers.allowed || [];
            const denied = policy.spec.mcp_servers.denied || [];

            if (allowed.length > 0) {
              auditResults.push({
                category: 'Policies',
                check: 'Allowed Tools',
                status: 'pass',
                message: `${allowed.length} allowed MCP server(s) configured`,
              });
            } else {
              auditResults.push({
                category: 'Policies',
                check: 'Allowed Tools',
                status: 'warning',
                message: 'No allowed MCP servers configured',
                remediation: `Add allowed MCP servers to ${getWorkspacePolicyPath()}`,
              });
            }

            if (denied.length > 0) {
              auditResults.push({
                category: 'Policies',
                check: 'Denied Tools',
                status: 'pass',
                message: `${denied.length} denied pattern(s) configured`,
              });
            }
          }
        } catch (error: any) {
          auditResults.push({
            category: 'Policies',
            check: 'Policy File',
            status: 'fail',
            message: `Failed to parse policy: ${error.message}`,
            remediation: `Check YAML syntax in ${getWorkspacePolicyPath()}`,
          });
        }
      } else {
        auditResults.push({
          category: 'Policies',
          check: 'Policy File',
          status: 'warning',
          message: `${getWorkspacePolicyPath()} does not exist`,
          remediation: 'Run `ossa workspace init` to create default policy',
        });
      }

      // Check 4: Discover agents and validate manifests
      const patterns = [
        '**/.agents/manifest.ossa.yaml',
        '**/.agents/*.ossa.yaml',
      ];

      const foundManifests: string[] = [];
      for (const pattern of patterns) {
        const files = await glob(pattern, {
          cwd,
          ignore: ['node_modules/**', '**/node_modules/**', 'dist/**', `${getDefaultWorkspaceDir()}/**`],
          maxDepth: 5,
        });
        foundManifests.push(...files);
      }

      if (foundManifests.length > 0) {
        auditResults.push({
          category: 'Agents',
          check: 'Agent Discovery',
          status: 'pass',
          message: `Found ${foundManifests.length} agent manifest(s)`,
        });

        // Validate each manifest
        let validCount = 0;
        let invalidCount = 0;

        for (const manifestFile of foundManifests.slice(0, 10)) {
          try {
            const fullPath = path.resolve(cwd, manifestFile);
            const content = fs.readFileSync(fullPath, 'utf-8');
            const manifest = yaml.parse(content);

            if (manifest?.metadata?.name && manifest?.apiVersion) {
              validCount++;
            } else {
              invalidCount++;
            }
          } catch {
            invalidCount++;
          }
        }

        if (invalidCount === 0) {
          auditResults.push({
            category: 'Agents',
            check: 'Manifest Validation',
            status: 'pass',
            message: `All ${validCount} checked manifest(s) are valid`,
          });
        } else {
          auditResults.push({
            category: 'Agents',
            check: 'Manifest Validation',
            status: 'warning',
            message: `${invalidCount} of ${validCount + invalidCount} manifest(s) have issues`,
            remediation: 'Run `ossa validate` on each manifest to fix issues',
          });
        }
      } else {
        auditResults.push({
          category: 'Agents',
          check: 'Agent Discovery',
          status: 'warning',
          message: 'No agent manifests found',
          remediation: 'Create agents with `ossa agent init` or `ossa generate`',
        });
      }

      // Calculate summary
      const summary = {
        total: auditResults.length,
        passed: auditResults.filter(r => r.status === 'pass').length,
        failed: auditResults.filter(r => r.status === 'fail').length,
        warnings: auditResults.filter(r => r.status === 'warning').length,
        info: auditResults.filter(r => r.status === 'info').length,
      };

      // Output results
      if (options.json) {
        outputJSON({
          workspace: workspaceDir,
          auditDate: new Date().toISOString(),
          summary,
          results: auditResults,
        });
        process.exit(0);
      }

      // Group by category
      const categories = [...new Set(auditResults.map(r => r.category))];

      for (const category of categories) {
        console.log(`\n${chalk.cyan(category)}`);
        const categoryResults = auditResults.filter(r => r.category === category);

        for (const result of categoryResults) {
          const icon =
            result.status === 'pass' ? chalk.green('âœ“') :
            result.status === 'fail' ? chalk.red('âœ—') :
            result.status === 'warning' ? chalk.yellow('âš ') :
            chalk.blue('â„¹');

          console.log(`  ${icon} ${result.check}`);
          console.log(chalk.gray(`    ${result.message}`));
          if (result.remediation) {
            console.log(chalk.gray(`    ðŸ’¡ ${result.remediation}`));
          }
        }
      }

      console.log('\n' + chalk.gray('â”€'.repeat(50)));
      console.log(chalk.blue('Summary:'));
      console.log(chalk.green(`  âœ“ Passed: ${summary.passed}`));
      if (summary.failed > 0) {
        console.log(chalk.red(`  âœ— Failed: ${summary.failed}`));
      }
      if (summary.warnings > 0) {
        console.log(chalk.yellow(`  âš  Warnings: ${summary.warnings}`));
      }
      console.log(chalk.gray(`  Total: ${summary.total}`));

      // Exit code
      const exitCode = summary.failed > 0 || (options.strict && summary.warnings > 0) ? 1 : 0;
      process.exit(exitCode);
    } catch (error) {
      handleCommandError(error);
    }
  });

// ============================================================================
// Subcommand: workspace validate
// ============================================================================
workspaceCommand
  .command('validate')
  .description('Validate workspace structure and configuration')
  .option('--json', 'Output as JSON')
  .option('--strict', 'Fail on warnings')
  .action(async (options) => {
    try {
      const cwd = process.cwd();
      const workspaceDir = path.resolve(cwd, '.agents-workspace');

      console.log(chalk.blue('Validating workspace structure...'));
      console.log(chalk.gray('â”€'.repeat(50)));

      const validationResults: Array<{
        category: string;
        check: string;
        status: 'pass' | 'fail' | 'warning';
        message: string;
        details?: string;
      }> = [];

      // Validate 1: Workspace directory structure
      if (!fs.existsSync(workspaceDir)) {
        validationResults.push({
          category: 'Structure',
          check: 'Workspace Directory',
          status: 'fail',
          message: `${getDefaultWorkspaceDir()}/ directory does not exist`,
          details: 'Run `ossa workspace init` to create workspace',
        });
      } else {
        validationResults.push({
          category: 'Structure',
          check: 'Workspace Directory',
          status: 'pass',
          message: `${getDefaultWorkspaceDir()}/ directory exists`,
        });

        // Validate required subdirectories
        const requiredDirs = [
          { name: 'registry', required: true },
          { name: 'policies', required: true },
          { name: 'orchestration', required: false },
          { name: 'shared-context', required: false },
          { name: 'logs', required: false },
        ];

        for (const dir of requiredDirs) {
          const dirPath = path.join(workspaceDir, dir.name);
          if (fs.existsSync(dirPath)) {
            const stats = fs.statSync(dirPath);
            if (stats.isDirectory()) {
              validationResults.push({
                category: 'Structure',
                check: `${dir.name}/ Directory`,
                status: 'pass',
                message: `${dir.name}/ exists and is a directory`,
              });
            } else {
              validationResults.push({
                category: 'Structure',
                check: `${dir.name}/ Directory`,
                status: 'fail',
                message: `${dir.name}/ exists but is not a directory`,
              });
            }
          } else if (dir.required) {
            validationResults.push({
              category: 'Structure',
              check: `${dir.name}/ Directory`,
              status: 'fail',
              message: `Required directory ${dir.name}/ is missing`,
              details: `Create: mkdir -p ${getDefaultWorkspaceDir()}/${dir.name}`,
            });
          } else {
            validationResults.push({
              category: 'Structure',
              check: `${dir.name}/ Directory`,
              status: 'warning',
              message: `Optional directory ${dir.name}/ is missing`,
            });
          }
        }
      }

      // Validate 2: Registry file structure
      const registryPath = path.resolve(workspaceDir, getWorkspaceRegistryPath());
      if (fs.existsSync(registryPath)) {
        try {
          const content = fs.readFileSync(registryPath, 'utf-8');
          const registry = yaml.parse(content);

          // Validate registry schema
          if (!registry.apiVersion) {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Schema',
              status: 'fail',
              message: 'Registry missing apiVersion field',
              details: 'Add apiVersion: ossa.dev/v1',
            });
          } else if (registry.apiVersion !== 'ossa.dev/v1') {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Schema',
              status: 'warning',
              message: `Registry apiVersion is ${registry.apiVersion}, expected ossa.dev/v1`,
            });
          } else {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Schema',
              status: 'pass',
              message: 'Registry apiVersion is valid',
            });
          }

          if (registry.kind !== 'AgentRegistry') {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Kind',
              status: 'fail',
              message: `Registry kind is ${registry.kind || 'missing'}, expected AgentRegistry`,
              details: 'Set kind: AgentRegistry',
            });
          } else {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Kind',
              status: 'pass',
              message: 'Registry kind is valid',
            });
          }

          if (!Array.isArray(registry.agents)) {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Agents Array',
              status: 'fail',
              message: 'Registry agents field must be an array',
              details: 'Set agents: []',
            });
          } else {
            validationResults.push({
              category: 'Registry',
              check: 'Registry Agents Array',
              status: 'pass',
              message: `Registry contains ${registry.agents.length} agent(s)`,
            });
          }

          // Validate discovery configuration
          if (registry.discovery) {
            if (!registry.discovery.strategy) {
              validationResults.push({
                category: 'Registry',
                check: 'Discovery Strategy',
                status: 'warning',
                message: 'Discovery strategy not specified',
              });
            } else {
              validationResults.push({
                category: 'Registry',
                check: 'Discovery Strategy',
                status: 'pass',
                message: `Discovery strategy: ${registry.discovery.strategy}`,
              });
            }
          }
        } catch (error: any) {
          validationResults.push({
            category: 'Registry',
            check: 'Registry File',
            status: 'fail',
            message: `Failed to parse registry: ${error.message}`,
            details: 'Check YAML syntax',
          });
        }
      } else {
        validationResults.push({
          category: 'Registry',
          check: 'Registry File',
          status: 'fail',
          message: `${getWorkspaceRegistryPath()} does not exist`,
          details: 'Run `ossa workspace init` to create registry',
        });
      }

      // Validate 3: Policy file structure
      const policyPath = path.resolve(workspaceDir, getWorkspacePolicyPath());
      if (fs.existsSync(policyPath)) {
        try {
          const content = fs.readFileSync(policyPath, 'utf-8');
          const policy = yaml.parse(content);

          // Validate policy schema
          if (!policy.apiVersion) {
            validationResults.push({
              category: 'Policies',
              check: 'Policy Schema',
              status: 'fail',
              message: 'Policy missing apiVersion field',
              details: 'Add apiVersion: ossa.dev/v1',
            });
          } else {
            validationResults.push({
              category: 'Policies',
              check: 'Policy Schema',
              status: 'pass',
              message: 'Policy apiVersion is valid',
            });
          }

          if (policy.kind !== 'ToolPolicy') {
            validationResults.push({
              category: 'Policies',
              check: 'Policy Kind',
              status: 'warning',
              message: `Policy kind is ${policy.kind || 'missing'}, expected ToolPolicy`,
            });
          } else {
            validationResults.push({
              category: 'Policies',
              check: 'Policy Kind',
              status: 'pass',
              message: 'Policy kind is valid',
            });
          }

          if (!policy.spec) {
            validationResults.push({
              category: 'Policies',
              check: 'Policy Spec',
              status: 'fail',
              message: 'Policy missing spec field',
              details: 'Add spec: { mcp_servers: { allowed: [], denied: [] } }',
            });
          } else {
            validationResults.push({
              category: 'Policies',
              check: 'Policy Spec',
              status: 'pass',
              message: 'Policy spec exists',
            });

            if (policy.spec.mcp_servers) {
              const allowed = policy.spec.mcp_servers.allowed || [];
              const denied = policy.spec.mcp_servers.denied || [];

              if (allowed.length === 0 && denied.length === 0) {
                validationResults.push({
                  category: 'Policies',
                  check: 'Policy Configuration',
                  status: 'warning',
                  message: 'Policy has no allowed or denied MCP servers configured',
                });
              } else {
                validationResults.push({
                  category: 'Policies',
                  check: 'Policy Configuration',
                  status: 'pass',
                  message: `Policy configured: ${allowed.length} allowed, ${denied.length} denied`,
                });
              }
            } else {
              validationResults.push({
                category: 'Policies',
                check: 'Policy MCP Servers',
                status: 'warning',
                message: 'Policy missing mcp_servers configuration',
              });
            }
          }
        } catch (error: any) {
          validationResults.push({
            category: 'Policies',
            check: 'Policy File',
            status: 'fail',
            message: `Failed to parse policy: ${error.message}`,
            details: 'Check YAML syntax',
          });
        }
      } else {
        validationResults.push({
          category: 'Policies',
          check: 'Policy File',
          status: 'warning',
          message: `${getWorkspacePolicyPath()} does not exist`,
          details: 'Run `ossa workspace init` to create default policy',
        });
      }

      // Calculate summary
      const summary = {
        total: validationResults.length,
        passed: validationResults.filter(r => r.status === 'pass').length,
        failed: validationResults.filter(r => r.status === 'fail').length,
        warnings: validationResults.filter(r => r.status === 'warning').length,
      };

      // Output results
      if (options.json) {
        outputJSON({
          workspace: workspaceDir,
          validationDate: new Date().toISOString(),
          summary,
          results: validationResults,
          valid: summary.failed === 0,
        });
        process.exit(summary.failed > 0 || (options.strict && summary.warnings > 0) ? 1 : 0);
      }

      // Group by category
      const categories = [...new Set(validationResults.map(r => r.category))];

      for (const category of categories) {
        console.log(`\n${chalk.cyan(category)}`);
        const categoryResults = validationResults.filter(r => r.category === category);

        for (const result of categoryResults) {
          const icon =
            result.status === 'pass' ? chalk.green('âœ“') :
            result.status === 'fail' ? chalk.red('âœ—') :
            chalk.yellow('âš ');

          console.log(`  ${icon} ${result.check}`);
          console.log(chalk.gray(`    ${result.message}`));
          if (result.details) {
            console.log(chalk.gray(`    ðŸ’¡ ${result.details}`));
          }
        }
      }

      console.log('\n' + chalk.gray('â”€'.repeat(50)));
      console.log(chalk.blue('Validation Summary:'));
      console.log(chalk.green(`  âœ“ Passed: ${summary.passed}`));
      if (summary.failed > 0) {
        console.log(chalk.red(`  âœ— Failed: ${summary.failed}`));
      }
      if (summary.warnings > 0) {
        console.log(chalk.yellow(`  âš  Warnings: ${summary.warnings}`));
      }
      console.log(chalk.gray(`  Total: ${summary.total}`));

      if (summary.failed === 0) {
        console.log(chalk.green('\nâœ“ Workspace structure is valid'));
      } else {
        console.log(chalk.red('\nâœ— Workspace structure has validation errors'));
      }

      // Exit code
      const exitCode = summary.failed > 0 || (options.strict && summary.warnings > 0) ? 1 : 0;
      process.exit(exitCode);
    } catch (error) {
      handleCommandError(error);
    }
  });
