/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/acdl/register": {
    /** Register agent capabilities */
    post: operations["registerAgent"];
  };
  "/acdl/discover": {
    /** Discover agents by capability */
    post: operations["discoverAgents"];
  };
  "/acdl/match": {
    /** Match agents for task requirements */
    post: operations["matchAgents"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ACDLManifest: {
      /**
       * @description Unique agent identifier following naming convention
       * @example worker-openapi-v1.2.0
       */
      agentId: string;
      /**
       * @description Primary agent classification
       * @enum {string}
       */
      agentType: "orchestrator" | "worker" | "critic" | "judge" | "trainer" | "governor" | "monitor" | "integrator";
      /**
       * @description Detailed agent specialization
       * @example worker.openapi
       */
      agentSubType: string;
      /**
       * @description Semantic version of the agent
       * @example 1.2.0-alpha.1
       */
      version: string;
      capabilities: components["schemas"]["Capabilities"];
      protocols: components["schemas"]["Protocols"];
      performance: components["schemas"]["Performance"];
      requirements?: components["schemas"]["Requirements"];
      metadata?: components["schemas"]["Metadata"];
    };
    Capabilities: {
      /**
       * @description Supported capability domains
       * @example [
       *   "documentation",
       *   "api-design",
       *   "validation"
       * ]
       */
      domains: ("nlp" | "vision" | "reasoning" | "data" | "documentation" | "api-design" | "validation" | "orchestration" | "monitoring" | "security")[];
      operations: {
          /** @example validate */
          name: string;
          /** @example Validate OpenAPI specifications */
          description: string;
          /** @description JSON Schema for operation input */
          inputSchema?: Record<string, never>;
          /** @description JSON Schema for operation output */
          outputSchema?: Record<string, never>;
        }[];
      /**
       * @example {
       *   "openapi": {
       *     "versions": [
       *       "3.0.3",
       *       "3.1.0"
       *     ],
       *     "features": [
       *       "validate",
       *       "generate",
       *       "diff",
       *       "merge"
       *     ]
       *   }
       * }
       */
      specializations?: {
        [key: string]: {
          versions?: string[];
          features?: string[];
        };
      };
    };
    Protocols: {
      supported: ({
          /** @enum {string} */
          name: "rest" | "grpc" | "websocket" | "mcp" | "graphql";
          version: string;
          /** Format: uri */
          endpoint: string;
          authentication?: {
            /** @enum {string} */
            type?: "none" | "api-key" | "oauth2" | "jwt" | "mtls";
            details?: Record<string, never>;
          };
        })[];
      /** @description Preferred protocol for communication */
      preferred?: string;
    };
    Performance: {
      throughput: {
        /** @example 100 */
        requestsPerSecond?: number;
        /** @example 10 */
        concurrentRequests?: number;
      };
      latency: {
        /**
         * @description 50th percentile latency in ms
         * @example 50
         */
        p50?: number;
        /**
         * @description 95th percentile latency in ms
         * @example 150
         */
        p95?: number;
        /**
         * @description 99th percentile latency in ms
         * @example 250
         */
        p99?: number;
      };
      limits?: {
        /**
         * @description Maximum request size in bytes
         * @example 10485760
         */
        maxRequestSize?: number;
        /** @description Maximum response size in bytes */
        maxResponseSize?: number;
        /**
         * @description Request timeout in milliseconds
         * @example 30000
         */
        timeout?: number;
        rateLimits?: {
          requestsPerMinute?: number;
          requestsPerHour?: number;
        };
      };
    };
    Requirements: {
      resources?: {
        cpu?: {
          /** @example 100m */
          requests?: string;
          /** @example 500m */
          limits?: string;
        };
        memory?: {
          /** @example 256Mi */
          requests?: string;
          /** @example 1Gi */
          limits?: string;
        };
        /** @example 10Gi */
        storage?: string;
      };
      dependencies?: ({
          name?: string;
          version?: string;
          /** @enum {string} */
          type?: "service" | "library" | "model" | "database";
        })[];
      environment?: {
        /** @example node:20 */
        runtime?: string;
        /** @enum {string} */
        platform?: "kubernetes" | "docker" | "serverless" | "bare-metal";
      };
    };
    Metadata: {
      /** @description Human-readable agent name */
      name?: string;
      /** @description Detailed agent description */
      description?: string;
      author?: string;
      organization?: string;
      license?: string;
      /** Format: uri */
      repository?: string;
      /** Format: uri */
      documentation?: string;
      tags?: string[];
      /** Format: date-time */
      created?: string;
      /** Format: date-time */
      updated?: string;
      /** @default false */
      deprecated?: boolean;
      deprecationNotice?: string;
    };
    DiscoveryQuery: {
      /** @description Required capability domains */
      domains?: string[];
      /** @description Required operations */
      operations?: string[];
      /** @description Filter by agent type */
      agentType?: string;
      /** @description Required protocol support */
      protocols?: string[];
      performance?: {
        minThroughput?: number;
        maxLatencyP99?: number;
      };
    };
    DiscoveryResponse: {
      agents?: {
          agentId?: string;
          /** @description Match score (0-1) */
          score?: number;
          manifest?: components["schemas"]["ACDLManifest"];
        }[];
      totalFound?: number;
      /** @description Query execution time in ms */
      queryTime?: number;
    };
    MatchRequest: {
      task: {
        type?: string;
        description?: string;
        /** @description Expected duration in ms */
        expectedDuration?: number;
      };
      requirements: {
        capabilities?: components["schemas"]["Capabilities"];
        performance?: components["schemas"]["Performance"];
        constraints?: {
          /** @description Token budget */
          budget?: number;
          /** Format: date-time */
          deadline?: string;
        };
      };
    };
    MatchResponse: {
      matches?: {
          agentId?: string;
          compatibility?: number;
          reasons?: string[];
          warnings?: string[];
        }[];
      recommendation?: {
        primaryAgent?: string;
        alternativeAgents?: string[];
        ensemble?: {
            agentId?: string;
            role?: string;
          }[];
      };
    };
    RegistrationResponse: {
      /** Format: uuid */
      registrationId?: string;
      /** @enum {string} */
      status?: "registered" | "pending" | "rejected";
      validationResults?: {
          check?: string;
          passed?: boolean;
          message?: string;
        }[];
      /** Format: date-time */
      registeredAt?: string;
      /** Format: date-time */
      expiresAt?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Register agent capabilities */
  registerAgent: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ACDLManifest"];
      };
    };
    responses: {
      /** @description Agent registered successfully */
      201: {
        content: {
          "application/json": components["schemas"]["RegistrationResponse"];
        };
      };
    };
  };
  /** Discover agents by capability */
  discoverAgents: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["DiscoveryQuery"];
      };
    };
    responses: {
      /** @description Matching agents found */
      200: {
        content: {
          "application/json": components["schemas"]["DiscoveryResponse"];
        };
      };
    };
  };
  /** Match agents for task requirements */
  matchAgents: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["MatchRequest"];
      };
    };
    responses: {
      /** @description Compatible agents matched */
      200: {
        content: {
          "application/json": components["schemas"]["MatchResponse"];
        };
      };
    };
  };
}
