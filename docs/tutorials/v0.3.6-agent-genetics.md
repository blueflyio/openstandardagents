# Agent Genetics: Evolutionary AI in OSSA v0.3.6

> **Tutorial Level**: Intermediate to Advanced
> **Prerequisites**: Understanding of OSSA manifests, agent lifecycle, and decentralized identity
> **OSSA Version**: v0.3.6+
> **Date**: 2026-01-27

## Table of Contents

1. [Introduction](#introduction)
2. [Conceptual Foundations](#conceptual-foundations)
3. [The Genetics Schema](#the-genetics-schema)
4. [Parent DIDs and Lineage Tracking](#parent-dids-and-lineage-tracking)
5. [Trait Inheritance](#trait-inheritance)
6. [Fitness Scoring](#fitness-scoring)
7. [Breeding Eligibility](#breeding-eligibility)
8. [Practical Applications](#practical-applications)
9. [Working Examples](#working-examples)
10. [Best Practices](#best-practices)
11. [Academic Context](#academic-context)
12. [References](#references)

---

## Introduction

The agent genetics feature in OSSA v0.3.6 represents a revolutionary advancement in autonomous agent development, introducing **evolutionary computation** principles to agent system design. This feature enables agents to evolve, improve, and adapt through selective breeding—a concept inspired by both biological evolution and genetic algorithms in artificial intelligence.

### What is Agent Genetics?

Agent genetics allows you to:

- **Breed new agents** from successful parent agents, combining their best traits
- **Track lineage** through decentralized identifiers (DIDs) across multiple generations
- **Inherit traits** with quantified expression levels (0.0-1.0 scale)
- **Evaluate fitness** across multiple dimensions (speed, accuracy, efficiency, adaptability)
- **Introduce mutations** for controlled innovation and capability enhancement
- **Manage breeding eligibility** through fitness thresholds and generation limits

### Why This Matters

Traditional agent development follows a **design-deploy-iterate** cycle where improvements are manually designed. Agent genetics introduces **evolutionary optimization**:

1. **Automated Improvement**: Agents improve through selection pressure rather than manual redesign
2. **Emergent Capabilities**: Combining traits from multiple parents can produce unexpected synergies
3. **Continuous Adaptation**: Multi-generational evolution enables long-term optimization
4. **Provenance Tracking**: Complete genealogical records ensure transparency and auditability
5. **Quality Control**: Fitness-based breeding ensures only high-performing agents propagate

---

## Conceptual Foundations

### Evolutionary Computation in AI

Agent genetics builds on established principles from evolutionary computation (Eiben & Smith, 2015):

1. **Population**: A set of candidate solutions (agents) with varying performance characteristics
2. **Selection**: High-performing agents are selected as parents for the next generation
3. **Recombination**: Parent traits are combined to create offspring with mixed characteristics
4. **Mutation**: Random or intentional variations introduce novel capabilities
5. **Fitness Evaluation**: Multi-dimensional performance metrics guide selection

### Genetic Algorithms vs. Agent Genetics

Traditional genetic algorithms operate on encoded solutions (bit strings, tree structures). OSSA agent genetics operates at a higher level:

| Aspect | Genetic Algorithms | OSSA Agent Genetics |
|--------|-------------------|---------------------|
| **Representation** | Encoded chromosomes | Structured agent manifests |
| **Traits** | Binary/numeric genes | Named capabilities with expression levels |
| **Fitness** | Single objective function | Multi-dimensional performance metrics |
| **Inheritance** | Crossover operators | Explicit trait attribution to parents |
| **Identity** | Anonymous solutions | Decentralized identifiers (DIDs) |
| **Provenance** | Generation number | Complete genealogical tree |

### Biological Inspiration

The genetics schema draws parallels with biological inheritance:

- **Diploid Organisms**: Two parents contribute traits (like sexual reproduction)
- **Mendelian Inheritance**: Traits are inherited from specific parents
- **Expression Levels**: Analogous to gene expression (phenotype vs. genotype)
- **Fitness Landscape**: Multi-dimensional performance mirrors ecological fitness
- **Generation Tracking**: Similar to phylogenetic trees in evolutionary biology

---

## The Genetics Schema

The complete genetics schema in OSSA v0.3.6:

```yaml
genetics:
  # Generation number (0 = original, 1+ = bred)
  generation: 3

  # Direct parent DIDs (typically 2 for sexual breeding)
  parent_dids:
    - "did:ossa:parent1-fast-reviewer"
    - "did:ossa:parent2-accurate-reviewer"

  # Complete ancestor lineage (grandparents, great-grandparents, etc.)
  ancestor_dids:
    - "did:ossa:grandparent1"
    - "did:ossa:grandparent2"
    - "did:ossa:grandparent3"
    - "did:ossa:grandparent4"

  # Traits inherited from parents
  inherited_traits:
    - trait_name: "fast_analysis"
      source_parent: "did:ossa:parent1-fast-reviewer"
      expression: 0.9  # 0.0-1.0 expression level

    - trait_name: "high_accuracy"
      source_parent: "did:ossa:parent2-accurate-reviewer"
      expression: 0.85

  # Novel variations (beneficial or detrimental)
  mutations:
    - mutation_type: "capability_enhancement"
      description: "Enhanced vulnerability detection"
      beneficial: true

  # Multi-dimensional fitness evaluation
  fitness:
    score: 0.92  # Overall fitness (0.0-1.0)
    metrics:
      speed: 0.95
      accuracy: 0.90
      efficiency: 0.88
      adaptability: 0.94

  # Breeding eligibility criteria
  breeding_eligibility:
    min_fitness_threshold: 0.7
    max_generation: 10
    eligible: true
```

---

## Parent DIDs and Lineage Tracking

### Decentralized Identity for Agents

Every agent with genetics MUST have a unique DID (Decentralized Identifier) following W3C standards:

```yaml
metadata:
  decentralized_identity:
    did: "did:ossa:a1b2c3d4e5f6789012345678901234567890abcd"
    public_key: "ed25519:9a8b7c6d5e4f3210abcdef1234567890fedcba0987654321"
```

**Format**: `did:ossa:[a-z0-9]{32,64}`

### Parent DIDs

The `parent_dids` array references the DIDs of agents that directly contributed to the offspring:

```yaml
genetics:
  parent_dids:
    - "did:ossa:parent1-fast-reviewer"
    - "did:ossa:parent2-accurate-reviewer"
```

**Key Principles**:

1. **Two-Parent Model**: Most breeding uses two parents (sexual reproduction analogy)
2. **Multi-Parent Breeding**: Advanced scenarios may use 3+ parents for complex trait mixing
3. **Single-Parent Cloning**: Asexual reproduction with mutations (`parent_dids: ["did:ossa:original"]`)
4. **Immutability**: Parent DIDs cannot be altered after agent creation

### Ancestor DIDs

The `ancestor_dids` array contains the complete genealogical history:

```yaml
genetics:
  ancestor_dids:
    - "did:ossa:grandparent1"   # Parent1's parent
    - "did:ossa:grandparent2"   # Parent1's other parent
    - "did:ossa:grandparent3"   # Parent2's parent
    - "did:ossa:grandparent4"   # Parent2's other parent
```

**Calculation**: For generation N with 2-parent breeding:
- Generation 0 (original): 0 ancestors
- Generation 1: 2 ancestors (parents)
- Generation 2: 6 ancestors (2 parents + 4 grandparents)
- Generation 3: 14 ancestors (2 parents + 4 grandparents + 8 great-grandparents)
- Generation N: 2^(N+1) - 2 ancestors

### Lineage Queries

With DID-based lineage, you can query:

```bash
# Find all descendants of a high-performing agent
ossa query --filter "genetics.parent_dids contains 'did:ossa:elite-agent'"

# Find agents with specific ancestor
ossa query --filter "genetics.ancestor_dids contains 'did:ossa:founder-agent'"

# Analyze inbreeding (same ancestor appears multiple times)
ossa lineage analyze --did "did:ossa:agent" --check-inbreeding
```

---

## Trait Inheritance

### What is a Trait?

A **trait** is a named capability or performance characteristic that can be inherited from parents. Traits are not just binary (present/absent) but have **expression levels** indicating strength or prominence.

### Trait Schema

```yaml
inherited_traits:
  - trait_name: "fast_analysis"          # Descriptive name
    source_parent: "did:ossa:parent1"    # Which parent contributed this
    expression: 0.9                      # Expression level (0.0-1.0)
```

### Expression Levels (0.0-1.0)

Expression levels quantify how strongly a trait manifests:

| Range | Interpretation | Example |
|-------|---------------|---------|
| **0.0-0.3** | Weak/vestigial | Latent capability, rarely expressed |
| **0.3-0.5** | Moderate | Present but not dominant |
| **0.5-0.7** | Strong | Clearly observable characteristic |
| **0.7-0.9** | Dominant | Primary defining feature |
| **0.9-1.0** | Exceptional | Elite-level expression |

### Trait Inheritance Strategies

#### 1. Direct Inheritance (Simple)

Offspring inherits specific traits from each parent:

```yaml
# Parent 1: Fast but less accurate
genetics:
  fitness:
    metrics:
      speed: 0.95
      accuracy: 0.75

# Parent 2: Accurate but slower
genetics:
  fitness:
    metrics:
      speed: 0.70
      accuracy: 0.95

# Offspring: Inherits best of both
inherited_traits:
  - trait_name: "fast_analysis"
    source_parent: "did:ossa:parent1"
    expression: 0.90  # Slightly reduced from parent

  - trait_name: "high_accuracy"
    source_parent: "did:ossa:parent2"
    expression: 0.92  # Slightly reduced from parent
```

#### 2. Blended Inheritance

Traits blend from both parents:

```yaml
# Both parents have "code_review" trait
# Parent 1: expression 0.8
# Parent 2: expression 0.9
# Offspring: Blended average
inherited_traits:
  - trait_name: "code_review"
    source_parent: "blended"  # Special indicator
    expression: 0.85  # (0.8 + 0.9) / 2
```

#### 3. Dominant/Recessive Traits

Implement Mendelian inheritance:

```yaml
inherited_traits:
  - trait_name: "security_focus"
    source_parent: "did:ossa:parent1"
    expression: 0.95  # Dominant trait (high expression)

  - trait_name: "performance_optimization"
    source_parent: "did:ossa:parent2"
    expression: 0.30  # Recessive (suppressed by dominant)
```

### Trait Categories

#### Performance Traits
- `fast_analysis`: Speed of task completion
- `high_accuracy`: Correctness of outputs
- `efficiency`: Resource utilization (tokens, memory)
- `adaptability`: Ability to handle novel scenarios

#### Capability Traits
- `security_focus`: Emphasis on security analysis
- `code_review_expertise`: Code review proficiency
- `documentation_generation`: Documentation quality
- `multi_language_support`: Language coverage breadth

#### Behavioral Traits
- `conservative_decisions`: Risk-averse behavior
- `creative_problem_solving`: Novel solution generation
- `collaborative_communication`: Multi-agent coordination
- `autonomous_operation`: Independence from human oversight

---

## Fitness Scoring

### Multi-Dimensional Fitness

Unlike single-objective optimization, OSSA genetics uses **multi-dimensional fitness** to evaluate agents across complementary metrics:

```yaml
fitness:
  score: 0.92  # Aggregate score (0.0-1.0)

  metrics:
    speed: 0.95          # Task completion velocity
    accuracy: 0.90       # Correctness of outputs
    efficiency: 0.88     # Resource utilization
    adaptability: 0.94   # Performance on novel tasks
```

### Fitness Dimensions

#### 1. Speed (Velocity)

**Measurement**: Tasks completed per unit time, or time-to-completion for standardized tasks.

```yaml
# Example: Code review agent
speed: 0.95  # Reviews 95% of files faster than median agent
```

**Calculation**:
```python
speed_score = (agent_throughput / population_max_throughput)
```

#### 2. Accuracy (Correctness)

**Measurement**: Precision and recall of agent outputs against ground truth.

```yaml
accuracy: 0.90  # 90% precision/recall on validation set
```

**Calculation**:
```python
accuracy_score = (true_positives + true_negatives) / total_samples
```

#### 3. Efficiency (Resource Utilization)

**Measurement**: Token consumption, memory usage, API calls relative to task complexity.

```yaml
efficiency: 0.88  # Uses 88% fewer tokens than baseline
```

**Calculation**:
```python
efficiency_score = 1 - (agent_token_cost / baseline_token_cost)
```

#### 4. Adaptability (Generalization)

**Measurement**: Performance on novel tasks not in training/breeding data.

```yaml
adaptability: 0.94  # Maintains 94% performance on unseen tasks
```

**Calculation**:
```python
adaptability_score = performance_on_novel_tasks / performance_on_known_tasks
```

### Aggregate Fitness Score

The overall `score` combines individual metrics:

```python
# Weighted average (customize weights for your use case)
weights = {
    'speed': 0.25,
    'accuracy': 0.35,  # Prioritize correctness
    'efficiency': 0.20,
    'adaptability': 0.20
}

aggregate_score = sum(metrics[key] * weights[key] for key in weights)
```

**Example**:
```yaml
fitness:
  metrics:
    speed: 0.95
    accuracy: 0.90
    efficiency: 0.88
    adaptability: 0.94

  # Calculation: 0.95*0.25 + 0.90*0.35 + 0.88*0.20 + 0.94*0.20
  score: 0.92  # Rounded aggregate
```

### Custom Fitness Metrics

Add domain-specific metrics:

```yaml
fitness:
  score: 0.89
  metrics:
    # Standard metrics
    speed: 0.92
    accuracy: 0.88
    efficiency: 0.85
    adaptability: 0.90

    # Custom metrics (domain-specific)
    security_detection_rate: 0.95  # For security agents
    false_positive_rate: 0.03      # Lower is better (invert score)
    code_coverage: 0.87            # For testing agents
    user_satisfaction: 0.91        # For customer service agents
```

---

## Breeding Eligibility

### Purpose

Not all agents should be candidates for breeding. **Breeding eligibility** establishes quality gates to ensure only high-performing agents propagate traits.

### Eligibility Criteria

```yaml
breeding_eligibility:
  min_fitness_threshold: 0.7   # Minimum aggregate fitness score
  max_generation: 10           # Prevent runaway breeding depth
  eligible: true               # Computed result
```

### Fitness Threshold

**Purpose**: Prevent low-performing agents from breeding.

```yaml
min_fitness_threshold: 0.7
```

**Logic**:
```python
if agent.fitness.score >= breeding_eligibility.min_fitness_threshold:
    eligible = True
else:
    eligible = False
```

**Common Thresholds**:
- **0.5**: Permissive (experimental breeding)
- **0.7**: Standard (production systems)
- **0.85**: Strict (elite breeding programs)
- **0.95**: Ultra-selective (research/optimization)

### Maximum Generation

**Purpose**: Prevent excessive breeding depth that may lead to:
- **Diminishing returns**: Performance plateaus after N generations
- **Overfitting**: Agents become too specialized for training data
- **Inbreeding depression**: Limited genetic diversity reduces adaptability

```yaml
max_generation: 10
```

**Logic**:
```python
if agent.genetics.generation < breeding_eligibility.max_generation:
    within_generation_limit = True
```

**Recommended Limits**:
- **5-10**: Most practical applications
- **15-20**: Research and long-term evolution experiments
- **∞** (no limit): Theoretical studies only

### Computed Eligibility

The `eligible` field is computed from all criteria:

```python
eligible = (
    fitness.score >= min_fitness_threshold
    and generation < max_generation
    and lifecycle_stages.current_stage in ['mature', 'senior']
    and not retired
)
```

```yaml
breeding_eligibility:
  eligible: true  # All criteria satisfied
```

### Additional Eligibility Criteria

Extend with custom rules:

```yaml
breeding_eligibility:
  min_fitness_threshold: 0.7
  max_generation: 10

  # Custom criteria
  min_tasks_completed: 1000      # Proven track record
  min_age_hours: 168             # At least 1 week old
  max_mutation_count: 3          # Limit accumulated mutations
  requires_credentials: true     # Must have verifiable credentials
  blacklist_ancestors:           # Exclude problematic lineages
    - "did:ossa:defective-agent-123"

  eligible: true
```

---

## Practical Applications

### Use Case 1: Optimizing Code Review Agents

**Scenario**: You have a slow but accurate reviewer and a fast but less accurate reviewer. Breed them to get the best of both.

**Implementation**:

1. **Identify Parents**:
   ```yaml
   # Parent 1: Fast Reviewer
   did: "did:ossa:fast-reviewer-v1"
   fitness:
     score: 0.75
     metrics:
       speed: 0.95
       accuracy: 0.70

   # Parent 2: Accurate Reviewer
   did: "did:ossa:accurate-reviewer-v1"
   fitness:
     score: 0.80
     metrics:
       speed: 0.65
       accuracy: 0.95
   ```

2. **Breed Offspring**:
   ```yaml
   # Offspring: Balanced Reviewer
   genetics:
     generation: 1
     parent_dids:
       - "did:ossa:fast-reviewer-v1"
       - "did:ossa:accurate-reviewer-v1"
     inherited_traits:
       - trait_name: "fast_analysis"
         source_parent: "did:ossa:fast-reviewer-v1"
         expression: 0.85
       - trait_name: "high_accuracy"
         source_parent: "did:ossa:accurate-reviewer-v1"
         expression: 0.88
     fitness:
       score: 0.87  # Improved over both parents
       metrics:
         speed: 0.85
         accuracy: 0.88
   ```

### Use Case 2: Multi-Generation Evolution

**Scenario**: Evolve security agents over 5 generations to maximize vulnerability detection.

**Implementation**:

```yaml
# Generation 0: Founders (created manually)
# Generation 1: Breed top 20% of founders
# Generation 2: Breed top 20% of Gen 1
# ...
# Generation 5: Elite agents

# Example Gen 5 agent:
genetics:
  generation: 5
  parent_dids:
    - "did:ossa:gen4-agent-elite-1"
    - "did:ossa:gen4-agent-elite-2"
  ancestor_dids:  # 62 total ancestors (2^6 - 2)
    - "did:ossa:gen3-agent-alpha"
    - "did:ossa:gen3-agent-beta"
    # ... 60 more ancestors
  fitness:
    score: 0.96  # Steady improvement across generations
    metrics:
      speed: 0.94
      accuracy: 0.97
      efficiency: 0.95
      adaptability: 0.98
```

### Use Case 3: Specialization Through Mutation

**Scenario**: Introduce targeted mutations to create specialized variants.

**Implementation**:

```yaml
genetics:
  mutations:
    - mutation_type: "capability_enhancement"
      description: "Enhanced SQL injection detection"
      beneficial: true

    - mutation_type: "specialization"
      description: "Focused exclusively on authentication vulnerabilities"
      beneficial: true  # Beneficial for security, but reduces generality

    - mutation_type: "performance_optimization"
      description: "Reduced token consumption by 40%"
      beneficial: true

  fitness:
    score: 0.93
    metrics:
      speed: 0.96  # Faster due to optimization
      accuracy: 0.98  # Higher on specialized domain
      efficiency: 0.94  # More efficient
      adaptability: 0.75  # Lower (trade-off for specialization)
```

### Use Case 4: A/B Testing Agent Variants

**Scenario**: Breed multiple offspring from the same parents, deploy them in parallel, and select the best performer.

**Implementation**:

```bash
# Breed 10 variants from same parent pair
for i in 1..10:
  offspring[i] = breed(parent1, parent2, mutation_rate=0.1)

# Deploy all variants
deploy_parallel(offspring)

# Measure fitness over 1 week
fitness_scores = evaluate(offspring, duration=7days)

# Select top 2 for next generation
elite = select_top_n(offspring, n=2, by=fitness_scores)
```

---

## Working Examples

### Example 1: Simple Two-Parent Breeding

**File**: `examples/v0.3.6-features/genetics-breeding-simple.ossa.yaml`

Demonstrates basic breeding from two parents with complementary traits.

**Key Concepts**:
- Two-parent breeding
- Trait inheritance from specific parents
- Basic fitness evaluation
- Breeding eligibility criteria

### Example 2: Multi-Generation Evolution

**File**: `examples/v0.3.6-features/genetics-breeding-advanced.ossa.yaml`

Demonstrates advanced multi-generation breeding with mutations and complex lineage.

**Key Concepts**:
- Generation tracking (Gen 5)
- Complete ancestor history
- Beneficial mutations
- Fitness progression across generations
- Inbreeding analysis

### Example 3: Fitness-Based Selection

**File**: `examples/v0.3.6-features/genetics-fitness-scoring.ossa.yaml`

Demonstrates comprehensive fitness evaluation and selection strategies.

**Key Concepts**:
- Multi-dimensional fitness
- Custom fitness metrics
- Weighted aggregate scoring
- Comparative fitness analysis
- Tournament selection

---

## Best Practices

### 1. Define Clear Fitness Metrics

**Do**:
```yaml
fitness:
  score: 0.92
  metrics:
    speed: 0.95          # Tasks/hour measured consistently
    accuracy: 0.90       # F1 score on validation set
    efficiency: 0.88     # Token cost / baseline
    adaptability: 0.94   # Performance on novel tasks
```

**Don't**:
```yaml
fitness:
  score: 0.92  # Unclear how this was calculated
```

### 2. Maintain Genetic Diversity

**Problem**: Breeding only the top performer repeatedly (genetic bottleneck).

**Solution**: Use **tournament selection** or **fitness-proportionate selection**:

```python
# Tournament selection: Pick N random agents, breed the best
def tournament_selection(population, tournament_size=5):
    tournament = random.sample(population, tournament_size)
    return max(tournament, key=lambda a: a.fitness.score)

parent1 = tournament_selection(population)
parent2 = tournament_selection(population)
offspring = breed(parent1, parent2)
```

### 3. Track Inbreeding

**Problem**: Same ancestors appear multiple times in lineage.

**Detection**:
```python
def inbreeding_coefficient(agent):
    ancestor_counts = Counter(agent.genetics.ancestor_dids)
    duplicates = sum(count - 1 for count in ancestor_counts.values())
    return duplicates / len(agent.genetics.ancestor_dids)

# If coefficient > 0.3, consider outcrossing
```

### 4. Use Generation Limits

**Recommended**:
```yaml
breeding_eligibility:
  max_generation: 10  # Prevents runaway breeding
```

**Reason**: After ~10 generations, diminishing returns and risk of overfitting.

### 5. Document Mutations

**Best Practice**:
```yaml
mutations:
  - mutation_type: "capability_enhancement"
    description: "Enhanced SQL injection detection via regex refinement"
    beneficial: true
    introduced_at: "2026-01-20T10:00:00Z"
    introduced_by: "did:ossa:breeder-agent"
```

### 6. Validate Fitness Scores

**Test on holdout data**:
```python
# Training set: Used for breeding decisions
training_fitness = evaluate(agent, dataset=training_set)

# Validation set: Unseen data
validation_fitness = evaluate(agent, dataset=validation_set)

# Flag overfitting
if training_fitness - validation_fitness > 0.15:
    warnings.warn("Agent may be overfitted")
```

### 7. Implement Breeding Pipelines

```bash
# Automated breeding pipeline
ossa breed \
  --parent1 "did:ossa:elite-1" \
  --parent2 "did:ossa:elite-2" \
  --mutation-rate 0.05 \
  --output offspring.ossa.yaml

# Evaluate fitness
ossa evaluate \
  --agent offspring.ossa.yaml \
  --dataset validation-set.json \
  --output fitness-report.json

# Conditional registration
if fitness-report.json["score"] >= 0.7:
  ossa register offspring.ossa.yaml
```

---

## Academic Context

### Evolutionary Algorithms in AI

Agent genetics builds on decades of research in evolutionary computation:

1. **Holland (1975)**: Genetic Algorithms for optimization
2. **Koza (1992)**: Genetic Programming for evolving programs
3. **Eiben & Smith (2015)**: Introduction to Evolutionary Computing
4. **Sörensen (2015)**: Metaheuristics — the metaphor exposed

**Key Insight**: Evolution as a search strategy through the space of possible agents.

### Multi-Objective Optimization

OSSA's multi-dimensional fitness aligns with Pareto optimization:

- **Deb et al. (2002)**: NSGA-II (Non-dominated Sorting Genetic Algorithm)
- **Zitzler & Thiele (1999)**: Multi-objective evolutionary algorithms

**Application**: Breeding agents may optimize for conflicting objectives (speed vs. accuracy), requiring Pareto frontier analysis.

### Neuroevolution

Evolving neural network architectures:

- **Stanley & Miikkulainen (2002)**: NEAT (NeuroEvolution of Augmenting Topologies)
- **Real et al. (2019)**: AutoML-Zero (Evolving ML algorithms from scratch)

**Parallel**: OSSA evolves agent configurations rather than neural weights, but principles transfer.

### Genetic Programming

Breeding programs/algorithms:

- **Koza (1992)**: Genetic Programming: On the Programming of Computers by Means of Natural Selection
- **Poli et al. (2008)**: A Field Guide to Genetic Programming

**Analogy**: OSSA manifests are like GP trees, with traits as nodes and breeding as recombination.

### Cultural Evolution

Agents inherit not just genes but learned knowledge:

- **Richerson & Boyd (2005)**: Not by Genes Alone: How Culture Transformed Human Evolution
- **Mesoudi (2011)**: Cultural Evolution: How Darwinian Theory Can Explain Human Culture

**Application**: OSSA agents pass down `knowledge_sources`, `tools`, and `system_prompt` refinements.

---

## References

### Technical Standards

- **W3C DID Core**: https://www.w3.org/TR/did-core/
- **W3C Verifiable Credentials**: https://www.w3.org/TR/vc-data-model/
- **OSSA Specification**: https://gitlab.com/blueflyio/openstandardagents

### Academic Literature

- **Deb, K., et al.** (2002). "A fast and elitist multiobjective genetic algorithm: NSGA-II." *IEEE Transactions on Evolutionary Computation*, 6(2), 182-197.
- **Eiben, A. E., & Smith, J. E.** (2015). *Introduction to Evolutionary Computing* (2nd ed.). Springer.
- **Holland, J. H.** (1975). *Adaptation in Natural and Artificial Systems*. University of Michigan Press.
- **Koza, J. R.** (1992). *Genetic Programming: On the Programming of Computers by Means of Natural Selection*. MIT Press.
- **Mesoudi, A.** (2011). *Cultural Evolution: How Darwinian Theory Can Explain Human Culture*. University of Chicago Press.
- **Poli, R., Langdon, W. B., & McPhee, N. F.** (2008). *A Field Guide to Genetic Programming*. lulu.com.
- **Real, E., et al.** (2019). "AutoML-Zero: Evolving machine learning algorithms from scratch." *arXiv preprint arXiv:2003.03384*.
- **Richerson, P. J., & Boyd, R.** (2005). *Not by Genes Alone: How Culture Transformed Human Evolution*. University of Chicago Press.
- **Stanley, K. O., & Miikkulainen, R.** (2002). "Evolving neural networks through augmenting topologies." *Evolutionary Computation*, 10(2), 99-127.
- **Sörensen, K.** (2015). "Metaheuristics—the metaphor exposed." *International Transactions in Operational Research*, 22(1), 3-18.
- **Zitzler, E., & Thiele, L.** (1999). "Multiobjective evolutionary algorithms: a comparative case study and the strength Pareto approach." *IEEE Transactions on Evolutionary Computation*, 3(4), 257-271.

### OSSA Documentation

- **v0.3.6 Features Overview**: `/docs/v0.3.6-features.md`
- **Migration Guide**: `/spec/v0.3/MIGRATION-v0.3.5-to-v0.3.6.md`
- **Schema Reference**: `/spec/v0.3/ossa-0.3.6.schema.json`
- **Working Examples**:
  - `/examples/v0.3.6-features/genetics-breeding-simple.ossa.yaml`
  - `/examples/v0.3.6-features/genetics-breeding-advanced.ossa.yaml`
  - `/examples/v0.3.6-features/genetics-fitness-scoring.ossa.yaml`

---

## Appendix: Glossary

- **DID (Decentralized Identifier)**: W3C standard for globally unique, cryptographically verifiable identifiers
- **Expression Level**: Quantified strength of a trait (0.0-1.0 scale)
- **Fitness**: Multi-dimensional performance evaluation of an agent
- **Generation**: Number of breeding iterations from original agent (0 = original, 1+ = bred)
- **Lineage**: Complete genealogical history (parents + ancestors)
- **Mutation**: Novel variation introduced during breeding
- **Trait**: Named capability or characteristic inherited from parents

---

**Questions or feedback?** Open an issue at https://gitlab.com/blueflyio/openstandardagents/-/issues

**License**: MIT License — Copyright © 2026 Bluefly IO

---

*This tutorial was created for OSSA v0.3.6 on 2026-01-27. For the latest version, visit the official documentation.*
