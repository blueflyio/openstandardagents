# GitLab CI/CD Pipeline for OSSA
# Decoupled Release Model
# - Code flows freely - Feature ‚Üí development ‚Üí main (CI validates, no auto-release)
# - Website deployment - Manual button (independent of releases)
# - NPM releases - Milestone-gated + ENABLE_RELEASE variable required
#
# Workflow
# 1. Feature branches ‚Üí merge to development (CI validates)
# 2. Development ‚Üí merge to main via merge train (CI validates)
# 3. Click "Deploy Website" button ‚Üí GitLab Pages deploys
# 4. To release - Set ENABLE_RELEASE=true + close milestone ‚Üí automatic npm publish + git tag
#
# Release Gate
# Releases require BOTH conditions
#   - Milestone must be 100% complete and closed

include:
  - local: '.gitlab/ci/agents.yml'
  # TODO: Add merge-train component when gitlab_components is made public/internal
  # - component: gitlab.com/blueflyio/agent-platform/gitlab_components/merge-train@main

#   - CI/CD variable ENABLE_RELEASE must be set to "true"
# This allows deploying to main without releasing. Set the variable only when ready to release.
#
# To set ENABLE_RELEASE
#   GitLab UI - Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Add variable
#   Variable - ENABLE_RELEASE
#   Value - true
#   Protected - Yes (recommended)
#   Masked - No
#
# Status - ACTIVE MODE
# Last updated - 2025-11-25

stages:
  - setup
  - version-detect
  - validate
  - build
  - test
  - quality
  - deploy
  - release
  - mirror

variables:
  NODE_VERSION: "22"
  NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  HUSKY: "0"
  LEFTHOOK: "0"

# ============================================================================
# STAGE 0 - VERSION DETECTION & DEV TAG MANAGEMENT
# ============================================================================

detect:milestone-and-tags:
  stage: version-detect
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set +e  # Don't exit on error - we handle errors manually
      
      echo "DEV TAG MANAGEMENT"
      echo "=================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo "Pipeline: ${CI_PIPELINE_ID}"
      echo ""

      # Initialize env files
      cat > dev-tags.env << 'EOF'
      DEV_TAG_VERSION=
      DEV_TAG_NAME=
      DEV_TAG_BUILD=
      DEV_MILESTONE_ID=
      EOF

      # Only run on main and development branches
      if [ "$CI_COMMIT_BRANCH" != "main" ] && [ "$CI_COMMIT_BRANCH" != "development" ]; then
        echo "Skipping dev tag management (not on main/development branch)"
      else
        # Get all milestones
        DEV_MILESTONES=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data-urlencode "per_page=100" \
          --data-urlencode "state=all" 2>/dev/null || echo "[]")

        if [ "$DEV_MILESTONES" != "[]" ] && [ -n "$DEV_MILESTONES" ]; then
          # Process milestones - use process substitution to avoid subshell
          while read -r dev_milestone_json; do
            [ -z "$dev_milestone_json" ] && continue

            DEV_TITLE=$(echo "$dev_milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
            DEV_ID=$(echo "$dev_milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
            DEV_VERSION=$(echo "$DEV_TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

            [ -z "$DEV_VERSION" ] && continue

        # Skip if already released
            if git tag -l 2>/dev/null | grep -qE "^v?${DEV_VERSION}$"; then
              echo "Skipping ${DEV_VERSION} (already released)"
          continue
        fi

            # Get latest dev tag for this version
            LATEST_DEV_TAG=$(git tag -l "${DEV_VERSION}-dev-*" 2>/dev/null | sort -V | tail -1)
            CURRENT_BUILD=$(echo "$LATEST_DEV_TAG" | sed "s/.*-dev-//" | grep -E '^[0-9]+$' || echo "0")
            [ -z "$CURRENT_BUILD" ] && CURRENT_BUILD=0
            NEXT_BUILD=$((CURRENT_BUILD + 1))

            # Check if we need a new tag
            if [ -n "$LATEST_DEV_TAG" ]; then
              TAG_COMMIT=$(git rev-list -n 1 "$LATEST_DEV_TAG" 2>/dev/null || echo "")
              if [ "$CI_COMMIT_SHA" = "$TAG_COMMIT" ]; then
                echo "No changes since ${LATEST_DEV_TAG}, skipping"
                continue
              fi
            fi

            NEW_TAG="${DEV_VERSION}-dev-${NEXT_BUILD}"
            echo "Creating dev tag: ${NEW_TAG}"

            # Create and push tag
            if git tag -a "$NEW_TAG" -m "Dev build ${NEXT_BUILD} for milestone ${DEV_ID}" "$CI_COMMIT_SHA" 2>/dev/null; then
              if git push origin "$NEW_TAG" 2>/dev/null; then
                echo "Created dev tag: ${NEW_TAG}"
                cat > dev-tags.env << EOF
      DEV_TAG_VERSION=${DEV_VERSION}
      DEV_TAG_NAME=${NEW_TAG}
      DEV_TAG_BUILD=${NEXT_BUILD}
      DEV_MILESTONE_ID=${DEV_ID}
      EOF
              else
                echo "Failed to push tag ${NEW_TAG}"
                git tag -d "$NEW_TAG" 2>/dev/null || true
              fi
            else
              echo "Tag ${NEW_TAG} already exists or failed to create"
            fi

            break  # Only create one dev tag per pipeline
          done < <(echo "$DEV_MILESTONES" | jq -c '.[]' 2>/dev/null || echo "")
        fi
      fi
      
      # Also detect closed milestones for release readiness
      echo ""
      echo "RELEASE READINESS CHECK"
      echo "========================"

      # Get all milestones
      ALL_MILESTONES=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data-urlencode "per_page=100" \
        --data-urlencode "state=all")
      
      # Initialize milestone env file
      cat > milestone-version.env << 'EOF'
      RELEASE_VERSION=
      MILESTONE_TITLE=
      MILESTONE_ID=
      MILESTONE_READY=false
      EOF
      
      # Find closed milestone ready for release - use process substitution to avoid subshell
      FOUND_MILESTONE=false
      while read -r milestone_json; do
        [ -z "$milestone_json" ] && continue
        [ "$FOUND_MILESTONE" = "true" ] && break
      
        TITLE=$(echo "$milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
        ID=$(echo "$milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
        STATE=$(echo "$milestone_json" | jq -r '.state // ""' 2>/dev/null || echo "")
      
        VERSION=$(echo "$TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

        if [ -n "$VERSION" ] && [ "$STATE" = "closed" ]; then
          # Skip if already released
          if git tag -l 2>/dev/null | grep -qE "^v?${VERSION}$"; then
            continue
          fi

          # Get milestone stats
          MILESTONE_STATS=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${ID}" \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" 2>/dev/null || echo "{}")
      
          TOTAL_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.total_issues_count // 0' 2>/dev/null || echo "0")
          CLOSED_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.closed_issues_count // 0' 2>/dev/null || echo "0")
          OPEN_ISSUES=$((TOTAL_ISSUES - CLOSED_ISSUES))

          # Check if 100% complete
          if [ "$OPEN_ISSUES" -eq 0 ] && [ "$TOTAL_ISSUES" -gt 0 ]; then
            cat > milestone-version.env << EOF
      RELEASE_VERSION=${VERSION}
      MILESTONE_TITLE=${TITLE}
      MILESTONE_ID=${ID}
      MILESTONE_READY=true
      EOF
            echo "Release-ready milestone found: v${VERSION}"
            FOUND_MILESTONE=true
            break
          elif [ "$TOTAL_ISSUES" -eq 0 ]; then
            cat > milestone-version.env << EOF
      RELEASE_VERSION=${VERSION}
      MILESTONE_TITLE=${TITLE}
      MILESTONE_ID=${ID}
      MILESTONE_READY=true
      EOF
            echo "Release-ready milestone found: v${VERSION} (empty milestone)"
            FOUND_MILESTONE=true
            break
          fi
        fi
      done < <(echo "$ALL_MILESTONES" | jq -c '.[] | select(.state == "closed")' 2>/dev/null || echo "")
      
      # If no milestone found, ensure env file exists
      if [ ! -s milestone-version.env ]; then
        cat > milestone-version.env << 'EOF'
      RELEASE_VERSION=
      MILESTONE_TITLE=
      MILESTONE_ID=
      MILESTONE_READY=false
      EOF
        echo "‚ÑπÔ∏è  No release-ready milestone found"
      fi
      
      # Merge dev-tags.env into milestone-version.env
      if [ -s dev-tags.env ]; then
        cat dev-tags.env >> milestone-version.env
      fi
      
      echo ""
      echo "üìã Summary:"
      cat milestone-version.env
  artifacts:
    reports:
      dotenv: milestone-version.env
    paths:
      - milestone-version.env
      - dev-tags.env
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "development"
      when: always
  allow_failure: true

# ============================================================================
# STAGE 1 - SETUP & VALIDATE
# ============================================================================

validate:node:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - node --version
    - npm --version
    - echo "Node.js ${NODE_VERSION} ready"
  rules:
    - when: always

validate:ossa:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Validating example manifests..."
    - node dist/cli/index.js validate examples/getting-started/hello-world-complete.ossa.yaml || echo "‚ö†Ô∏è  Validation warnings (non-blocking)"
  allow_failure: true
  rules:
    - when: always

validate:version-sync:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - echo "Checking version consistency..."
    - npm run version:check
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - README.md
      - spec/**/*
      when: always

# ============================================================================
# VERSION MANAGEMENT VIA GITLAB AGENTS (Dogfooding)
# ============================================================================
# TODO: Enable after component is published to main
# include:
#   - component: gitlab.com/blueflyio/openstandardagents/version-management/version-bump-agent@main

# version:bump:agent:
#   extends: .version-bump-agent
#   variables:
#     BUMP_TYPE: "patch"
#     TARGET_BRANCH: "development"
#   rules:
#     - if: '$BUMP_VERSION == "true"'
#       when: manual
#       allow_failure: false
    - if: '$CI_MERGE_REQUEST_TITLE =~ /^chore:.*version/i'
      when: manual
      allow_failure: false

# version:sync:agent:
#   extends: .version-sync-agent
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "push"'
#       when: always
#     - if: '$VERSION_SYNC == "true"'
#       when: manual

# version:consistency:check:
#   extends: .version-consistency-check

validate:scripts-version:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Validating npm scripts use dynamic version..."
      VERSION=$(node -p "require('./package.json').version")
      echo "Current version: ${VERSION}"
      
      # Verify exports["./schema"] matches current version
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"
      ACTUAL_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''")
      if [ "$ACTUAL_EXPORT" != "$EXPECTED_EXPORT" ] && [ -n "$ACTUAL_EXPORT" ]; then
        echo "‚ùå ERROR: package.json exports[\"./schema\"] is \"${ACTUAL_EXPORT}\", should be \"${EXPECTED_EXPORT}\""
        exit 1
      fi

      # Check scripts don't have hardcoded version paths
      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "‚úÖ Scripts field does not contain hardcoded version paths"
      else
        echo "‚ùå ERROR: package.json scripts contain hardcoded version paths"
        exit 1
      fi

      echo "‚úÖ All scripts use dynamic version detection"
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - scripts/**/*
      when: always

validate:docs-consistency:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "üîç Pre-Release Documentation Validation"
      echo "========================================"
      
      VERSION=$(node -p "require('./package.json').version")
      echo "Package version: v${VERSION}"

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo ""
        echo "‚ùå ERROR: Documentation is out of sync!"
        echo ""
        echo "FIX REQUIRED:"
        echo " 1. Run locally: npx tsx scripts/sync-versions.ts --fix"
        echo " 2. Commit the changes"
        echo " 3. Push and re-run pipeline"
        exit 1
      fi

      echo "‚úÖ ALL DOCUMENTATION CONSISTENCY CHECKS PASSED"
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "development"
      when: always

# ============================================================================
# STAGE 2 - BUILD
# ============================================================================

build:dist:
  stage: build
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - test -f dist/cli/index.js || (echo "‚ùå ERROR dist/cli/index.js missing" && exit 1)
    - echo "‚úÖ Build completed"
  artifacts:
    paths:
      - dist/
      - package.json
      - package-lock.json
    expire_in: 1 hour
  rules:
    - when: always

# ============================================================================
# STAGE 3 - TEST
# ============================================================================

test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm run lint || echo "‚ö†Ô∏è  Lint warnings"
    - npm run typecheck || echo "‚ö†Ô∏è  Typecheck warnings"
  allow_failure: true
  rules:
    - when: always

test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - npm run build
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 7 days
  allow_failure: false
  rules:
    - when: always

test:security:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm audit --production || echo "‚ö†Ô∏è  Security vulnerabilities"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 4 - QUALITY GATES
# ============================================================================

quality:gates:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  script:
    - echo "‚úÖ Quality gates passed"
  rules:
    - when: always
  needs:
    - job: test:unit
      optional: true
    - job: test:lint
      optional: true
    - job: test:security
      optional: true

# ============================================================================
# STAGE 5 - DEPLOY (Website - Manual Button)
# ============================================================================

# Review Apps for MRs - Deploy to Kubernetes for preview
review:deploy:
  stage: deploy
  image: node:${NODE_VERSION}-alpine
  needs:
    - job: build:dist
      optional: true
      artifacts: false
  before_script:
    - apk add --no-cache git curl kubectl
    - cd website && npm ci --legacy-peer-deps
  script:
    - |
      echo "üöÄ Deploying Review App for MR !${CI_MERGE_REQUEST_IID}"
      echo "   Branch: ${CI_COMMIT_REF_SLUG}"
      echo "   Namespace: ossa-review-${CI_MERGE_REQUEST_IID}"

      # Build website
      npm run build:no-wiki

      # Create namespace if not exists
      kubectl create namespace ossa-review-${CI_MERGE_REQUEST_IID} --dry-run=client -o yaml | kubectl apply -f -

      # Deploy to k8s (using ConfigMap for static site)
      kubectl create configmap ossa-website-${CI_MERGE_REQUEST_IID} \
        --from-file=out/ \
        --namespace=ossa-review-${CI_MERGE_REQUEST_IID} \
        --dry-run=client -o yaml | kubectl apply -f -

      # Apply deployment manifest
      cat <<EOF | kubectl apply -f -
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ossa-review-${CI_MERGE_REQUEST_IID}
        namespace: ossa-review-${CI_MERGE_REQUEST_IID}
        labels:
          app: ossa-review
          mr: "${CI_MERGE_REQUEST_IID}"
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: ossa-review
        template:
          metadata:
            labels:
              app: ossa-review
          spec:
            containers:
            - name: nginx
              image: nginx:alpine
              ports:
              - containerPort: 80
              volumeMounts:
              - name: website
                mountPath: /usr/share/nginx/html
            volumes:
            - name: website
              configMap:
                name: ossa-website-${CI_MERGE_REQUEST_IID}
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: ossa-review-${CI_MERGE_REQUEST_IID}
        namespace: ossa-review-${CI_MERGE_REQUEST_IID}
      spec:
        selector:
          app: ossa-review
        ports:
        - port: 80
          targetPort: 80
      ---
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: ossa-review-${CI_MERGE_REQUEST_IID}
        namespace: ossa-review-${CI_MERGE_REQUEST_IID}
        annotations:
          kubernetes.io/ingress.class: nginx
      spec:
        rules:
        - host: ossa-mr-${CI_MERGE_REQUEST_IID}.orb.local
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: ossa-review-${CI_MERGE_REQUEST_IID}
                  port:
                    number: 80
      EOF

      echo ""
      echo "‚úÖ Review App deployed!"
      echo "   URL: https://ossa-mr-${CI_MERGE_REQUEST_IID}.orb.local"
  environment:
    name: review/${CI_COMMIT_REF_SLUG}
    url: https://ossa-mr-${CI_MERGE_REQUEST_IID}.orb.local
    deployment_tier: development
    kubernetes:
      namespace: ossa-review-${CI_MERGE_REQUEST_IID}
    on_stop: review:stop
    auto_stop_in: 1 week
  rules:
    - if: $CI_MERGE_REQUEST_IID
      when: manual
      allow_failure: true
  tags:
    - kubernetes

# Stop/cleanup Review App when MR is closed/merged
review:stop:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache kubectl
  script:
    - |
      echo "üßπ Cleaning up Review App for MR !${CI_MERGE_REQUEST_IID}"
      kubectl delete namespace ossa-review-${CI_MERGE_REQUEST_IID} --ignore-not-found=true
      echo "‚úÖ Review App cleaned up"
  environment:
    name: review/${CI_COMMIT_REF_SLUG}
    action: stop
  rules:
    - if: $CI_MERGE_REQUEST_IID
      when: manual
      allow_failure: true
  tags:
    - kubernetes

pages:
  stage: deploy
  image: node:${NODE_VERSION}-alpine
  needs:
    - job: build:dist
      optional: true
      artifacts: false
  before_script:
    - cd website
    - npm ci --legacy-peer-deps
    - apk add --no-cache git curl
    - export GITLAB_HOST="${GITLAB_HOST:-${CI_SERVER_HOST}}"
  script:
    - echo "üåê Building website for GitLab Pages..."
    - npm run sync-wiki || echo "‚ö†Ô∏è  Wiki sync failed (continuing without wiki content)"
    - npm run build:no-wiki
    - |
      if [ ! -d "out" ]; then
        echo "‚ùå ERROR: out/ directory not found"
        exit 1
      fi
    - mkdir -p ../public
    - cp -r out/* ../public/
    - echo "‚úÖ Build artifacts ready"
  artifacts:
    paths:
      - public
    expire_in: 30 days
  environment:
    name: website
    url: https://openstandardagents.org
    deployment_tier: production
    kubernetes:
      namespace: ossa-production
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
    - if: $CI_COMMIT_BRANCH == "development"
      when: manual
      allow_failure: true
    - if: $CI_COMMIT_BRANCH
      when: manual
      allow_failure: true

# ============================================================================
# STAGE 6 - RELEASE (NPM - Milestone-Gated)
# ============================================================================

release:preview:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "üîç Release Preview (Dry-Run)"
      echo "============================"
      
      if [ "$ENABLE_RELEASE" = "true" ]; then
        echo "‚úÖ ENABLE_RELEASE: ${ENABLE_RELEASE} (releases enabled)"
      else
        echo "‚ö†Ô∏è  ENABLE_RELEASE: ${ENABLE_RELEASE:-not set} (releases disabled)"
      fi
      
      if [ -n "$RELEASE_VERSION" ]; then
        echo "üì¶ Detected from closed milestone:"
        echo "   Milestone: ${MILESTONE_TITLE}"
        echo "   Version: v${RELEASE_VERSION}"
        echo "   Ready: ${MILESTONE_READY:-false}"
      fi

      CURRENT_VERSION=$(node -p "require('./package.json').version")
      echo "üìÑ Current package.json: v${CURRENT_VERSION}"
      
      if [ "$ENABLE_RELEASE" = "true" ] && [ "$MILESTONE_READY" = "true" ]; then
        echo "‚úÖ Release will proceed automatically"
      else
        echo "‚ö†Ô∏è  Release blocked (see conditions above)"
      fi
      
      npx semantic-release --dry-run || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  allow_failure: true
  needs:
    - build:dist
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:npm:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
    - detect:milestone-and-tags
  before_script:
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI Release"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
    - git checkout -B main origin/main
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "üöÄ MILESTONE-GATED RELEASE"
      echo "=========================="
      
      # Check ENABLE_RELEASE gate
      if [ "$ENABLE_RELEASE" != "true" ]; then
        echo "üö´ RELEASE BLOCKED: ENABLE_RELEASE not set"
        echo ""
        echo "To enable releases:"
        echo " Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Add variable"
        echo " Variable: ENABLE_RELEASE"
        echo " Value: true"
        exit 0
      fi
      
      # Check milestone readiness
      if [ "$MILESTONE_READY" != "true" ]; then
        echo "üö´ RELEASE BLOCKED: No release-ready milestone"
        echo ""
        echo "Requirements:"
        echo " 1. ‚úÖ ENABLE_RELEASE = true"
        echo " 2. ‚ùå Milestone must be closed and 100% complete"
        exit 0
      fi
      
      echo "‚úÖ Release gate passed"
      echo "   ENABLE_RELEASE: ${ENABLE_RELEASE}"
      echo "   Milestone: ${MILESTONE_TITLE}"
      echo "   Version: v${RELEASE_VERSION}"

      # Update package.json
      npm version ${RELEASE_VERSION} --no-git-tag-version --allow-same-version

      # Sync documentation
      echo "üìù Syncing documentation..."
      npx tsx scripts/sync-versions.ts --fix

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo "‚ùå ERROR: Documentation sync failed"
        exit 1
      fi

      # Configure npm
      GITLAB_HOST="${CI_SERVER_HOST}"
      if [ -n "$NPM_TOKEN" ]; then
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      //registry.npmjs.org/:_authToken=${NPM_TOKEN}
      EOF
      else
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      EOF
      fi

      # Final tests
      echo "üß™ Running final tests..."
      npm run test || (echo "‚ùå Tests failed" && exit 1)

      # Publish to npm
      echo "üì¶ Publishing v${RELEASE_VERSION} to npm..."
      if ! npm publish --access public; then
        echo "‚ùå npm publish failed"
        exit 1
      fi
      
      # Create git tag with comprehensive release information
      PROD_TAG="v${RELEASE_VERSION}"
      RELEASE_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      
      # Extract release notes from CHANGELOG if available
      CHANGELOG_FILE="spec/v${RELEASE_VERSION}/CHANGELOG.md"
      if [ ! -f "$CHANGELOG_FILE" ]; then
        CHANGELOG_FILE="spec/v${RELEASE_VERSION}-RC/CHANGELOG.md"
      fi
      
      if [ -f "$CHANGELOG_FILE" ]; then
        # Extract overview and key features from CHANGELOG
        OVERVIEW=$(grep -A 5 "^## Overview" "$CHANGELOG_FILE" 2>/dev/null | head -6 | tail -5 | sed 's/^/  /' || echo "")
        KEY_FEATURES=$(grep -A 20 "^## What's New" "$CHANGELOG_FILE" 2>/dev/null | head -21 | tail -20 | sed 's/^/  /' || echo "")
      else
        OVERVIEW=""
        KEY_FEATURES=""
      fi
      
      # Build comprehensive tag message using heredoc
      read -r -d '' TAG_MESSAGE << EOF || true
      Release v${RELEASE_VERSION}

      Milestone - ${MILESTONE_TITLE}
      Pipeline - ${CI_PIPELINE_ID}
      Released - ${RELEASE_DATE}
      Commit - ${CI_COMMIT_SHA}

      ${OVERVIEW}

      ${KEY_FEATURES}

      Documentation
      - Schema - https://openstandardagents.org/schema/
      - Changelog - https://github.com/blueflyio/openstandardagents/blob/main/CHANGELOG.md
      - Migration Guide - https://openstandardagents.org/docs/migration-guides/
      - Examples - https://openstandardagents.org/examples/

      npm Package - @bluefly/openstandardagents@${RELEASE_VERSION}
      GitLab Release - https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}
      EOF
      
      git tag -a "$PROD_TAG" -m "$TAG_MESSAGE" "$CI_COMMIT_SHA"
      
      # Commit and push
      git add package.json package-lock.json README.md spec/ || true
      git commit -m "chore(release): v${RELEASE_VERSION} [skip ci]" || echo "No changes to commit"
      git push origin main --tags

      echo "‚úÖ Release v${RELEASE_VERSION} completed!"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true" && $ENABLE_RELEASE == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual
  needs:
    - quality:gates
    - build:dist
    - release:preview
    - validate:docs-consistency
    - detect:milestone-and-tags

# ============================================================================
# STAGE 7 - MIRROR
# ============================================================================

mirror:github:
  stage: mirror
  image: alpine:latest
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
  script:
    - |
      if [ -z "$GITHUB_MIRROR_TOKEN" ]; then
        echo "‚ÑπÔ∏è  GITHUB_MIRROR_TOKEN not set - skipping"
        exit 0
      fi

      echo "üîÑ Syncing to GitHub..."
      git remote add github https://${GITHUB_MIRROR_TOKEN}@github.com/blueflyio/openstandardagents.git || true
      git push github --all --force || true
      git push github --tags --force || true
      echo "‚úÖ GitHub mirror synced"
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true

# ============================================================================
# WORKFLOW
# ============================================================================

workflow:
  rules:
    - if: $CI_COMMIT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG
    - when: always

# ============================================================================
# RELEASE AUTOMATION - Enterprise Grade
# ============================================================================

# Auto-increment dev tag on merge to development
increment-dev-tag:
  stage: .post
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
    - npm install -g tsx
  script:
    - tsx .gitlab/release-automation/scripts/increment-dev-tag.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "development" && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: true

# Manual release buttons (main branch only)
release-to-npm:
  stage: release
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=npm tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production

release-to-github:
  stage: release
  image: node:${NODE_VERSION}
  needs: [release-to-npm]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=github tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: github
    url: https://github.com/blueflyio/openstandardagents
    deployment_tier: production

# OrbStack local website deployment (decoupled from releases)
deploy-website-orbstack:
  stage: deploy
  image: node:${NODE_VERSION}
  needs:
    - job: build:dist
      optional: true
      artifacts: false
  before_script:
    - cd website && npm ci
  script:
    - |
      echo "üöÄ Building website for OrbStack..."
      npm run build:no-wiki
      echo "‚úÖ Build complete"
      echo ""
      echo "üì¶ Website built and ready for OrbStack deployment"
      echo "   URL: https://ossa.orb.local"
      echo ""
      echo "To deploy manually:"
      echo "  rsync -avz out/ orbstack-host:/path/to/ossa/"
  artifacts:
    paths:
      - website/out/
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
    - if: $CI_COMMIT_BRANCH == "development"
      when: manual
    - changes:
        - website/**/*
      when: manual
      allow_failure: true
  environment:
    name: orbstack
    url: https://ossa.orb.local
    deployment_tier: development

# Production website deployment (part of release workflow)
deploy-website-production:
  stage: release
  image: node:${NODE_VERSION}
  needs: [release-to-github]
  before_script:
    - cd website && npm ci
  script:
    - cd website && RELEASE_ACTION=website tsx ../.gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: website
    url: https://openstandardagents.org
    deployment_tier: production

announce-release:
  stage: .post
  image: node:${NODE_VERSION}
  needs: [deploy-website-production]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=announce tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual