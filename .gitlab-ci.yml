# GitLab CI/CD Pipeline for OSSA
# Decoupled Release Model
# - Code flows freely - Feature ‚Üí development ‚Üí main (CI validates, no auto-release)
# - Website deployment - Manual button (independent of releases)
# - NPM releases - Milestone-gated + ENABLE_RELEASE variable required
#
# Workflow
# 1. Feature branches ‚Üí merge to development (CI validates)
# 2. Development ‚Üí merge to main via merge train (CI validates)
# 3. Click "Deploy Website" button ‚Üí GitLab Pages deploys
# 4. To release - Set ENABLE_RELEASE=true + close milestone ‚Üí automatic npm publish + git tag
#
# Release Gate
# Releases require BOTH conditions
#   - Milestone must be 100% complete and closed

include:
  - local: '.gitlab/ci/agents.yml'
  - local: '.gitlab/ci/branch-policy.yml'
  - local: '.gitlab/ci/webhook-agents.yml'  # OSSA v0.2.9 webhook-triggered agents
  - local: '.gitlab/ci/merge-train-optimized.yml'  # Optimized merge train pipeline
  - local: '.gitlab/ci/milestone-workflow.yml'  # Milestone-driven workflow enforcement
  - local: '.gitlab/ci/fix-mr-targets.yml'  # Fix MRs targeting main branch
  # Security scanning from Auto DevOps
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  # Merge trains enabled via workflow rules (see workflow section at bottom)
  # Component available but private - uncomment when gitlab_components is public
  # - component: gitlab.com/blueflyio/agent-platform/gitlab_components/merge-train@main

#   - CI/CD variable ENABLE_RELEASE must be set to "true"
# This allows deploying to main without releasing. Set the variable only when ready to release.
#
# To set ENABLE_RELEASE
#   GitLab UI - Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Add variable
#   Variable - ENABLE_RELEASE
#   Value - true
#   Protected - Yes (recommended)
#   Masked - No
#
# Status - ACTIVE MODE
# Last updated - 2025-11-25

stages:
  - .pre
  - setup
  - version-detect
  - validate
  - build
  - test
  - quality
  - deploy
  - mirror
  - release
  - .post

variables:
  NODE_VERSION: "22"
  NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  HUSKY: "0"
  LEFTHOOK: "0"

# ============================================================================
# STAGE 0 - VERSION DETECTION & DEV TAG MANAGEMENT
# ============================================================================

detect:milestone-and-tags:
  stage: version-detect
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set +e  # Don't exit on error - we handle errors manually

      # Rate-limited API call function with exponential backoff
      safe_api_call() {
        local url="$1"
        local max_retries=3
        local retry=0
        local wait_time=2

        while [ $retry -lt $max_retries ]; do
          local response=$(curl -sS -w "\n%{http_code}" "$url" \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
            "${@:2}")

          local http_code=$(echo "$response" | tail -n1)
          local body=$(echo "$response" | sed '$d')

          if [ "$http_code" = "429" ]; then
            retry=$((retry + 1))
            echo "‚ö†Ô∏è  Rate limit hit, retrying in ${wait_time}s (attempt $retry/$max_retries)" >&2
            sleep $wait_time
            wait_time=$((wait_time * 2))
            continue
          elif [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
            echo "$body"
            return 0
          else
            echo "‚ö†Ô∏è  API call failed with HTTP $http_code" >&2
            retry=$((retry + 1))
            sleep $wait_time
            wait_time=$((wait_time * 2))
            continue
          fi
        done

        echo "[]"
        return 1
      }

      echo "DEV TAG MANAGEMENT"
      echo "=================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo "Pipeline: ${CI_PIPELINE_ID}"
      echo ""

      # Initialize env files
      cat > dev-tags.env << 'EOF'
      DEV_TAG_VERSION=
      DEV_TAG_NAME=
      DEV_TAG_BUILD=
      DEV_MILESTONE_ID=
      EOF

      # Only run on main and development branches
      if [ "$CI_COMMIT_BRANCH" != "main" ] && [ "$CI_COMMIT_BRANCH" != "development" ]; then
        echo "Skipping dev tag management (not on main/development branch)"
      else
        # Get all milestones (with rate limiting)
        DEV_MILESTONES=$(safe_api_call "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
          -G --data-urlencode "per_page=100" --data-urlencode "state=all" || echo "[]")

        if [ "$DEV_MILESTONES" != "[]" ] && [ -n "$DEV_MILESTONES" ]; then
          # Process milestones - use process substitution to avoid subshell
          while read -r dev_milestone_json; do
            [ -z "$dev_milestone_json" ] && continue

            DEV_TITLE=$(echo "$dev_milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
            DEV_ID=$(echo "$dev_milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
            DEV_VERSION=$(echo "$DEV_TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

            [ -z "$DEV_VERSION" ] && continue

        # Skip if already released
            if git tag -l 2>/dev/null | grep -qE "^v?${DEV_VERSION}$"; then
              echo "Skipping ${DEV_VERSION} (already released)"
          continue
        fi

            # Get latest dev tag for this version
            LATEST_DEV_TAG=$(git tag -l "${DEV_VERSION}-dev-*" 2>/dev/null | sort -V | tail -1)
            CURRENT_BUILD=$(echo "$LATEST_DEV_TAG" | sed "s/.*-dev-//" | grep -E '^[0-9]+$' || echo "0")
            [ -z "$CURRENT_BUILD" ] && CURRENT_BUILD=0
            NEXT_BUILD=$((CURRENT_BUILD + 1))

            # Check if we need a new tag
            if [ -n "$LATEST_DEV_TAG" ]; then
              TAG_COMMIT=$(git rev-list -n 1 "$LATEST_DEV_TAG" 2>/dev/null || echo "")
              if [ "$CI_COMMIT_SHA" = "$TAG_COMMIT" ]; then
                echo "No changes since ${LATEST_DEV_TAG}, skipping"
                continue
              fi
            fi

            NEW_TAG="${DEV_VERSION}-dev-${NEXT_BUILD}"
            echo "Creating dev tag: ${NEW_TAG}"

            # Create and push tag
            if git tag -a "$NEW_TAG" -m "Dev build ${NEXT_BUILD} for milestone ${DEV_ID}" "$CI_COMMIT_SHA" 2>/dev/null; then
              if git push origin "$NEW_TAG" 2>/dev/null; then
                echo "Created dev tag: ${NEW_TAG}"
                cat > dev-tags.env << EOF
      DEV_TAG_VERSION=${DEV_VERSION}
      DEV_TAG_NAME=${NEW_TAG}
      DEV_TAG_BUILD=${NEXT_BUILD}
      DEV_MILESTONE_ID=${DEV_ID}
      EOF
              else
                echo "Failed to push tag ${NEW_TAG}"
                git tag -d "$NEW_TAG" 2>/dev/null || true
              fi
            else
              echo "Tag ${NEW_TAG} already exists or failed to create"
            fi

            break  # Only create one dev tag per pipeline
          done < <(echo "$DEV_MILESTONES" | jq -c '.[]' 2>/dev/null || echo "")
        fi
      fi
      
      # Detect ACTIVE milestones ready for release
      # NEW FLOW: Milestone stays ACTIVE, release closes it
      echo ""
      echo "RELEASE READINESS CHECK"
      echo "========================"
      echo "Looking for ACTIVE milestone with all issues closed..."
      echo ""

      # Get ACTIVE milestones only
      ALL_MILESTONES=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data-urlencode "per_page=100" \
        --data-urlencode "state=active")

      # Initialize milestone env file
      echo "RELEASE_VERSION=" > milestone-version.env
      echo "MILESTONE_TITLE=" >> milestone-version.env
      echo "MILESTONE_ID=" >> milestone-version.env
      echo "MILESTONE_URL=" >> milestone-version.env
      echo "MILESTONE_READY=false" >> milestone-version.env
      echo "ISSUE_COUNT=0" >> milestone-version.env
      echo "OPEN_ISSUE_COUNT=0" >> milestone-version.env

      # Find ACTIVE milestone with all issues closed (ready for release)
      FOUND_MILESTONE=false
      while read -r milestone_json; do
        [ -z "$milestone_json" ] && continue
        [ "$FOUND_MILESTONE" = "true" ] && break

        TITLE=$(echo "$milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
        ID=$(echo "$milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
        WEB_URL=$(echo "$milestone_json" | jq -r '.web_url // ""' 2>/dev/null || echo "")

        VERSION=$(echo "$TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

        if [ -n "$VERSION" ]; then
          # Skip if already released (tag exists)
          if git tag -l 2>/dev/null | grep -qE "^v?${VERSION}$"; then
            echo "‚è≠Ô∏è  Skipping ${VERSION} - already released"
            continue
          fi

          # Get milestone stats
          MILESTONE_STATS=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${ID}" \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" 2>/dev/null || echo "{}")

          TOTAL_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.total_issues_count // 0' 2>/dev/null || echo "0")
          CLOSED_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.closed_issues_count // 0' 2>/dev/null || echo "0")
          OPEN_ISSUES=$((TOTAL_ISSUES - CLOSED_ISSUES))

          echo "üìä Milestone: ${TITLE}"
          echo "   Total issues: ${TOTAL_ISSUES}"
          echo "   Closed: ${CLOSED_ISSUES}"
          echo "   Open: ${OPEN_ISSUES}"
          echo ""

          # Check if 100% complete (all issues closed)
          if [ "$OPEN_ISSUES" -eq 0 ] && [ "$TOTAL_ISSUES" -gt 0 ]; then
            echo "RELEASE_VERSION=${VERSION}" > milestone-version.env
            echo "MILESTONE_TITLE=${TITLE}" >> milestone-version.env
            echo "MILESTONE_ID=${ID}" >> milestone-version.env
            echo "MILESTONE_URL=${WEB_URL}" >> milestone-version.env
            echo "MILESTONE_READY=true" >> milestone-version.env
            echo "ISSUE_COUNT=${TOTAL_ISSUES}" >> milestone-version.env
            echo "OPEN_ISSUE_COUNT=0" >> milestone-version.env
            echo "‚úÖ Release-ready: ${TITLE} (${TOTAL_ISSUES} issues closed)"
            FOUND_MILESTONE=true
            break
          elif [ "$TOTAL_ISSUES" -eq 0 ]; then
            echo "‚ö†Ô∏è  Milestone ${TITLE} has no issues - skipping"
          else
            # Milestone has open issues - NOT ready but record for validation
            echo "RELEASE_VERSION=${VERSION}" > milestone-version.env
            echo "MILESTONE_TITLE=${TITLE}" >> milestone-version.env
            echo "MILESTONE_ID=${ID}" >> milestone-version.env
            echo "MILESTONE_URL=${WEB_URL}" >> milestone-version.env
            echo "MILESTONE_READY=false" >> milestone-version.env
            echo "ISSUE_COUNT=${TOTAL_ISSUES}" >> milestone-version.env
            echo "OPEN_ISSUE_COUNT=${OPEN_ISSUES}" >> milestone-version.env
            echo "‚ùå NOT ready: ${OPEN_ISSUES} issues still open"
            echo "   Close all issues before releasing!"
          fi
        fi
      done < <(echo "$ALL_MILESTONES" | jq -c '.[]' 2>/dev/null || echo "")

      # If no milestone found, ensure env file exists
      if [ ! -s milestone-version.env ]; then
        echo "RELEASE_VERSION=" > milestone-version.env
        echo "MILESTONE_TITLE=" >> milestone-version.env
        echo "MILESTONE_ID=" >> milestone-version.env
        echo "MILESTONE_READY=false" >> milestone-version.env
        echo "‚ÑπÔ∏è  No release-ready milestone found"
      fi
      
      # Merge dev-tags.env into milestone-version.env
      if [ -s dev-tags.env ]; then
        cat dev-tags.env >> milestone-version.env
      fi
      
      echo ""
      echo "üìã Summary:"
      cat milestone-version.env
  artifacts:
    reports:
      dotenv: milestone-version.env
    paths:
      - milestone-version.env
      - dev-tags.env
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "development"
      when: always
  allow_failure: true

# ============================================================================
# STAGE 1 - SETUP & VALIDATE
# ============================================================================

validate:node:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - node --version
    - npm --version
    - echo "Node.js ${NODE_VERSION} ready"
  rules:
    - when: always

validate:ossa:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Validating example manifests..."
    - node dist/cli/index.js validate examples/getting-started/hello-world-complete.ossa.yaml || echo "‚ö†Ô∏è  Validation warnings (non-blocking)"
  allow_failure: true
  rules:
    - when: always

validate:gitlab-ci:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      echo "Validating .gitlab-ci.yml syntax..."
      RESPONSE=$(curl -sS --request POST \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        --form "dry_run=true" \
        --form "content=@.gitlab-ci.yml" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/ci/lint")

      VALID=$(echo "$RESPONSE" | jq -r '.valid')
      if [ "$VALID" != "true" ]; then
        echo "‚ùå CI configuration validation failed:"
        echo "$RESPONSE" | jq -r '.errors[]'
        exit 1
      fi
      echo "‚úÖ CI configuration is valid"
  allow_failure: true
  rules:
    - when: always

# Check for divergent branches before merging to protected branches
check:divergence:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      if [ "$CI_MERGE_REQUEST_TARGET_BRANCH" = "main" ] || [ "$CI_MERGE_REQUEST_TARGET_BRANCH" = "development" ]; then
        echo "üîç Checking for divergent branches..."
        git fetch origin
        
        BEHIND=$(git log --oneline origin/$CI_MERGE_REQUEST_SOURCE_BRANCH..origin/$CI_MERGE_REQUEST_TARGET_BRANCH 2>/dev/null | wc -l)
        AHEAD=$(git log --oneline origin/$CI_MERGE_REQUEST_TARGET_BRANCH..origin/$CI_MERGE_REQUEST_SOURCE_BRANCH 2>/dev/null | wc -l)
        
        if [ $BEHIND -gt 0 ] && [ $AHEAD -gt 0 ]; then
          echo "‚ùå DIVERGENT BRANCHES DETECTED"
          echo "Target has $BEHIND commits not in source"
          echo "Source has $AHEAD commits not in target"
          echo "Use squash merge or force push recovery"
          exit 1
        fi
        
        if [ $BEHIND -gt 0 ]; then
          echo "‚ö†Ô∏è  Source behind target by $BEHIND commits"
          exit 1
        fi
        
        echo "‚úÖ No divergence detected"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Check for .DS_Store files
check:ds-store:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      echo "üîç Checking for .DS_Store files..."
      if git diff --name-only $CI_MERGE_REQUEST_DIFF_BASE_SHA 2>/dev/null | grep -q "\.DS_Store"; then
        echo "‚ùå .DS_Store files in MR"
        exit 1
      fi
      echo "‚úÖ No .DS_Store files"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

validate:version-sync:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - echo "Checking version consistency..."
    - npm run version:check
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - README.md
      - spec/**/*
      when: always

# ============================================================================
# VERSION MANAGEMENT VIA GITLAB AGENTS (Dogfooding)
# ============================================================================
# TODO: Enable after component is published to main
# include:
#   - component: gitlab.com/blueflyio/openstandardagents/version-management/version-bump-agent@main

# version:bump:agent:
#   extends: .version-bump-agent
#   variables:
#     BUMP_TYPE: "patch"
#     TARGET_BRANCH: "development"
#   rules:
#     - if: '$BUMP_VERSION == "true"'
#       when: manual
#       allow_failure: false
    - if: '$CI_MERGE_REQUEST_TITLE =~ /^chore:.*version/i'
      when: manual
      allow_failure: false

# version:sync:agent:
#   extends: .version-sync-agent
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "push"'
#       when: always
#     - if: '$VERSION_SYNC == "true"'
#       when: manual

# version:consistency:check:
#   extends: .version-consistency-check

validate:scripts-version:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Validating npm scripts use dynamic version..."
      VERSION=$(node -p "require('./package.json').version")
      echo "Current version: ${VERSION}"
      
      # Verify exports["./schema"] matches current version
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"
      ACTUAL_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''")
      if [ "$ACTUAL_EXPORT" != "$EXPECTED_EXPORT" ] && [ -n "$ACTUAL_EXPORT" ]; then
        echo "‚ùå ERROR: package.json exports[\"./schema\"] is \"${ACTUAL_EXPORT}\", should be \"${EXPECTED_EXPORT}\""
        exit 1
      fi

      # Check scripts don't have hardcoded version paths
      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "‚úÖ Scripts field does not contain hardcoded version paths"
      else
        echo "‚ùå ERROR: package.json scripts contain hardcoded version paths"
        exit 1
      fi

      echo "‚úÖ All scripts use dynamic version detection"
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - scripts/**/*
      when: always

validate:docs-consistency:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "üîç Pre-Release Documentation Validation"
      echo "========================================"
      
      VERSION=$(node -p "require('./package.json').version")
      echo "Package version: v${VERSION}"

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo ""
        echo "‚ùå ERROR: Documentation is out of sync!"
        echo ""
        echo "FIX REQUIRED:"
        echo " 1. Run locally: npx tsx scripts/sync-versions.ts --fix"
        echo " 2. Commit the changes"
        echo " 3. Push and re-run pipeline"
        exit 1
      fi

      echo "‚úÖ ALL DOCUMENTATION CONSISTENCY CHECKS PASSED"
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "development"
      when: always

# ============================================================================
# STAGE 2 - BUILD
# ============================================================================

build:dist:
  stage: build
  image: node:${NODE_VERSION}-alpine
  timeout: 30 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - test -f dist/cli/index.js || (echo "‚ùå ERROR dist/cli/index.js missing" && exit 1)
    - echo "‚úÖ Build completed"
  artifacts:
    paths:
      - dist/
      - package.json
      - package-lock.json
    expire_in: 1 hour
  rules:
    - when: always

# ============================================================================
# STAGE 3 - TEST
# ============================================================================

test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  timeout: 20 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm run lint || echo "‚ö†Ô∏è  Lint warnings"
    - npm run typecheck || echo "‚ö†Ô∏è  Typecheck warnings"
  allow_failure: true
  rules:
    - when: always

test:code-quality:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npx eslint src/ -f json -o eslint-report.json || true
    - node scripts/eslint-to-codequality.cjs
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json
      - eslint-report.json
    expire_in: 7 days
  rules:
    - when: always

test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  timeout: 20 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  dependencies:
    - build:dist
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - npm run build
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: test-results/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
      - test-results/
    expire_in: 7 days
  allow_failure: false
  rules:
    - when: always

test:security:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm audit --production || echo "‚ö†Ô∏è  Security vulnerabilities"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 4 - QUALITY GATES
# ============================================================================

quality:gates:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  script:
    - echo "‚úÖ Quality gates passed"
  rules:
    - when: always
  needs:
    - job: test:unit
      optional: true
    - job: test:lint
      optional: true
    - job: test:security
      optional: true

# ============================================================================
# STAGE 5 - DEPLOY (Removed - Website moved to openstandardagents.org)
# ============================================================================
# Website deployment is now handled by the openstandardagents.org repository.
# This repo (openstandardagents) is the spec/CLI npm package only.

# ============================================================================
# STAGE 6 - RELEASE (NPM - Milestone-Gated)
# ============================================================================

# AUTOMATED CHANGELOG GENERATION (git-cliff)
# Runs on every merge to release branches - generates Keep a Changelog format
changelog:generate:
  stage: release
  image: alpine:latest
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0  # Full history needed for changelog generation
  before_script:
    - apk add --no-cache git curl bash
    # Install git-cliff
    - curl -sSfL https://github.com/orhun/git-cliff/releases/download/v2.7.0/git-cliff-2.7.0-x86_64-unknown-linux-musl.tar.gz | tar xz
    - mv git-cliff-*/git-cliff /usr/local/bin/
    - chmod +x /usr/local/bin/git-cliff
    - git config --global user.email "ci@openstandardagents.org"
    - git config --global user.name "OSSA CI Bot"
  script:
    - |
      echo "Generating changelog with git-cliff..."
      echo "Branch: $CI_COMMIT_BRANCH"
      echo "Commit: $CI_COMMIT_SHA"

      # Generate changelog
      git cliff --output CHANGELOG.md

      # Check if changelog changed
      if git diff --quiet CHANGELOG.md 2>/dev/null; then
        echo "No changelog updates needed"
        exit 0
      fi

      echo "Changelog updated:"
      head -100 CHANGELOG.md

      # Commit and push if there are changes
      git add CHANGELOG.md
      git commit -m "chore(release): update changelog [skip ci]"

      # Push using CI token
      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git"
      git push origin HEAD:$CI_COMMIT_BRANCH

      echo "Changelog committed and pushed"
  rules:
    # Run on merges to release branches
    - if: $CI_COMMIT_BRANCH =~ /^release\/v[0-9]+\.[0-9]+\.x$/
      when: on_success
    # Run on merges to main
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true  # Don't block pipeline if changelog fails

# GENERATE CHANGELOG from milestone issues (legacy - for release notes)
release:changelog:
  stage: release
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - npm install -g tsx
  script:
    - |
      #!/bin/bash
      set -e

      echo "üìù CHANGELOG GENERATION"
      echo "======================="

      if [ "$MILESTONE_READY" != "true" ]; then
        echo "‚ö†Ô∏è  No release-ready milestone - skipping"
        exit 0
      fi

      echo "Milestone: ${MILESTONE_TITLE}"
      echo "Version: v${RELEASE_VERSION}"
      echo "Milestone ID: ${MILESTONE_ID}"
      echo ""

      # Generate changelog from milestone issues
      MILESTONE_ID=${MILESTONE_ID} \
      RELEASE_VERSION=${RELEASE_VERSION} \
      CHANGELOG_OUTPUT="RELEASE_NOTES.md" \
      tsx .gitlab/release-automation/scripts/generate-changelog.ts

      # Also create version-specific changelog
      VERSION_CHANGELOG="spec/v${RELEASE_VERSION}/CHANGELOG.md"
      mkdir -p "spec/v${RELEASE_VERSION}"
      cp RELEASE_NOTES.md "$VERSION_CHANGELOG"

      echo ""
      echo "‚úÖ Changelog generated successfully"
      cat RELEASE_NOTES.md
  artifacts:
    paths:
      - RELEASE_NOTES.md
      - spec/v*/CHANGELOG.md
      - changelog.env
    reports:
      dotenv: changelog.env
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  needs:
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true
  allow_failure: false

# PRE-RELEASE VALIDATION - Critical checks before any release
release:validate:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git jq bash curl
    - npm ci --legacy-peer-deps
  script:
    - |
      #!/bin/bash
      set -e

      echo "üîí PRE-RELEASE VALIDATION"
      echo "========================="
      echo ""

      ERRORS=0
      WARNINGS=0

      # 0. MILESTONE GATE CHECK - All issues must be closed!
      echo "üìã 0. Milestone Gate (All Issues Closed)"
      if [ "$MILESTONE_READY" = "true" ]; then
        echo "   ‚úÖ Milestone ready: ${MILESTONE_TITLE}"
        echo "   ‚úÖ All ${ISSUE_COUNT:-0} issues closed"
      elif [ -n "$MILESTONE_TITLE" ] && [ "${OPEN_ISSUE_COUNT:-0}" -gt 0 ]; then
        echo "   ‚ùå ERROR: Cannot release - ${OPEN_ISSUE_COUNT} issues still OPEN!"
        echo ""
        echo "   Open issues in ${MILESTONE_TITLE}:"
        # Fetch and display open issues
        OPEN_ISSUES_LIST=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues" \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --data-urlencode "milestone=${MILESTONE_TITLE}" \
          --data-urlencode "state=opened" \
          --data-urlencode "per_page=100" 2>/dev/null || echo "[]")

        echo "$OPEN_ISSUES_LIST" | jq -r '.[] | "   - #\(.iid): \(.title)"' 2>/dev/null || echo "   (Could not fetch issues)"
        echo ""
        echo "   üëâ Close all issues before releasing!"
        ERRORS=$((ERRORS + 1))
      elif [ -z "$MILESTONE_TITLE" ]; then
        echo "   ‚ö†Ô∏è  WARNING: No milestone detected"
        echo "   Release will proceed without milestone linkage"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "   ‚ö†Ô∏è  WARNING: Milestone has 0 issues"
        WARNINGS=$((WARNINGS + 1))
      fi
      echo ""

      # 1. VERSION CONSISTENCY CHECK
      echo "üìã 1. Version Consistency"
      VERSION=$(node -p "require('./package.json').version")
      echo "   Package version: v${VERSION}"

      # Check schema exists for this version
      SCHEMA_PATH="spec/v${VERSION}/ossa-${VERSION}.schema.json"
      if [ ! -f "$SCHEMA_PATH" ]; then
        echo "   ‚ùå ERROR: Schema not found: ${SCHEMA_PATH}"
        ERRORS=$((ERRORS + 1))
      else
        echo "   ‚úÖ Schema exists: ${SCHEMA_PATH}"
      fi

      # Check README version badge matches
      if grep -q "v${VERSION}" README.md; then
        echo "   ‚úÖ README version badge matches"
      else
        echo "   ‚ö†Ô∏è  WARNING: README may not reference v${VERSION}"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 2. SCHEMA VALIDATION
      echo ""
      echo "üìã 2. Schema Validation"

      # Check schema is valid JSON
      if jq empty "$SCHEMA_PATH" 2>/dev/null; then
        echo "   ‚úÖ Schema is valid JSON"
      else
        echo "   ‚ùå ERROR: Schema is not valid JSON"
        ERRORS=$((ERRORS + 1))
      fi

      # Check schema has required fields
      SCHEMA_VERSION=$(jq -r '.properties.apiVersion.const // .properties.apiVersion.enum[0] // ""' "$SCHEMA_PATH" 2>/dev/null || echo "")
      if [ -n "$SCHEMA_VERSION" ]; then
        echo "   ‚úÖ Schema apiVersion: ${SCHEMA_VERSION}"
      else
        echo "   ‚ö†Ô∏è  WARNING: Could not detect apiVersion in schema"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 3. EXAMPLES VALIDATION
      echo ""
      echo "üìã 3. Examples Validation"

      EXAMPLE_ERRORS=0
      for example in examples/**/*.ossa.yaml examples/**/*.ossa.json; do
        [ ! -f "$example" ] && continue

        # Check apiVersion matches
        if grep -q "apiVersion.*ossa/v${VERSION}" "$example" 2>/dev/null || \
           jq -e ".apiVersion == \"ossa/v${VERSION}\"" "$example" 2>/dev/null; then
          echo "   ‚úÖ ${example}"
        else
          EXAMPLE_API=$(grep -oE "apiVersion.*ossa/v[0-9.]+" "$example" 2>/dev/null | head -1 || \
                        jq -r '.apiVersion // "unknown"' "$example" 2>/dev/null || echo "unknown")
          echo "   ‚ùå ERROR: ${example} has ${EXAMPLE_API}, expected ossa/v${VERSION}"
          EXAMPLE_ERRORS=$((EXAMPLE_ERRORS + 1))
        fi
      done

      if [ $EXAMPLE_ERRORS -gt 0 ]; then
        echo "   ‚ùå ${EXAMPLE_ERRORS} examples have wrong apiVersion"
        ERRORS=$((ERRORS + EXAMPLE_ERRORS))
      fi

      # 4. BUILD ARTIFACTS CHECK
      echo ""
      echo "üìã 4. Build Artifacts"

      if [ -f "dist/cli/index.js" ]; then
        echo "   ‚úÖ CLI built: dist/cli/index.js"
      else
        echo "   ‚ùå ERROR: CLI not built"
        ERRORS=$((ERRORS + 1))
      fi

      if [ -d "dist/lib" ]; then
        echo "   ‚úÖ Library built: dist/lib/"
      else
        echo "   ‚ö†Ô∏è  WARNING: dist/lib/ not found"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 5. PACKAGE.JSON EXPORTS CHECK
      echo ""
      echo "üìã 5. Package Exports"

      SCHEMA_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''" 2>/dev/null || echo "")
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"

      if [ "$SCHEMA_EXPORT" = "$EXPECTED_EXPORT" ]; then
        echo "   ‚úÖ Schema export correct: ${SCHEMA_EXPORT}"
      elif [ -z "$SCHEMA_EXPORT" ]; then
        echo "   ‚ö†Ô∏è  WARNING: No ./schema export defined"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "   ‚ùå ERROR: Schema export mismatch"
        echo "      Expected: ${EXPECTED_EXPORT}"
        echo "      Got: ${SCHEMA_EXPORT}"
        ERRORS=$((ERRORS + 1))
      fi

      # 6. TEST RUN
      echo ""
      echo "üìã 6. Test Suite"

      if npm run test 2>&1; then
        echo "   ‚úÖ All tests passed"
      else
        echo "   ‚ùå ERROR: Tests failed"
        ERRORS=$((ERRORS + 1))
      fi

      # 7. TYPECHECK
      echo ""
      echo "üìã 7. TypeScript Validation"

      if npm run typecheck 2>&1; then
        echo "   ‚úÖ TypeScript compilation clean"
      else
        echo "   ‚ùå ERROR: TypeScript errors"
        ERRORS=$((ERRORS + 1))
      fi

      # 8. NO HARDCODED VERSIONS IN SCRIPTS
      echo ""
      echo "üìã 8. Script Version Check"

      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "   ‚úÖ No hardcoded versions in scripts"
      else
        echo "   ‚ùå ERROR: Hardcoded versions found in package.json scripts"
        ERRORS=$((ERRORS + 1))
      fi

      # SUMMARY
      echo ""
      echo "========================================"
      echo "üìä VALIDATION SUMMARY"
      echo "========================================"
      echo "   Errors: ${ERRORS}"
      echo "   Warnings: ${WARNINGS}"
      echo ""

      if [ $ERRORS -gt 0 ]; then
        echo "‚ùå RELEASE BLOCKED: ${ERRORS} error(s) must be fixed"
        echo ""
        echo "Fix the errors above before releasing."
        exit 1
      fi

      if [ $WARNINGS -gt 0 ]; then
        echo "‚ö†Ô∏è  RELEASE APPROVED WITH WARNINGS: ${WARNINGS} warning(s)"
      else
        echo "‚úÖ RELEASE APPROVED: All checks passed"
      fi
  artifacts:
    reports:
      dotenv: validation-report.env
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  needs:
    - build:dist
    - test:unit
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:preview:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "üîç Release Preview (Dry-Run)"
      echo "============================"
      
      if [ "$ENABLE_RELEASE" = "true" ]; then
        echo "‚úÖ ENABLE_RELEASE: ${ENABLE_RELEASE} (releases enabled)"
      else
        echo "‚ö†Ô∏è  ENABLE_RELEASE: ${ENABLE_RELEASE:-not set} (releases disabled)"
      fi
      
      if [ -n "$RELEASE_VERSION" ]; then
        echo "üì¶ Detected from closed milestone:"
        echo "   Milestone: ${MILESTONE_TITLE}"
        echo "   Version: v${RELEASE_VERSION}"
        echo "   Ready: ${MILESTONE_READY:-false}"
      fi

      CURRENT_VERSION=$(node -p "require('./package.json').version")
      echo "üìÑ Current package.json: v${CURRENT_VERSION}"
      
      if [ "$ENABLE_RELEASE" = "true" ] && [ "$MILESTONE_READY" = "true" ]; then
        echo "‚úÖ Release will proceed automatically"
      else
        echo "‚ö†Ô∏è  Release blocked (see conditions above)"
      fi
      
      npx semantic-release --dry-run || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  allow_failure: true
  needs:
    - build:dist
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:npm:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 15 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production
    auto_stop_in: never
  dependencies:
    - build:dist
    - detect:milestone-and-tags
    - release:changelog
  before_script:
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI Release"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
    - git checkout -B main origin/main
  script:
    - |
      #!/bin/bash
      set -e

      echo "üöÄ MILESTONE-GATED RELEASE"
      echo "=========================="

      # Check ENABLE_RELEASE gate
      if [ "$ENABLE_RELEASE" != "true" ]; then
        echo "üö´ RELEASE BLOCKED: ENABLE_RELEASE not set"
        echo ""
        echo "To enable releases:"
        echo " Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Add variable"
        echo " Variable: ENABLE_RELEASE"
        echo " Value: true"
        exit 0
      fi

      # Check milestone readiness
      if [ "$MILESTONE_READY" != "true" ]; then
        echo "üö´ RELEASE BLOCKED: No release-ready milestone"
        echo ""
        echo "Requirements:"
        echo " 1. ‚úÖ ENABLE_RELEASE = true"
        echo " 2. ‚ùå Milestone must be closed and 100% complete"
        exit 0
      fi

      echo "‚úÖ Release gate passed"
      echo "   ENABLE_RELEASE: ${ENABLE_RELEASE}"
      echo "   Milestone: ${MILESTONE_TITLE}"
      echo "   Version: v${RELEASE_VERSION}"
      echo "   Issues Closed: ${ISSUE_COUNT:-0}"

      # Update package.json
      npm version ${RELEASE_VERSION} --no-git-tag-version --allow-same-version

      # Sync documentation
      echo "üìù Syncing documentation..."
      npx tsx scripts/sync-versions.ts --fix

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo "‚ùå ERROR: Documentation sync failed"
        exit 1
      fi

      # Configure npm
      GITLAB_HOST="${CI_SERVER_HOST}"
      if [ -n "$NPM_TOKEN" ]; then
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      //registry.npmjs.org/:_authToken=${NPM_TOKEN}
      EOF
      else
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      EOF
      fi

      # Final tests
      echo "üß™ Running final tests..."
      npm run test || (echo "‚ùå Tests failed" && exit 1)

      # Publish to npm
      echo "üì¶ Publishing v${RELEASE_VERSION} to npm..."
      if ! npm publish --access public; then
        echo "‚ùå npm publish failed"
        exit 1
      fi

      # Create git tag with comprehensive release information
      PROD_TAG="v${RELEASE_VERSION}"
      RELEASE_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

      # Load changelog content if available
      CHANGELOG_CONTENT=""
      if [ -f "RELEASE_NOTES.md" ]; then
        CHANGELOG_CONTENT=$(cat RELEASE_NOTES.md)
      fi

      # Build comprehensive tag message using heredoc
      read -r -d '' TAG_MESSAGE << EOF || true
      Release v${RELEASE_VERSION}

      Milestone: ${MILESTONE_TITLE}
      Issues Closed: ${ISSUE_COUNT:-0}
      Pipeline: ${CI_PIPELINE_ID}
      Released: ${RELEASE_DATE}
      Commit: ${CI_COMMIT_SHA}

      See full changelog: https://gitlab.com/${CI_PROJECT_PATH}/-/blob/main/spec/v${RELEASE_VERSION}/CHANGELOG.md

      Links:
      - npm Package: https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}
      - Documentation: https://openstandardagents.org/
      - Milestone: ${MILESTONE_URL:-https://gitlab.com/${CI_PROJECT_PATH}/-/milestones}
      EOF

      git tag -a "$PROD_TAG" -m "$TAG_MESSAGE" "$CI_COMMIT_SHA"

      # Commit and push
      git add package.json package-lock.json README.md spec/ RELEASE_NOTES.md || true
      git commit -m "chore(release): v${RELEASE_VERSION} [skip ci]" || echo "No changes to commit"
      git push origin main --tags

      # Create GitLab Release with auto-generated changelog
      echo "üìã Creating GitLab Release with milestone integration..."

      # Prepare changelog for release description
      RELEASE_DESCRIPTION="${CHANGELOG_CONTENT}"

      # If no changelog, use fallback
      if [ -z "$RELEASE_DESCRIPTION" ]; then
        RELEASE_DESCRIPTION="## Release v${RELEASE_VERSION}\n\nMilestone: ${MILESTONE_TITLE} (${MILESTONE_URL})\n\nSee CHANGELOG.md for details."
      fi

      # Create release with milestone linkage
      RELEASE_PAYLOAD=$(jq -n \
        --arg name "Release v${RELEASE_VERSION}" \
        --arg tag "v${RELEASE_VERSION}" \
        --arg desc "$RELEASE_DESCRIPTION" \
        --arg milestone "${MILESTONE_TITLE}" \
        --arg npm_url "https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}" \
        --arg schema_url "https://openstandardagents.org/schema/" \
        --arg docs_url "https://openstandardagents.org/" \
        --arg milestone_url "${MILESTONE_URL}" \
        '{
          name: $name,
          tag_name: $tag,
          description: $desc,
          milestones: [$milestone],
          assets: {
            links: [
              {
                name: "npm package",
                url: $npm_url,
                link_type: "package"
              },
              {
                name: "JSON Schema",
                url: $schema_url,
                link_type: "other"
              },
              {
                name: "Documentation",
                url: $docs_url,
                link_type: "other"
              },
              {
                name: "Milestone",
                url: $milestone_url,
                link_type: "other"
              }
            ]
          }
        }')

      curl --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "$RELEASE_PAYLOAD" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases"

      echo "‚úÖ GitLab Release created: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"

      # CLOSE THE MILESTONE after successful release
      echo ""
      echo "üîí Closing milestone: ${MILESTONE_TITLE}..."
      if [ -n "$MILESTONE_ID" ]; then
        CLOSE_RESULT=$(curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --header "Content-Type: application/json" \
          --data '{"state_event": "close"}' \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${MILESTONE_ID}" 2>/dev/null)

        CLOSE_STATE=$(echo "$CLOSE_RESULT" | jq -r '.state // "unknown"' 2>/dev/null)
        if [ "$CLOSE_STATE" = "closed" ]; then
          echo "‚úÖ Milestone closed successfully"
        else
          echo "‚ö†Ô∏è  Could not close milestone (state: ${CLOSE_STATE})"
          echo "   Manual close required: ${MILESTONE_URL}"
        fi
      else
        echo "‚ö†Ô∏è  No MILESTONE_ID - cannot close milestone"
      fi

      echo ""
      echo "‚úÖ Release v${RELEASE_VERSION} completed!"
      echo ""
      echo "üìä Release Summary:"
      echo "   Version: v${RELEASE_VERSION}"
      echo "   Milestone: ${MILESTONE_TITLE} (CLOSED)"
      echo "   Issues: ${ISSUE_COUNT:-0}"
      echo "   npm: https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}"
      echo "   Release: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"
      echo "   Milestone: ${MILESTONE_URL}"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true" && $ENABLE_RELEASE == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual
  needs:
    - quality:gates
    - build:dist
    - release:preview
    - release:validate
    - release:changelog
    - validate:docs-consistency
    - detect:milestone-and-tags

create-patch-version:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache git curl
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
  script:
    - |
      echo "üì¶ Automated Patch Version Creation"
      echo "===================================="

      # Extract version from branch name (e.g., release/v0.1.x -> 0.1)
      BRANCH_VERSION=$(echo "$CI_COMMIT_BRANCH" | sed -E 's/release\/v?([0-9]+\.[0-9]+)\.x/\1/')

      if [ -z "$BRANCH_VERSION" ] || [ "$BRANCH_VERSION" = "$CI_COMMIT_BRANCH" ]; then
        echo "‚ö†Ô∏è  Not a release branch format (release/v0.X.x)"
        exit 0
      fi

      echo "Release series: v${BRANCH_VERSION}.x"

      # Get latest tag for this release series
      LATEST_TAG=$(git tag -l "v${BRANCH_VERSION}.*" | sort -V | tail -n1)

      if [ -z "$LATEST_TAG" ]; then
        NEW_TAG="v${BRANCH_VERSION}.0"
        echo "No existing tags for v${BRANCH_VERSION}.x series"
      else
        echo "Latest tag: $LATEST_TAG"

        # Check if HEAD is already tagged
        HEAD_TAGS=$(git tag --points-at HEAD)
        if echo "$HEAD_TAGS" | grep -q "^v${BRANCH_VERSION}"; then
          echo "‚úÖ HEAD already has tag: $HEAD_TAGS"
          exit 0
        fi

        # Increment patch version
        PATCH=$(echo "$LATEST_TAG" | sed -E "s/v${BRANCH_VERSION}\.([0-9]+)/\1/")
        NEW_PATCH=$((PATCH + 1))
        NEW_TAG="v${BRANCH_VERSION}.${NEW_PATCH}"
      fi

      echo ""
      echo "üè∑Ô∏è  Creating new tag: $NEW_TAG"

      # Create annotated tag
      git tag -a "$NEW_TAG" -m "Release $NEW_TAG from $CI_COMMIT_BRANCH

      Commit: $CI_COMMIT_SHA
      Pipeline: $CI_PIPELINE_URL
      Branch: $CI_COMMIT_BRANCH"

      # Push tag
      if git push origin "$NEW_TAG"; then
        echo "‚úÖ Successfully created and pushed tag: $NEW_TAG"
      else
        echo "‚ùå Failed to push tag"
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v[0-9]+\.[0-9]+\.x$/ && $CI_PIPELINE_SOURCE == "push"
      when: manual  # Manual so you can review before creating tag
  allow_failure: true

create-release:
  stage: release
  image: registry.gitlab.com/gitlab-org/cli:latest
  script:
    - |
      echo "üìã Creating GitLab Release for $CI_COMMIT_TAG"

      # Extract version number
      VERSION=$(echo "$CI_COMMIT_TAG" | sed 's/^v//')

      # Load changelog if available
      DESCRIPTION="Release $CI_COMMIT_TAG"
      if [ -f "CHANGELOG.md" ]; then
        # Extract this version's section from CHANGELOG
        DESCRIPTION=$(awk "/^## \[${VERSION}\]/,/^## \[/{if (/^## \[${VERSION}\]/) next; if (/^## \[/) exit; print}" CHANGELOG.md || echo "Release $CI_COMMIT_TAG")
      fi

      echo "Creating release with description:"
      echo "$DESCRIPTION"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: "Release $CI_COMMIT_TAG of components in $CI_PROJECT_PATH"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/  # Only semantic version tags
      when: on_success

# ============================================================================
# STAGE 7 - MIRROR
# ============================================================================

mirror:github:
  stage: mirror
  image: alpine:latest
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
  script:
    - |
      # Use GH_TOKEN (group variable) or GITHUB_MIRROR_TOKEN (legacy)
      MIRROR_TOKEN="${GH_TOKEN:-$GITHUB_MIRROR_TOKEN}"

      if [ -z "$MIRROR_TOKEN" ]; then
        echo "‚ÑπÔ∏è  No GitHub token set (GH_TOKEN or GITHUB_MIRROR_TOKEN) - skipping"
        exit 0
      fi

      echo "üîÑ Syncing to GitHub..."
      git remote add github https://${MIRROR_TOKEN}@github.com/blueflyio/openstandardagents.git || true
      git push github --all --force || true
      git push github --tags --force || true
      echo "‚úÖ GitHub mirror synced"
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true

# ============================================================================
# POST-RELEASE CLEANUP
# ============================================================================
# After successful release:
# 1. Tag all issues with released::v{VERSION}
# 2. Tag all MRs with released::v{VERSION}
# 3. Create next milestone (patch increment)

post-release:cleanup:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      #!/bin/bash
      set -e

      echo "üßπ POST-RELEASE CLEANUP"
      echo "======================="

      # Check if release just happened
      if [ -z "$RELEASE_VERSION" ] || [ -z "$MILESTONE_ID" ]; then
        echo "‚ÑπÔ∏è  No release detected - skipping cleanup"
        exit 0
      fi

      VERSION="${RELEASE_VERSION}"
      LABEL_NAME="released::v${VERSION}"

      echo "üìå Version: v${VERSION}"
      echo "üìå Milestone: ${MILESTONE_TITLE}"
      echo ""

      # 1. Create release label if not exists
      echo "Creating label: ${LABEL_NAME}"
      curl --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data "name=${LABEL_NAME}&color=#00FF00&description=Released in v${VERSION}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/labels" 2>/dev/null || echo "Label may already exist"

      # 2. Tag all closed issues in milestone
      echo ""
      echo "üìå Tagging issues..."
      ISSUES=$(curl -sS -G \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues" \
        --data-urlencode "milestone=${MILESTONE_TITLE}" \
        --data-urlencode "state=closed" \
        --data-urlencode "per_page=100")

      echo "$ISSUES" | jq -r '.[].iid' | while read ISSUE_IID; do
        [ -z "$ISSUE_IID" ] && continue
        curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --data "add_labels=${LABEL_NAME}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues/${ISSUE_IID}" > /dev/null
        echo "  ‚úì Tagged issue #${ISSUE_IID}"
      done

      # 3. Tag all merged MRs in milestone
      echo ""
      echo "üìå Tagging merge requests..."
      MRS=$(curl -sS -G \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests" \
        --data-urlencode "milestone=${MILESTONE_TITLE}" \
        --data-urlencode "state=merged" \
        --data-urlencode "per_page=100")

      echo "$MRS" | jq -r '.[].iid' | while read MR_IID; do
        [ -z "$MR_IID" ] && continue
        curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --data "add_labels=${LABEL_NAME}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${MR_IID}" > /dev/null
        echo "  ‚úì Tagged MR !${MR_IID}"
      done

      # 4. Create next milestone (patch increment)
      echo ""
      echo "üìÖ Creating next milestone..."
      NEXT_VERSION=$(echo "$VERSION" | awk -F. '{print $1"."$2"."$3+1}')

      NEXT_MILESTONE=$(curl -sS --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"title\": \"v${NEXT_VERSION}\",
          \"description\": \"Next patch release (auto-created after v${VERSION})\"
        }" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" 2>/dev/null)

      NEXT_ID=$(echo "$NEXT_MILESTONE" | jq -r '.id // empty')
      if [ -n "$NEXT_ID" ]; then
        echo "  ‚úì Created milestone v${NEXT_VERSION}"
      else
        echo "  ‚ö†Ô∏è  Milestone v${NEXT_VERSION} may already exist"
      fi

      echo ""
      echo "‚úÖ POST-RELEASE CLEANUP COMPLETE"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true" && $ENABLE_RELEASE == "true"
      when: on_success
  needs:
    - job: release:npm
      artifacts: true
    - job: detect:milestone-and-tags
      artifacts: true
  allow_failure: true

# ============================================================================
# WORKFLOW - MERGE TRAINS ENABLED
# ============================================================================
# Merge trains prevent branch divergence by:
# 1. Queuing MRs instead of racing to merge
# 2. Testing merged state before allowing merge
# 3. Auto-rebasing when target branch updates
# 4. Failing fast on conflicts
#
# Enabled for: development, main branches
# Eliminates: Manual sync commits between releases
# See: https://docs.gitlab.com/ee/ci/pipelines/merge_trains.html
# ============================================================================

workflow:
  rules:
    # Merge train pipelines (combined state testing)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merge_train"
    # Merged result pipelines (pre-merge validation)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"
    # Regular MR pipelines
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # Prevent duplicate pipelines (skip branch pipeline if MR is open)
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    # Regular branch pipelines
    - if: $CI_COMMIT_BRANCH
    # Tag pipelines
    - if: $CI_COMMIT_TAG
    - when: always

# ============================================================================
# RELEASE AUTOMATION - Enterprise Grade
# ============================================================================

# Auto-increment dev tag on merge to development
increment-dev-tag:
  stage: .post
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
    - npm install -g tsx
  script:
    - tsx .gitlab/release-automation/scripts/increment-dev-tag.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "development" && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: true

# Manual release buttons (main branch only)
release-to-npm:
  stage: release
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=npm tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production

release-to-github:
  stage: release
  image: node:${NODE_VERSION}
  needs: [release-to-npm]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=github tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: github
    url: https://github.com/blueflyio/openstandardagents
    deployment_tier: production

# Website deployment moved to openstandardagents.org repository
# See: https://gitlab.com/blueflyio/openstandardagents.org

announce-release:
  stage: .post
  image: node:${NODE_VERSION}
  needs: [release-to-github]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=announce tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
# ============================================================================
# AUTOMATED RELEASE MR CREATION
# ============================================================================

create-release-mrs:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      echo "üöÄ Checking for milestones needing release MRs..."
      
      MILESTONES=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/milestones?state=active")
      
      echo "$MILESTONES" | jq -r '.[] | select(.title | startswith("v")) | .id + " " + .title' | while read MILESTONE_ID MILESTONE_TITLE; do
        EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened&source_branch=development&target_branch=main&milestone=$MILESTONE_TITLE" \
          | jq -r '.[0].iid // empty')
        
        if [ -z "$EXISTING_MR" ]; then
          curl --request POST \
            --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
            --header "Content-Type: application/json" \
            --data "{
              \"source_branch\": \"development\",
              \"target_branch\": \"main\",
              \"title\": \"Draft: üöÄ Release $MILESTONE_TITLE\",
              \"description\": \"## Release $MILESTONE_TITLE\\n\\nDraft MR for next release. Features merge to development and accumulate here.\\n\\n### When Ready\\n1. Mark as ready\\n2. Add to merge train\\n3. Train merges to main\\n4. Release automation runs\",
              \"milestone_id\": $MILESTONE_ID,
              \"draft\": true,
              \"labels\": \"type::release,status::draft\"
            }" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests"
        fi
      done
  rules:
    - if: $CI_COMMIT_BRANCH == "development"
      when: manual

# Generate llms.txt context files
generate:llms-txt:
  stage: build
  image: python:3.11-slim
  script:
    - pip install llms-txt
    - llms_txt2ctx llms.txt > llms-ctx.txt
    - llms_txt2ctx llms.txt --optional True > llms-ctx-full.txt
  artifacts:
    paths:
      - llms.txt
      - llms-ctx.txt
      - llms-ctx-full.txt
    expire_in: never
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "development"
      when: on_success

# ============================================================================
# POST-RELEASE SYNC - Sync main back to development after releases
# ============================================================================

dependency:update:
  stage: .post
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache git
  script:
    - |
      echo "üì¶ Checking for outdated dependencies..."
      npm outdated || true

      echo ""
      echo "üîí Running security audit..."
      npm audit || true

      echo ""
      echo "üí° To fix vulnerabilities, run: npm audit fix --audit-level=moderate"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: true

sync:main-to-development:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache git curl jq
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      echo "üîÑ Syncing main ‚Üí development..."

      git fetch origin main development
      git checkout development
      git pull origin development

      # Check if main has commits not in development
      BEHIND=$(git rev-list --count development..origin/main)

      if [ "$BEHIND" -gt 0 ]; then
        echo "development is $BEHIND commits behind main"

        # Create sync MR automatically
        curl --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --header "Content-Type: application/json" \
          --data '{
            "source_branch": "main",
            "target_branch": "development",
            "title": "chore: sync main ‚Üí development post-release [skip ci]",
            "description": "Automated sync after release. Contains release commits.",
            "remove_source_branch": false,
            "squash": true
          }' \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
      else
        echo "‚úÖ development is up-to-date with main"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_TAG
      when: on_success
    - when: never

# OSSA Runners
include:
  - local: '.gitlab/ci/ossa-runners.yml'
