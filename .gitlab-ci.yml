# GitLab CI/CD Pipeline for OSSA
# Release Branch Strategy
# - Code flows: Feature â†’ release/v0.X.x â†’ main (CI validates, auto-release on merge to main)
# - Website deployment - Manual button (independent of releases)
# - NPM releases - Milestone-gated + ENABLE_RELEASE variable required
#
# Workflow
# 1. Feature branches â†’ merge to release/v0.X.x (CI validates)
# 2. Release branches â†’ merge to main via merge train (CI validates)
# 3. Click "Deploy Website" button â†’ GitLab Pages deploys
# 4. To release - Set ENABLE_RELEASE=true + close milestone â†’ automatic npm publish + git tag
#
# Release Gate
# Releases require BOTH conditions
#   - Milestone must be 100% complete and closed

include:
  - local: '.gitlab/ci/agents.yml'
  - local: '.gitlab/ci/branch-policy.yml'
  - local: '.gitlab/ci/webhook-agents.yml'  # OSSA v0.2.9 webhook-triggered agents
  - local: '.gitlab/ci/merge-train-optimized.yml'  # Optimized merge train pipeline
  - local: '.gitlab/ci/milestone-workflow.yml'  # Milestone-driven workflow enforcement
  - local: '.gitlab/ci/fix-mr-targets.yml'  # Fix MRs targeting main branch
  - local: '.gitlab/ci/ossa-version-management.yml'  # Dynamic OSSA version detection and injection
  # Security scanning from Auto DevOps
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  # Merge trains enabled via workflow rules (see workflow section at bottom)
  # Component available but private - uncomment when gitlab_components is public
  # - component: gitlab.com/blueflyio/agent-platform/gitlab_components/merge-train@main
# OSSA Runners
  - local: '.gitlab/ci/ossa-runners.yml'
#   - CI/CD variable ENABLE_RELEASE must be set to "true"
# This allows deploying to main without releasing. Set the variable only when ready to release.
#
# To set ENABLE_RELEASE
#   GitLab UI - Settings â†’ CI/CD â†’ Variables â†’ Add variable
#   Variable - ENABLE_RELEASE
#   Value - true
#   Protected - Yes (recommended)
#   Masked - No
#
# Status - ACTIVE MODE
# Last updated - 2025-11-25

stages:
  - .pre           # GitLab reserved pre-stage (used by create-release-mrs)
  - setup          # Version detection and sync happen here (earliest stage)
  - version-detect # Used by included CI files (release-workflow.yml, version-bump-agent.yml)
  - validate       # Validation jobs (can use version from setup)
  - build          # Build jobs (can use version from setup)
  - test           # Test jobs (can use version from setup)
  - quality        # Quality gates
  - deploy         # Deployment
  - release        # Release automation
  - mirror         # Mirror to external repos
  - .post          # GitLab reserved post-stage (post-release jobs)

variables:
  NODE_VERSION: "22"
  NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  HUSKY: "0"
  LEFTHOOK: "0"

# ============================================================================
# STAGE 0 - VERSION DETECTION & DEV TAG MANAGEMENT
# ============================================================================

detect:version:
  stage: setup
  image: alpine:latest
  tags:
    - saas-linux-small-amd64
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git bash
    - chmod +x .gitlab/scripts/detect-version.sh
  script:
    - .gitlab/scripts/detect-version.sh
  artifacts:
    expire_in: 1 hour
    paths:
      - build.env
  rules:
    - if: '$CI_COMMIT_BRANCH =~ /^release\/v/'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^release\/v/'
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"'
    - if: '$CI_COMMIT_TAG'

detect:milestone-and-tags:
  stage: setup
  image: alpine:latest
  timeout: 10 minutes
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set -euo pipefail

      # Validate required variables
      if [ -z "${CI_API_V4_URL:-}" ] || [ -z "${CI_PROJECT_ID:-}" ] || [ -z "${CI_JOB_TOKEN:-}" ]; then
        echo "ERROR: Missing required CI variables"
        exit 1
      fi

      # Rate-limited API call function with exponential backoff
      safe_api_call() {
        local url="$1"
        local max_retries=5
        local retry=0
        local wait_time=2

        if [ -z "$url" ]; then
          echo "ERROR: safe_api_call called with empty URL" >&2
          echo "[]"
          return 1
        fi

        while [ $retry -lt $max_retries ]; do
          local response
          local http_code
          local body

          response=$(curl -sS -w "\n%{http_code}" "$url" \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" 2>&1) || true

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          if [ "$http_code" = "429" ]; then
            retry=$((retry + 1))
            echo "WARNING: Rate limit hit, retrying in ${wait_time}s (attempt $retry/$max_retries)" >&2
            sleep $wait_time
            wait_time=$((wait_time * 2))
            continue
          elif [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
            echo "$body"
            return 0
          else
            echo "WARNING: API call failed with HTTP $http_code" >&2
            retry=$((retry + 1))
            sleep $wait_time
            wait_time=$((wait_time * 2))
            continue
          fi
        done

        echo "[]"
        return 1
      }

      echo "DEV TAG MANAGEMENT"
      echo "=================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo "Pipeline: ${CI_PIPELINE_ID}"
      echo ""

      # Initialize env files
      cat > dev-tags.env << 'EOF'
      DEV_TAG_VERSION=
      DEV_TAG_NAME=
      DEV_TAG_BUILD=
      DEV_MILESTONE_ID=
      EOF

      # Only run on main and release branches
      if [ "$CI_COMMIT_BRANCH" != "main" ] && ! echo "$CI_COMMIT_BRANCH" | grep -qE "^release/v"; then
        echo "Skipping dev tag management (not on main/release branch)"
      else
        # Get all milestones (with rate limiting)
        DEV_MILESTONES=$(safe_api_call "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
          -G --data-urlencode "per_page=100" --data-urlencode "state=all" || echo "[]")

        if [ "$DEV_MILESTONES" != "[]" ] && [ -n "$DEV_MILESTONES" ]; then
          # Process milestones - use process substitution to avoid subshell
          while read -r dev_milestone_json; do
            [ -z "$dev_milestone_json" ] && continue

            DEV_TITLE=$(echo "$dev_milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
            DEV_ID=$(echo "$dev_milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
            DEV_VERSION=$(echo "$DEV_TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

            [ -z "$DEV_VERSION" ] && continue

        # Skip if already released
            if git tag -l 2>/dev/null | grep -qE "^v?${DEV_VERSION}$"; then
              echo "Skipping ${DEV_VERSION} (already released)"
          continue
        fi

            # Get latest dev tag for this version
            LATEST_DEV_TAG=$(git tag -l "${DEV_VERSION}-dev-*" 2>/dev/null | sort -V | tail -1)
            CURRENT_BUILD=$(echo "$LATEST_DEV_TAG" | sed "s/.*-dev-//" | grep -E '^[0-9]+$' || echo "0")
            [ -z "$CURRENT_BUILD" ] && CURRENT_BUILD=0
            NEXT_BUILD=$((CURRENT_BUILD + 1))

            # Check if we need a new tag
            if [ -n "$LATEST_DEV_TAG" ]; then
              TAG_COMMIT=$(git rev-list -n 1 "$LATEST_DEV_TAG" 2>/dev/null || echo "")
              if [ "$CI_COMMIT_SHA" = "$TAG_COMMIT" ]; then
                echo "No changes since ${LATEST_DEV_TAG}, skipping"
                continue
              fi
            fi

            NEW_TAG="${DEV_VERSION}-dev-${NEXT_BUILD}"
            echo "Creating dev tag: ${NEW_TAG}"

            # Create and push tag
            if git tag -a "$NEW_TAG" -m "Dev build ${NEXT_BUILD} for milestone ${DEV_ID}" "$CI_COMMIT_SHA" 2>/dev/null; then
              if git push origin "$NEW_TAG" 2>/dev/null; then
                echo "Created dev tag: ${NEW_TAG}"
                cat > dev-tags.env << EOF
      DEV_TAG_VERSION=${DEV_VERSION}
      DEV_TAG_NAME=${NEW_TAG}
      DEV_TAG_BUILD=${NEXT_BUILD}
      DEV_MILESTONE_ID=${DEV_ID}
      EOF
              else
                echo "Failed to push tag ${NEW_TAG}"
                git tag -d "$NEW_TAG" 2>/dev/null || true
              fi
            else
              echo "Tag ${NEW_TAG} already exists or failed to create"
            fi

            break  # Only create one dev tag per pipeline
          done < <(echo "$DEV_MILESTONES" | jq -c '.[]' 2>/dev/null || echo "")
        fi
      fi
      
      # Detect ACTIVE milestones ready for release
      # NEW FLOW: Milestone stays ACTIVE, release closes it
      echo ""
      echo "RELEASE READINESS CHECK"
      echo "========================"
      echo "Looking for ACTIVE milestone with all issues closed..."
      echo ""

      # Get ACTIVE milestones only
      ALL_MILESTONES=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
        --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
        --data-urlencode "per_page=100" \
        --data-urlencode "state=active")

      # Initialize milestone env file
      echo "RELEASE_VERSION=" > milestone-version.env
      echo "MILESTONE_TITLE=" >> milestone-version.env
      echo "MILESTONE_ID=" >> milestone-version.env
      echo "MILESTONE_URL=" >> milestone-version.env
      echo "MILESTONE_READY=false" >> milestone-version.env
      echo "ISSUE_COUNT=0" >> milestone-version.env
      echo "OPEN_ISSUE_COUNT=0" >> milestone-version.env

      # Find ACTIVE milestone with all issues closed (ready for release)
      FOUND_MILESTONE=false
      while read -r milestone_json; do
        [ -z "$milestone_json" ] && continue
        [ "$FOUND_MILESTONE" = "true" ] && break

        TITLE=$(echo "$milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
        ID=$(echo "$milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
        WEB_URL=$(echo "$milestone_json" | jq -r '.web_url // ""' 2>/dev/null || echo "")

        VERSION=$(echo "$TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

        if [ -n "$VERSION" ]; then
          # Skip if already released (tag exists)
          if git tag -l 2>/dev/null | grep -qE "^v?${VERSION}$"; then
            echo "SKIP: Skipping ${VERSION} - already released"
            continue
          fi

          # Get milestone stats
          MILESTONE_STATS=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${ID}" \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" 2>/dev/null || echo "{}")

          TOTAL_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.total_issues_count // 0' 2>/dev/null || echo "0")
          CLOSED_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.closed_issues_count // 0' 2>/dev/null || echo "0")
          OPEN_ISSUES=$((TOTAL_ISSUES - CLOSED_ISSUES))

          echo "ðŸ“Š Milestone: ${TITLE}"
          echo "  Total issues: ${TOTAL_ISSUES}"
          echo "  Closed: ${CLOSED_ISSUES}"
          echo "  Open: ${OPEN_ISSUES}"
          echo ""

          # Check if 100% complete (all issues closed)
          if [ "$OPEN_ISSUES" -eq 0 ] && [ "$TOTAL_ISSUES" -gt 0 ]; then
            echo "RELEASE_VERSION=${VERSION}" > milestone-version.env
            echo "MILESTONE_TITLE=${TITLE}" >> milestone-version.env
            echo "MILESTONE_ID=${ID}" >> milestone-version.env
            echo "MILESTONE_URL=${WEB_URL}" >> milestone-version.env
            echo "MILESTONE_READY=true" >> milestone-version.env
            echo "ISSUE_COUNT=${TOTAL_ISSUES}" >> milestone-version.env
            echo "OPEN_ISSUE_COUNT=0" >> milestone-version.env
            echo "Release-ready: ${TITLE} (${TOTAL_ISSUES} issues closed)"
            FOUND_MILESTONE=true
            break
          elif [ "$TOTAL_ISSUES" -eq 0 ]; then
            echo "WARNING: Milestone ${TITLE} has no issues - skipping"
          else
            # Milestone has open issues - NOT ready but record for validation
            echo "RELEASE_VERSION=${VERSION}" > milestone-version.env
            echo "MILESTONE_TITLE=${TITLE}" >> milestone-version.env
            echo "MILESTONE_ID=${ID}" >> milestone-version.env
            echo "MILESTONE_URL=${WEB_URL}" >> milestone-version.env
            echo "MILESTONE_READY=false" >> milestone-version.env
            echo "ISSUE_COUNT=${TOTAL_ISSUES}" >> milestone-version.env
            echo "OPEN_ISSUE_COUNT=${OPEN_ISSUES}" >> milestone-version.env
            echo "ERROR: NOT ready: ${OPEN_ISSUES} issues still open"
            echo "  Close all issues before releasing!"
          fi
        fi
      done < <(echo "$ALL_MILESTONES" | jq -c '.[]' 2>/dev/null || echo "")

      # If no milestone found, ensure env file exists
      if [ ! -s milestone-version.env ]; then
        echo "RELEASE_VERSION=" > milestone-version.env
        echo "MILESTONE_TITLE=" >> milestone-version.env
        echo "MILESTONE_ID=" >> milestone-version.env
        echo "MILESTONE_READY=false" >> milestone-version.env
        echo "INFO: No release-ready milestone found"
      fi
      
      # Merge dev-tags.env into milestone-version.env
      if [ -s dev-tags.env ]; then
        cat dev-tags.env >> milestone-version.env
      fi
      
      echo ""
      echo "ðŸ“‹ Summary:"
      cat milestone-version.env
  artifacts:
    reports:
      dotenv: milestone-version.env
    paths:
      - milestone-version.env
      - dev-tags.env
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: always
  allow_failure: true

# ============================================================================
# STAGE 1 - SETUP & VALIDATE
# ============================================================================

validate:node:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - node --version
    - npm --version
    - echo "Node.js ${NODE_VERSION} ready"
  rules:
    - when: always

validate:ossa:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Validating example manifests..."
    - node dist/cli/index.js validate examples/getting-started/hello-world-complete.ossa.yaml || echo "WARNING Validation warnings (non-blocking)"
  allow_failure: true
  rules:
    - when: always

validate:gitlab-ci:
  stage: validate
  image: alpine:latest
  script:
    - apk add --no-cache curl jq
    - |
      for file in $(find . -name ".gitlab-ci*.yml" -o -name "*.gitlab-ci.yml" 2>/dev/null | grep -v "^./examples/" | head -1); do
        if [ -f "$file" ]; then
          echo "Validating $file"
          RESPONSE=$(curl --silent --request POST \
            --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "$(jq -Rs '{content: .}' < "$file")" \
            "${CI_API_V4_URL}/ci/lint")
          
          # Check if the response contains a valid field
          if echo "$RESPONSE" | jq -e '.valid' > /dev/null 2>&1; then
            if echo "$RESPONSE" | jq -e '.valid == true' > /dev/null 2>&1; then
              echo "CI configuration is valid"
            else
              echo "CI configuration is invalid:"
              echo "$RESPONSE" | jq -r '.errors[]' 2>/dev/null || echo "Unknown validation error"
              exit 1
            fi
          else
            echo "WARNING: CI validation API returned unexpected response:"
            echo "$RESPONSE"
            echo "Continuing anyway..."
          fi
        fi
      done
  allow_failure: true
  rules:
    - when: always

# Check for divergent branches before merging to protected branches
check:divergence:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git
  script:
    - |
      if [ "$CI_MERGE_REQUEST_TARGET_BRANCH" = "main" ] || echo "$CI_MERGE_REQUEST_TARGET_BRANCH" | grep -qE "^release/v"; then
        echo "ðŸ” Checking for divergent branches..."
        git fetch origin
        
        BEHIND=$(git log --oneline origin/$CI_MERGE_REQUEST_SOURCE_BRANCH..origin/$CI_MERGE_REQUEST_TARGET_BRANCH 2>/dev/null | wc -l)
        AHEAD=$(git log --oneline origin/$CI_MERGE_REQUEST_TARGET_BRANCH..origin/$CI_MERGE_REQUEST_SOURCE_BRANCH 2>/dev/null | wc -l)
        
        if [ $BEHIND -gt 0 ] && [ $AHEAD -gt 0 ]; then
          echo "ERROR: DIVERGENT BRANCHES DETECTED"
          echo "Target has $BEHIND commits not in source"
          echo "Source has $AHEAD commits not in target"
          echo "Use squash merge or force push recovery"
          exit 1
        fi
        
        if [ $BEHIND -gt 0 ]; then
          echo "WARNING: Source behind target by $BEHIND commits"
          exit 1
        fi
        
        echo "No divergence detected"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Check for .DS_Store files
check:ds-store:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git
  script:
    - |
      echo "ðŸ” Checking for .DS_Store files..."
      if git diff --name-only $CI_MERGE_REQUEST_DIFF_BASE_SHA 2>/dev/null | grep -q "\.DS_Store"; then
        echo "ERROR: .DS_Store files in MR"
        exit 1
      fi
      echo "No .DS_Store files"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

validate:version-sync:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - echo "Checking version consistency..."
    - npm run version:check
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - README.md
      - spec/**/*
      when: always

# ============================================================================
# VERSION MANAGEMENT VIA GITLAB AGENTS (Dogfooding)
# ============================================================================
# TODO: Enable after component is published to main
# include:
#   - component: gitlab.com/blueflyio/openstandardagents/version-management/version-bump-agent@main

# version:bump:agent:
#   extends: .version-bump-agent
#   variables:
#     BUMP_TYPE: "patch"
#     TARGET_BRANCH: "release/v0.X.x"
#   rules:
#     - if: '$BUMP_VERSION == "true"'
#       when: manual
#       allow_failure: false

# version:sync:agent:
#   extends: .version-sync-agent
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "push"'
#       when: always
#     - if: '$VERSION_SYNC == "true"'
#       when: manual

# version:consistency:check:
#   extends: .version-consistency-check

validate:scripts-version:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache curl jq
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Validating npm scripts use dynamic version..."
      VERSION=$(node -p "require('./package.json').version")
      echo "Current version: ${VERSION}"
      
      # Verify exports["./schema"] matches current version
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"
      ACTUAL_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''")
      if [ "$ACTUAL_EXPORT" != "$EXPECTED_EXPORT" ] && [ -n "$ACTUAL_EXPORT" ]; then
        echo "ERROR: package.json exports[\"./schema\"] is \"${ACTUAL_EXPORT}\", should be \"${EXPECTED_EXPORT}\""
        exit 1
      fi

      # Check scripts don't have hardcoded version paths
      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "Scripts field does not contain hardcoded version paths"
      else
        echo "ERROR: package.json scripts contain hardcoded version paths"
        exit 1
      fi

      echo "All scripts use dynamic version detection"
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - scripts/**/*
      when: always

validate:docs-consistency:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache curl jq
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Pre-Release Documentation Validation"
      echo "========================================"
      
      VERSION=$(node -p "require('./package.json').version")
      echo "Package version: v${VERSION}"

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo ""
        echo "ERROR: Documentation is out of sync!"
        echo ""
        echo "FIX REQUIRED:"
        echo "1. Run locally: npx tsx scripts/sync-versions.ts --fix"
        echo "2. Commit the changes"
        echo "3. Push and re-run pipeline"
        exit 1
      fi

      echo "ALL DOCUMENTATION CONSISTENCY CHECKS PASSED"
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^release\/v/
      when: always

# ============================================================================
# STAGE 2 - BUILD
# ============================================================================

build:dist:
  stage: build
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  timeout: 30 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  needs:
    - job: version:sync:placeholders
      optional: true
      artifacts: true
    - job: detect:version
      optional: true
      artifacts: true
  before_script:
    - apk add --no-cache curl jq
    - test -f build.env && . build.env || echo "No build.env found (using defaults)"
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - test -f dist/cli/index.js || (echo "ERROR ERROR dist/cli/index.js missing" && exit 1)
    - echo "Build completed"
  artifacts:
    paths:
      - dist/
      - package.json
      - package-lock.json
    expire_in: 1 hour
  rules:
    - when: always

# ============================================================================
# STAGE 3 - TEST
# ============================================================================

test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  needs:
    - job: version:sync:placeholders
      optional: true
      artifacts: true
    - job: detect:version
      optional: true
      artifacts: true
  before_script:
    - apk add --no-cache curl jq
    - test -f build.env && . build.env || echo "No build.env found (using defaults)"
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm run lint || echo "WARNING Lint warnings"
    - npm run typecheck || echo "WARNING Typecheck warnings"
  allow_failure: true
  rules:
    - when: always

test:code-quality:
  stage: test
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  script:
    - npm ci --legacy-peer-deps
    - npx eslint src/ -f json -o eslint-report.json || true
    - node scripts/eslint-to-codequality.cjs
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json
      - eslint-report.json
    expire_in: 7 days
  rules:
    - when: always

test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  timeout: 20 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  dependencies:
    - build:dist
  needs:
    - job: build:dist
      artifacts: true
    - job: version:sync:placeholders
      optional: true
      artifacts: true
    - job: detect:version
      optional: true
      artifacts: true
  before_script:
    - apk add --no-cache curl jq
    - test -f build.env && . build.env || echo "No build.env found (using defaults)"
    - npm ci --legacy-peer-deps
  script:
    - npm run build
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: test-results/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
      - test-results/
    expire_in: 7 days
  allow_failure: false
  rules:
    - when: always

test:security:
  stage: test
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  script:
    - npm ci --legacy-peer-deps
    - npm audit --production || echo "WARNING Security vulnerabilities"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 4 - QUALITY GATES
# ============================================================================

quality:gates:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  script:
    - echo "Quality gates passed"
  rules:
    - when: always
  needs:
    - job: test:unit
      optional: true
    - job: test:lint
      optional: true
    - job: test:security
      optional: true

# ============================================================================
# STAGE 5 - DEPLOY (Removed - Website moved to openstandardagents.org)
# ============================================================================
# Website deployment is now handled by the openstandardagents.org repository.
# This repo (openstandardagents) is the spec/CLI npm package only.

# ============================================================================
# STAGE 6 - RELEASE (NPM - Milestone-Gated)
# ============================================================================

# AUTOMATED CHANGELOG GENERATION (git-cliff)
# Runs on every merge to release branches - generates Keep a Changelog format
changelog:generate:
  stage: release
  image: alpine:latest
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0  # Full history needed for changelog generation
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl bash
    # Install git-cliff
    - curl -sSfL https://github.com/orhun/git-cliff/releases/download/v2.7.0/git-cliff-2.7.0-x86_64-unknown-linux-musl.tar.gz | tar xz
    - mv git-cliff-*/git-cliff /usr/local/bin/
    - chmod +x /usr/local/bin/git-cliff
    - git config --global user.email "ci@openstandardagents.org"
    - git config --global user.name "OSSA CI Bot"
  script:
    - |
      echo "Generating changelog with git-cliff..."
      echo "Branch: $CI_COMMIT_BRANCH"
      echo "Commit: $CI_COMMIT_SHA"

      # Generate changelog
      git cliff --output CHANGELOG.md

      # Check if changelog changed
      if git diff --quiet CHANGELOG.md 2>/dev/null; then
        echo "No changelog updates needed"
        exit 0
      fi

      echo "Changelog updated:"
      head -100 CHANGELOG.md

      # Commit and push if there are changes
      git add CHANGELOG.md
      git commit -m "chore(release): update changelog [skip ci]"

      # Push using CI token
      git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git"
      git push origin HEAD:$CI_COMMIT_BRANCH

      echo "Changelog committed and pushed"
  rules:
    # Run on merges to release branches
    - if: $CI_COMMIT_BRANCH =~ /^release\/v[0-9]+\.[0-9]+\.x$/
      when: on_success
    # Run on merges to main
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true  # Don't block pipeline if changelog fails

# GENERATE CHANGELOG from milestone issues (legacy - for release notes)
release:changelog:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 10 minutes
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - npm install -g tsx
    - test -f build.env && . build.env || echo "No build.env found (using defaults)"
  script:
    - |
      #!/bin/bash
      set -euo pipefail
      echo "CHANGELOG GENERATION"
      echo "======================="

      if [ "$MILESTONE_READY" != "true" ]; then
        echo "WARNING: No release-ready milestone - skipping"
        exit 0
      fi

      echo "Milestone: ${MILESTONE_TITLE}"
      echo "Version: v${RELEASE_VERSION}"
      echo "Milestone ID: ${MILESTONE_ID}"
      echo ""

      # Generate changelog from milestone issues
      MILESTONE_ID=${MILESTONE_ID} \
      RELEASE_VERSION=${RELEASE_VERSION} \
      CHANGELOG_OUTPUT="RELEASE_NOTES.md" \
      tsx .gitlab/release-automation/scripts/generate-changelog.ts

      # Also create version-specific changelog
      VERSION_CHANGELOG="spec/v${RELEASE_VERSION}/CHANGELOG.md"
      mkdir -p "spec/v${RELEASE_VERSION}"
      cp RELEASE_NOTES.md "$VERSION_CHANGELOG"

      echo ""
      echo "Changelog generated successfully"
      cat RELEASE_NOTES.md
  artifacts:
    paths:
      - RELEASE_NOTES.md
      - spec/v*/CHANGELOG.md
      - changelog.env
    reports:
      dotenv: changelog.env
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  needs:
    - job: detect:version
      optional: true
      artifacts: true
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true
  allow_failure: false

# PRE-RELEASE VALIDATION - Critical checks before any release
release:validate:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 10 minutes
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git jq bash curl
    - npm ci --legacy-peer-deps
  script:
    - |
      #!/bin/bash
      set -euo pipefail
      echo "ðŸ”’ PRE-RELEASE VALIDATION"
      echo "========================="
      echo ""

      ERRORS=0
      WARNINGS=0

      # 0. MILESTONE GATE CHECK - All issues must be closed!
      echo "ðŸ“‹ 0. Milestone Gate (All Issues Closed)"
      if [ "$MILESTONE_READY" = "true" ]; then
        echo "   Milestone ready: ${MILESTONE_TITLE}"
        echo "   All ${ISSUE_COUNT:-0} issues closed"
      elif [ -n "$MILESTONE_TITLE" ] && [ "${OPEN_ISSUE_COUNT:-0}" -gt 0 ]; then
        echo "ERROR: Cannot release - ${OPEN_ISSUE_COUNT} issues still OPEN!"
        echo ""
        echo "  Open issues in ${MILESTONE_TITLE}:"
        # Fetch and display open issues
        OPEN_ISSUES_LIST=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues" \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --data-urlencode "milestone=${MILESTONE_TITLE}" \
          --data-urlencode "state=opened" \
          --data-urlencode "per_page=100" 2>/dev/null || echo "[]")

        echo "$OPEN_ISSUES_LIST" | jq -r '.[] | "   - #\(.iid): \(.title)"' 2>/dev/null || echo "  (Could not fetch issues)"
        echo ""
        echo "  ðŸ‘‰ Close all issues before releasing!"
        ERRORS=$((ERRORS + 1))
      elif [ -z "$MILESTONE_TITLE" ]; then
        echo "WARNING: No milestone detected"
        echo "  Release will proceed without milestone linkage"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "WARNING: Milestone has 0 issues"
        WARNINGS=$((WARNINGS + 1))
      fi
      echo ""

      # 1. VERSION CONSISTENCY CHECK
      echo "ðŸ“‹ 1. Version Consistency"
      VERSION=$(node -p "require('./package.json').version")
      echo "  Package version: v${VERSION}"

      # Check schema exists for this version
      SCHEMA_PATH="spec/v${VERSION}/ossa-${VERSION}.schema.json"
      if [ ! -f "$SCHEMA_PATH" ]; then
        echo "ERROR: Schema not found: ${SCHEMA_PATH}"
        ERRORS=$((ERRORS + 1))
      else
        echo "   Schema exists: ${SCHEMA_PATH}"
      fi

      # Check README version badge matches
      if grep -q "v${VERSION}" README.md; then
        echo "   README version badge matches"
      else
        echo "WARNING: README may not reference v${VERSION}"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 2. SCHEMA VALIDATION
      echo ""
      echo "ðŸ“‹ 2. Schema Validation"

      # Check schema is valid JSON
      if jq empty "$SCHEMA_PATH" 2>/dev/null; then
        echo "   Schema is valid JSON"
      else
        echo "ERROR: Schema is not valid JSON"
        ERRORS=$((ERRORS + 1))
      fi

      # Check schema has required fields
      SCHEMA_VERSION=$(jq -r '.properties.apiVersion.const // .properties.apiVersion.enum[0] // ""' "$SCHEMA_PATH" 2>/dev/null || echo "")
      if [ -n "$SCHEMA_VERSION" ]; then
        echo "   Schema apiVersion: ${SCHEMA_VERSION}"
      else
        echo "WARNING: Could not detect apiVersion in schema"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 3. EXAMPLES VALIDATION
      echo ""
      echo "ðŸ“‹ 3. Examples Validation"

      EXAMPLE_ERRORS=0
      for example in examples/**/*.ossa.yaml examples/**/*.ossa.json; do
        [ ! -f "$example" ] && continue

        # Check apiVersion matches
        if grep -q "apiVersion.*ossa/v${VERSION}" "$example" 2>/dev/null || \
           jq -e ".apiVersion == \"ossa/v${VERSION}\"" "$example" 2>/dev/null; then
          echo "   ${example}"
        else
          EXAMPLE_API=$(grep -oE "apiVersion.*ossa/v[0-9.]+" "$example" 2>/dev/null | head -1 || \
                        jq -r '.apiVersion // "unknown"' "$example" 2>/dev/null || echo "unknown")
          echo "ERROR: ${example} has ${EXAMPLE_API}, expected ossa/v${VERSION}"
          EXAMPLE_ERRORS=$((EXAMPLE_ERRORS + 1))
        fi
      done

      if [ $EXAMPLE_ERRORS -gt 0 ]; then
        echo "  ERROR: ${EXAMPLE_ERRORS} examples have wrong apiVersion"
        ERRORS=$((ERRORS + EXAMPLE_ERRORS))
      fi

      # 4. BUILD ARTIFACTS CHECK
      echo ""
      echo "ðŸ“‹ 4. Build Artifacts"

      if [ -f "dist/cli/index.js" ]; then
        echo "   CLI built: dist/cli/index.js"
      else
        echo "ERROR: CLI not built"
        ERRORS=$((ERRORS + 1))
      fi

      if [ -d "dist/lib" ]; then
        echo "   Library built: dist/lib/"
      else
        echo "WARNING: dist/lib/ not found"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 5. PACKAGE.JSON EXPORTS CHECK
      echo ""
      echo "ðŸ“‹ 5. Package Exports"

      SCHEMA_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''" 2>/dev/null || echo "")
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"

      if [ "$SCHEMA_EXPORT" = "$EXPECTED_EXPORT" ]; then
        echo "   Schema export correct: ${SCHEMA_EXPORT}"
      elif [ -z "$SCHEMA_EXPORT" ]; then
        echo "WARNING: No ./schema export defined"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "ERROR: Schema export mismatch"
        echo "     Expected: ${EXPECTED_EXPORT}"
        echo "     Got: ${SCHEMA_EXPORT}"
        ERRORS=$((ERRORS + 1))
      fi

      # 6. TEST RUN
      echo ""
      echo "ðŸ“‹ 6. Test Suite"

      if npm run test 2>&1; then
        echo "   All tests passed"
      else
        echo "ERROR: Tests failed"
        ERRORS=$((ERRORS + 1))
      fi

      # 7. TYPECHECK
      echo ""
      echo "ðŸ“‹ 7. TypeScript Validation"

      if npm run typecheck 2>&1; then
        echo "   TypeScript compilation clean"
      else
        echo "ERROR: TypeScript errors"
        ERRORS=$((ERRORS + 1))
      fi

      # 8. NO HARDCODED VERSIONS IN SCRIPTS
      echo ""
      echo "ðŸ“‹ 8. Script Version Check"

      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "   No hardcoded versions in scripts"
      else
        echo "ERROR: Hardcoded versions found in package.json scripts"
        ERRORS=$((ERRORS + 1))
      fi

      # SUMMARY
      echo ""
      echo "========================================"
      echo "ðŸ“Š VALIDATION SUMMARY"
      echo "========================================"
      echo "  Errors: ${ERRORS}"
      echo "  Warnings: ${WARNINGS}"
      echo ""

      if [ $ERRORS -gt 0 ]; then
        echo "ERROR: RELEASE BLOCKED: ${ERRORS} error(s) must be fixed"
        echo ""
        echo "Fix the errors above before releasing."
        exit 1
      fi

      if [ $WARNINGS -gt 0 ]; then
        echo "WARNING: RELEASE APPROVED WITH WARNINGS: ${WARNINGS} warning(s)"
      else
        echo "RELEASE APPROVED: All checks passed"
      fi
  artifacts:
    reports:
      dotenv: validation-report.env
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  needs:
    - build:dist
    - test:unit
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:preview:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Release Preview (Dry-Run)"
      echo "============================"
      
      if [ "$ENABLE_RELEASE" = "true" ]; then
        echo "ENABLE_RELEASE: ${ENABLE_RELEASE} (releases enabled)"
      else
        echo "WARNING: ENABLE_RELEASE: ${ENABLE_RELEASE:-not set} (releases disabled)"
      fi
      
      if [ -n "$RELEASE_VERSION" ]; then
        echo "ðŸ“¦ Detected from closed milestone:"
        echo "  Milestone: ${MILESTONE_TITLE}"
        echo "  Version: v${RELEASE_VERSION}"
        echo "  Ready: ${MILESTONE_READY:-false}"
      fi

      CURRENT_VERSION=$(node -p "require('./package.json').version")
      echo "ðŸ“„ Current package.json: v${CURRENT_VERSION}"
      
      if [ "$ENABLE_RELEASE" = "true" ] && [ "$MILESTONE_READY" = "true" ]; then
        echo "Release will proceed automatically"
      else
        echo "WARNING: Release blocked (see conditions above)"
      fi
      
      npx semantic-release --dry-run || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  allow_failure: true
  needs:
    - build:dist
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:npm:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 15 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production
    auto_stop_in: never
  dependencies:
    - build:dist
    - detect:milestone-and-tags
    - release:changelog
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI Release"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
    - git checkout -B main origin/main
  script:
    - |
      #!/bin/bash
      set -euo pipefail
      echo "MILESTONE-GATED RELEASE"
      echo "=========================="

      # Check ENABLE_RELEASE gate
      if [ "$ENABLE_RELEASE" != "true" ]; then
        echo "ðŸš« RELEASE BLOCKED: ENABLE_RELEASE not set"
        echo ""
        echo "To enable releases:"
        echo "Settings â†’ CI/CD â†’ Variables â†’ Add variable"
        echo "Variable: ENABLE_RELEASE"
        echo "Value: true"
        exit 0
      fi

      # Check milestone readiness
      if [ "$MILESTONE_READY" != "true" ]; then
        echo "ðŸš« RELEASE BLOCKED: No release-ready milestone"
        echo ""
        echo "Requirements:"
        echo "1.  ENABLE_RELEASE = true"
        echo "2. ERROR: Milestone must be closed and 100% complete"
        exit 0
      fi

      echo "Release gate passed"
      echo "  ENABLE_RELEASE: ${ENABLE_RELEASE}"
      echo "  Milestone: ${MILESTONE_TITLE}"
      echo "  Version: v${RELEASE_VERSION}"
      echo "  Issues Closed: ${ISSUE_COUNT:-0}"

      # Update package.json
      npm version ${RELEASE_VERSION} --no-git-tag-version --allow-same-version

      # Sync documentation
      echo "Syncing documentation..."
      npx tsx scripts/sync-versions.ts --fix

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo "ERROR: Documentation sync failed"
        exit 1
      fi

      # Configure npm using npm config (safer than .npmrc file)
      GITLAB_HOST="${CI_SERVER_HOST}"
      npm config set @bluefly:registry "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/"
      npm config set "//${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken" "${CI_JOB_TOKEN}"
      if [ -n "$NPM_TOKEN" ]; then
        npm config set "//registry.npmjs.org/:_authToken" "${NPM_TOKEN}"
      fi
      # Ensure .npmrc is not committed
      echo ".npmrc" >> .gitignore || true

      # Final tests
      echo "ðŸ§ª Running final tests..."
      npm run test || (echo "ERROR: Tests failed" && exit 1)

      # Publish to npm
      echo "ðŸ“¦ Publishing v${RELEASE_VERSION} to npm..."
      if ! npm publish --access public; then
        echo "ERROR: npm publish failed"
        exit 1
      fi

      # Create git tag with comprehensive release information
      PROD_TAG="v${RELEASE_VERSION}"
      RELEASE_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

      # Load changelog content if available
      CHANGELOG_CONTENT=""
      if [ -f "RELEASE_NOTES.md" ]; then
        CHANGELOG_CONTENT=$(cat RELEASE_NOTES.md)
      fi

      # Build comprehensive tag message using heredoc
      read -r -d '' TAG_MESSAGE << EOF || true
      Release v${RELEASE_VERSION}

      Milestone: ${MILESTONE_TITLE}
      Issues Closed: ${ISSUE_COUNT:-0}
      Pipeline: ${CI_PIPELINE_ID}
      Released: ${RELEASE_DATE}
      Commit: ${CI_COMMIT_SHA}

      See full changelog: https://gitlab.com/${CI_PROJECT_PATH}/-/blob/main/spec/v${RELEASE_VERSION}/CHANGELOG.md

      Links:
      - npm Package: https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}
      - Documentation: https://openstandardagents.org/
      - Milestone: ${MILESTONE_URL:-https://gitlab.com/${CI_PROJECT_PATH}/-/milestones}
      EOF

      git tag -a "$PROD_TAG" -m "$TAG_MESSAGE" "$CI_COMMIT_SHA"

      # Commit and push
      git add package.json package-lock.json README.md spec/ RELEASE_NOTES.md || true
      git commit -m "chore(release): v${RELEASE_VERSION} [skip ci]" || echo "No changes to commit"
      git push origin main --tags

      # Create GitLab Release with auto-generated changelog
      echo "ðŸ“‹ Creating GitLab Release with milestone integration..."

      # Prepare changelog for release description
      RELEASE_DESCRIPTION="${CHANGELOG_CONTENT}"

      # If no changelog, use fallback
      if [ -z "$RELEASE_DESCRIPTION" ]; then
        RELEASE_DESCRIPTION="## Release v${RELEASE_VERSION}\n\nMilestone: ${MILESTONE_TITLE} (${MILESTONE_URL})\n\nSee CHANGELOG.md for details."
      fi

      # Create release with milestone linkage
      RELEASE_PAYLOAD=$(jq -n \
        --arg name "Release v${RELEASE_VERSION}" \
        --arg tag "v${RELEASE_VERSION}" \
        --arg desc "$RELEASE_DESCRIPTION" \
        --arg milestone "${MILESTONE_TITLE}" \
        --arg npm_url "https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}" \
        --arg schema_url "https://openstandardagents.org/schema/" \
        --arg docs_url "https://openstandardagents.org/" \
        --arg milestone_url "${MILESTONE_URL}" \
        '{
          name: $name,
          tag_name: $tag,
          description: $desc,
          milestones: [$milestone],
          assets: {
            links: [
              {
                name: "npm package",
                url: $npm_url,
                link_type: "package"
              },
              {
                name: "JSON Schema",
                url: $schema_url,
                link_type: "other"
              },
              {
                name: "Documentation",
                url: $docs_url,
                link_type: "other"
              },
              {
                name: "Milestone",
                url: $milestone_url,
                link_type: "other"
              }
            ]
          }
        }')

      curl --request POST \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "$RELEASE_PAYLOAD" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases"

      echo "GitLab Release created: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"

      # CLOSE THE MILESTONE after successful release
      echo ""
      echo "ðŸ”’ Closing milestone: ${MILESTONE_TITLE}..."
      if [ -n "$MILESTONE_ID" ]; then
        CLOSE_RESULT=$(curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data '{"state_event": "close"}' \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${MILESTONE_ID}" 2>/dev/null)

        CLOSE_STATE=$(echo "$CLOSE_RESULT" | jq -r '.state // "unknown"' 2>/dev/null)
        if [ "$CLOSE_STATE" = "closed" ]; then
          echo "Milestone closed successfully"
        else
          echo "WARNING: Could not close milestone (state: ${CLOSE_STATE})"
          echo "  Manual close required: ${MILESTONE_URL}"
        fi
      else
        echo "WARNING: No MILESTONE_ID - cannot close milestone"
      fi

      echo ""
      echo "Release v${RELEASE_VERSION} completed!"
      echo ""
      echo "ðŸ“Š Release Summary:"
      echo "  Version: v${RELEASE_VERSION}"
      echo "  Milestone: ${MILESTONE_TITLE} (CLOSED)"
      echo "  Issues: ${ISSUE_COUNT:-0}"
      echo "  npm: https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}"
      echo "  Release: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"
      echo "  Milestone: ${MILESTONE_URL}"
  rules:
    # Hotfix branches should NOT create production releases
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\//
      when: never
    # Only main branch creates production releases
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true" && $ENABLE_RELEASE == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual
  needs:
    - quality:gates
    - build:dist
    - release:preview
    - release:validate
    - release:changelog
    - validate:docs-consistency
    - detect:milestone-and-tags

create-patch-version:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
  script:
    - |
      echo "Automated Patch Version Creation"
      echo "===================================="

      # Check if this is a hotfix branch
      if echo "$CI_COMMIT_BRANCH" | grep -qE "^hotfix/"; then
        echo "Hotfix branch detected - creating dev tag only"
        # For hotfix, use current version from package.json or latest release tag
        if [ -f "package.json" ]; then
          CURRENT_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.3.0")
        else
          CURRENT_VERSION="0.3.0"
        fi
        # Extract major.minor from version (e.g., 0.3.0 -> 0.3)
        BRANCH_VERSION=$(echo "$CURRENT_VERSION" | sed -E 's/^([0-9]+\.[0-9]+)\.[0-9]+$/\1/')
        echo "Hotfix dev tag series: v${BRANCH_VERSION}.0-dev.x"
      else
        # Extract version from branch name (e.g., release/v0.1.x -> 0.1)
        BRANCH_VERSION=$(echo "$CI_COMMIT_BRANCH" | sed -E 's/release\/v?([0-9]+\.[0-9]+)\.x/\1/')

        if [ -z "$BRANCH_VERSION" ] || [ "$BRANCH_VERSION" = "$CI_COMMIT_BRANCH" ]; then
          echo "WARNING: Not a release branch format (release/v0.X.x)"
          exit 0
        fi

        echo "Release series: v${BRANCH_VERSION}.x"
      fi

      # Get latest dev tag for this release series (v0.3.0-dev.1, v0.3.0-dev.2, etc.)
      LATEST_DEV_TAG=$(git tag -l "v${BRANCH_VERSION}.0-dev.*" | sort -V | tail -n1)
      
      # Also check for non-dev tags (v0.3.0, v0.3.1, etc.)
      LATEST_TAG=$(git tag -l "v${BRANCH_VERSION}.*" | grep -v "dev" | sort -V | tail -n1)

      if [ -z "$LATEST_DEV_TAG" ]; then
        # No dev tags exist, start with dev.1
        NEW_TAG="v${BRANCH_VERSION}.0-dev.1"
        echo "No existing dev tags for v${BRANCH_VERSION}.x series, starting with ${NEW_TAG}"
      else
        echo "Latest dev tag: $LATEST_DEV_TAG"

        # Check if HEAD is already tagged
        HEAD_TAGS=$(git tag --points-at HEAD)
        if echo "$HEAD_TAGS" | grep -qE "^v${BRANCH_VERSION}.0-dev."; then
          echo "HEAD already has dev tag: $HEAD_TAGS"
          exit 0
        fi

        # Extract dev number and increment
        DEV_NUM=$(echo "$LATEST_DEV_TAG" | sed -E "s/v${BRANCH_VERSION}\.0-dev\.([0-9]+)/\1/")
        if [ -z "$DEV_NUM" ] || [ "$DEV_NUM" = "$LATEST_DEV_TAG" ]; then
          DEV_NUM=0
        fi
        NEW_DEV_NUM=$((DEV_NUM + 1))
        NEW_TAG="v${BRANCH_VERSION}.0-dev.${NEW_DEV_NUM}"
      fi

      echo ""
      echo "TAG: Creating new tag: $NEW_TAG"

      # Create annotated tag
      git tag -a "$NEW_TAG" -m "Release $NEW_TAG from $CI_COMMIT_BRANCH

      Commit: $CI_COMMIT_SHA
      Pipeline: $CI_PIPELINE_URL
      Branch: $CI_COMMIT_BRANCH"

      # Push tag
      if git push origin "$NEW_TAG"; then
        echo "Successfully created and pushed tag: $NEW_TAG"
        
        # Create GitLab Release for dev tag
        echo ""
        echo "Creating GitLab Release for $NEW_TAG"
        
        RELEASE_DESCRIPTION="Dev build $NEW_TAG from $CI_COMMIT_BRANCH - Commit $CI_COMMIT_SHA - Pipeline $CI_PIPELINE_URL - Branch $CI_COMMIT_BRANCH - This is a development/pre-release tag and should not be used in production."
        
        RELEASE_PAYLOAD=$(jq -n \
          --arg name "Dev Release $NEW_TAG" \
          --arg tag "$NEW_TAG" \
          --arg desc "$RELEASE_DESCRIPTION" \
          '{
            name: $name,
            tag_name: $tag,
            description: $desc
          }')
        
        RELEASE_RESPONSE=$(curl -sS --request POST \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "$RELEASE_PAYLOAD" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases" 2>&1)
        
        if echo "$RELEASE_RESPONSE" | jq -e '.tag_name' > /dev/null 2>&1; then
          echo "GitLab Release created: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/$NEW_TAG"
        else
          echo "WARNING: Failed to create GitLab Release (tag was created successfully)"
          echo "Response: $RELEASE_RESPONSE"
        fi
      else
        echo "ERROR: Failed to push tag"
        exit 1
      fi
  rules:
    # Hotfix branches can create dev tags
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\//
      when: on_success
    # Release branches create dev tags
    - if: $CI_COMMIT_BRANCH =~ /^release\/v[0-9]+\.[0-9]+\.x$/
      when: on_success
  allow_failure: false

create-release:
  stage: release
  image: registry.gitlab.com/gitlab-org/cli:latest
  script:
    - |
      echo "ðŸ“‹ Creating GitLab Release for $CI_COMMIT_TAG"

      # Extract version number
      VERSION=$(echo "$CI_COMMIT_TAG" | sed 's/^v//')

      # Load changelog if available
      DESCRIPTION="Release $CI_COMMIT_TAG"
      if [ -f "CHANGELOG.md" ]; then
        # Extract this version's section from CHANGELOG
        DESCRIPTION=$(awk "/^## \[${VERSION}\]/,/^## \[/{if (/^## \[${VERSION}\]/) next; if (/^## \[/) exit; print}" CHANGELOG.md || echo "Release $CI_COMMIT_TAG")
      fi

      echo "Creating release with description:"
      echo "$DESCRIPTION"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: "Release $CI_COMMIT_TAG of components in $CI_PROJECT_PATH"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/  # Only semantic version tags
      when: on_success

# ============================================================================
# STAGE 7 - MIRROR
# ============================================================================

mirror:github:
  stage: mirror
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
  script:
    - |
      # Use GH_TOKEN (group variable) or GITHUB_MIRROR_TOKEN (legacy)
      MIRROR_TOKEN="${GH_TOKEN:-$GITHUB_MIRROR_TOKEN}"

      if [ -z "$MIRROR_TOKEN" ]; then
        echo "INFO: No GitHub token set (GH_TOKEN or GITHUB_MIRROR_TOKEN) - skipping"
        exit 0
      fi

      echo "Syncing to GitHub..."
      git remote add github https://${MIRROR_TOKEN}@github.com/blueflyio/openstandardagents.git || true
      git push github --all --force || true
      git push github --tags --force || true
      echo "GitHub mirror synced"
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true

# ============================================================================
# POST-RELEASE CLEANUP
# ============================================================================
# After successful release:
# 1. Tag all issues with released::v{VERSION}
# 2. Tag all MRs with released::v{VERSION}
# 3. Create next milestone (patch increment)

post-release:cleanup:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache curl jq bash
  script:
    - |
      #!/bin/bash
      set -euo pipefail
      echo "ðŸ§¹ POST-RELEASE CLEANUP"
      echo "======================="

      # Check if release just happened
      if [ -z "$RELEASE_VERSION" ] || [ -z "$MILESTONE_ID" ]; then
        echo "INFO: No release detected - skipping cleanup"
        exit 0
      fi

      VERSION="${RELEASE_VERSION}"
      LABEL_NAME="released::v${VERSION}"

      echo "ðŸ“Œ Version: v${VERSION}"
      echo "ðŸ“Œ Milestone: ${MILESTONE_TITLE}"
      echo ""

      # 1. Create release label if not exists
      echo "Creating label: ${LABEL_NAME}"
      curl --request POST \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        --data "name=${LABEL_NAME}&color=#00FF00&description=Released in v${VERSION}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/labels" 2>/dev/null || echo "Label may already exist"

      # 2. Tag all closed issues in milestone
      echo ""
      echo "ðŸ“Œ Tagging issues..."
      ISSUES=$(curl -sS -G \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues" \
        --data-urlencode "milestone=${MILESTONE_TITLE}" \
        --data-urlencode "state=closed" \
        --data-urlencode "per_page=100")

      echo "$ISSUES" | jq -r '.[].iid' | while read ISSUE_IID; do
        [ -z "$ISSUE_IID" ] && continue
        curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --data "add_labels=${LABEL_NAME}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues/${ISSUE_IID}" > /dev/null
        echo " âœ“ Tagged issue #${ISSUE_IID}"
      done

      # 3. Tag all merged MRs in milestone
      echo ""
      echo "ðŸ“Œ Tagging merge requests..."
      MRS=$(curl -sS -G \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests" \
        --data-urlencode "milestone=${MILESTONE_TITLE}" \
        --data-urlencode "state=merged" \
        --data-urlencode "per_page=100")

      echo "$MRS" | jq -r '.[].iid' | while read MR_IID; do
        [ -z "$MR_IID" ] && continue
        curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --data "add_labels=${LABEL_NAME}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${MR_IID}" > /dev/null
        echo " âœ“ Tagged MR !${MR_IID}"
      done

      # 4. Create next milestone (patch increment)
      echo ""
      echo "ðŸ“… Creating next milestone..."
      NEXT_VERSION=$(echo "$VERSION" | awk -F. '{print $1"."$2"."$3+1}')

      NEXT_MILESTONE=$(curl -sS --request POST \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"title\": \"v${NEXT_VERSION}\",
          \"description\": \"Next patch release (auto-created after v${VERSION})\"
        }" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" 2>/dev/null)

      NEXT_ID=$(echo "$NEXT_MILESTONE" | jq -r '.id // empty')
      if [ -n "$NEXT_ID" ]; then
        echo " âœ“ Created milestone v${NEXT_VERSION}"
      else
        echo " WARNING:  Milestone v${NEXT_VERSION} may already exist"
      fi

      echo ""
      echo "POST-RELEASE CLEANUP COMPLETE"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true" && $ENABLE_RELEASE == "true"
      when: on_success
  needs:
    - job: release:npm
      artifacts: true
    - job: detect:milestone-and-tags
      artifacts: true
  allow_failure: true

# ============================================================================
# WORKFLOW - MERGE TRAINS ENABLED
# ============================================================================
# Merge trains prevent branch divergence by:
# 1. Queuing MRs instead of racing to merge
# 2. Testing merged state before allowing merge
# 3. Auto-rebasing when target branch updates
# 4. Failing fast on conflicts
#
# Enabled for: development, main branches
# Eliminates: Manual sync commits between releases
# See: https://docs.gitlab.com/ee/ci/pipelines/merge_trains.html
# ============================================================================

workflow:
  rules:
    # Merge train pipelines (combined state testing)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merge_train"
    # Merged result pipelines (pre-merge validation)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"
    # Regular MR pipelines
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # Prevent duplicate pipelines (skip branch pipeline if MR is open)
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    # Regular branch pipelines
    - if: $CI_COMMIT_BRANCH
    # Tag pipelines
    - if: $CI_COMMIT_TAG
    - when: always

# ============================================================================
# RELEASE AUTOMATION - Enterprise Grade
# ============================================================================

# Auto-increment dev tag on merge to release branches
increment-dev-tag:
  stage: .post
  image: node:${NODE_VERSION}
  before_script:
    - apk add --no-cache curl jq
    - npm ci
    - npm install -g tsx
  script:
    - tsx .gitlab/release-automation/scripts/increment-dev-tag.ts
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/ && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: true

# Manual release buttons (main branch only)
release-to-npm:
  stage: release
  image: node:${NODE_VERSION}
  before_script:
    - apk add --no-cache curl jq
    - npm ci
  script:
    - RELEASE_ACTION=npm tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production

release-to-github:
  stage: release
  image: node:${NODE_VERSION}
  needs: [release-to-npm]
  before_script:
    - apk add --no-cache curl jq
    - npm ci
  script:
    - RELEASE_ACTION=github tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: github
    url: https://github.com/blueflyio/openstandardagents
    deployment_tier: production

# Website deployment moved to openstandardagents.org repository
# See: https://gitlab.com/blueflyio/openstandardagents.org

announce-release:
  stage: .post
  image: node:${NODE_VERSION}
  needs: [release-to-github]
  before_script:
    - apk add --no-cache curl jq
    - npm ci
  script:
    - RELEASE_ACTION=announce tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
# ============================================================================
# AUTOMATED RELEASE MR CREATION
# ============================================================================

create-release-mrs:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      : "${GITLAB_PUSH_TOKEN:?GITLAB_PUSH_TOKEN not set}"
      echo "Checking for milestones needing release MRs..."

      MILESTONES=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_PUSH_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/milestones?state=active")

      echo "$MILESTONES" | jq -r '.[] | select(.title | startswith("v")) | .id + " " + .title' | while read MILESTONE_ID MILESTONE_TITLE; do
        # Extract version from milestone title (e.g., v0.3.x from "v0.3.5")
        RELEASE_BRANCH=$(echo "$MILESTONE_TITLE" | sed -E 's/v([0-9]+\.[0-9]+)\.[0-9]+/release\/v\1.x/')

        EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_PUSH_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened&source_branch=${RELEASE_BRANCH}&target_branch=main&milestone=$MILESTONE_TITLE" \
          | jq -r '.[0].iid // empty')

        if [ -z "$EXISTING_MR" ]; then
          curl --request POST \
            --header "PRIVATE-TOKEN: $GITLAB_PUSH_TOKEN" \
            --header "Content-Type: application/json" \
            --data "{
              \"source_branch\": \"${RELEASE_BRANCH}\",
              \"target_branch\": \"main\",
              \"title\": \"Draft:  Release $MILESTONE_TITLE\",
              \"description\": \"## Release $MILESTONE_TITLE\\n\\nDraft MR for next release. Features merge to ${RELEASE_BRANCH} and accumulate here.\\n\\n### When Ready\\n1. Mark as ready\\n2. Add to merge train\\n3. Train merges to main\\n4. Release automation runs\",
              \"milestone_id\": $MILESTONE_ID,
              \"draft\": true,
              \"labels\": \"type::release,status::draft\"
            }" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests"
        fi
      done
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: manual

# Generate llms.txt context files
generate:llms-txt:
  stage: build
  image: python:3.11-slim
  script:
    - pip install llms-txt
    - llms_txt2ctx llms.txt > llms-ctx.txt
    - llms_txt2ctx llms.txt --optional True > llms-ctx-full.txt
  artifacts:
    paths:
      - llms.txt
      - llms-ctx.txt
      - llms-ctx-full.txt
    expire_in: never
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: on_success

# ============================================================================
# POST-RELEASE SYNC - Sync main back to release branches after releases
# ============================================================================

dependency:update:
  stage: .post
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git
  script:
    - |
      echo "ðŸ“¦ Checking for outdated dependencies..."
      npm outdated || true

      echo ""
      echo "ðŸ”’ Running security audit..."
      npm audit || true

      echo ""
      echo "ðŸ’¡ To fix vulnerabilities, run: npm audit fix --audit-level=moderate"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: true

sync:main-to-release:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl jq
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      echo "Syncing main â†’ release branches..."

      # Extract version from latest tag to determine release branch
      LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.3.0")
      RELEASE_BRANCH=$(echo "$LATEST_TAG" | sed -E 's/v([0-9]+\.[0-9]+)\.[0-9]+/release\/v\1.x/')

      git fetch origin main "$RELEASE_BRANCH"
      git checkout "$RELEASE_BRANCH"
      git pull origin "$RELEASE_BRANCH"

      # Check if main has commits not in release branch
      BEHIND=$(git rev-list --count "${RELEASE_BRANCH}..origin/main")

      if [ "$BEHIND" -gt 0 ]; then
        echo "${RELEASE_BRANCH} is $BEHIND commits behind main"

        # Create sync MR automatically
        curl --request POST \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "{
            \"source_branch\": \"main\",
            \"target_branch\": \"${RELEASE_BRANCH}\",
            \"title\": \"chore: sync main â†’ ${RELEASE_BRANCH} post-release [skip ci]\",
            \"description\": \"Automated sync after release. Contains release commits.\",
            \"remove_source_branch\": false,
            \"squash\": true
          }" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
      else
        echo "${RELEASE_BRANCH} is up-to-date with main"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_TAG
      when: on_success
    - when: never



# Auto-create RC tag on every merge to main
create-rc-tag:main:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
  script:
    - |
      echo "RC TAG AUTOMATION FOR MAIN BRANCH"
      echo "=================================="
      
      # Get version from package.json
      VERSION=$(grep '"version"' package.json | sed -E 's/.*"version":\s*"([^"]+)".*/\1/' | sed 's/-dev\.[0-9]*//' | sed 's/-rc\.[0-9]*//')
      
      if [ -z "$VERSION" ]; then
        echo "ERROR: Could not extract version from package.json"
        exit 1
      fi
      
      echo "Base version: $VERSION"
      
      # Get latest RC tag for this version
      LATEST_RC_TAG=$(git tag -l "v${VERSION}-rc.*" | sort -V | tail -n1)
      
      if [ -z "$LATEST_RC_TAG" ]; then
        # No RC tags exist, start with rc.1
        NEW_TAG="v${VERSION}-rc.1"
        echo "No existing RC tags for v${VERSION}, starting with ${NEW_TAG}"
      else
        echo "Latest RC tag: $LATEST_RC_TAG"
        
        # Check if HEAD is already tagged
        HEAD_TAGS=$(git tag --points-at HEAD)
        if echo "$HEAD_TAGS" | grep -qE "^v${VERSION}-rc\."; then
          echo "HEAD already has RC tag: $HEAD_TAGS"
          exit 0
        fi
        
        # Extract RC number and increment
        RC_NUM=$(echo "$LATEST_RC_TAG" | sed -E "s/v${VERSION}-rc\.([0-9]+)/\1/")
        NEW_RC_NUM=$((RC_NUM + 1))
        NEW_TAG="v${VERSION}-rc.${NEW_RC_NUM}"
      fi
      
      echo ""
      echo "TAG: Creating new RC tag: $NEW_TAG"
      
      # Create annotated tag
      git tag -a "$NEW_TAG" -m "RC tag $NEW_TAG from main branch

      Commit: $CI_COMMIT_SHA
      Pipeline: $CI_PIPELINE_URL
      Branch: $CI_COMMIT_BRANCH
      "
      
      # Push tag
      if git push origin "$NEW_TAG"; then
        echo "Successfully created and pushed RC tag: $NEW_TAG"
      else
        echo "ERROR: Failed to push RC tag"
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: false
