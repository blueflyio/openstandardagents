# =============================================================================
# OSSA Website CI/CD Pipeline with Auto DevOps Integration
# =============================================================================
#
# Auto DevOps Features Enabled:
# - Auto Build: Cloud Native Buildpacks (CNB) with Heroku builder
# - Auto Test: Herokuish-based test detection
# - Auto Code Quality: Static analysis with GitLab Code Quality
# - Auto SAST: Static application security testing
# - Auto Secret Detection: Credential leak detection
# - Auto Dependency Scanning: Vulnerability scanning for dependencies
# - Auto Container Scanning: Docker image vulnerability scanning
# - Auto Browser Performance: Sitespeed.io performance testing
# - Auto Deploy: Kubernetes deployment with Helm
#
# GitLab Ultimate Features:
# - Unit Test Reports: JUnit XML format with coverage
# - Test Cases: Playwright E2E tests with JUnit reports
# - Metrics Reports: Custom deployment and build metrics
# - Code Quality: Docker-based code quality analysis
# - Browser Performance: Sitespeed.io performance testing
# - Accessibility Testing: Pa11y automated WCAG 2.1 AA compliance
#
# Pipeline Stages:
# 1. validate - Lint, typecheck, branch protection
# 2. test - Unit tests + E2E tests (Playwright)
# 3. build - Next.js static export
# 4. security - SAST, Secret Detection, Dependency Scanning
# 5. quality - Code quality, performance, accessibility
# 6. deploy - Staging (release branches) and Production (main)
# 7. release - Release automation
# =============================================================================

include:
  # Auto DevOps templates
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Container-Scanning.gitlab-ci.yml
  - template: Jobs/Code-Quality.gitlab-ci.yml
  # Custom OSSA agent automation
  - local: '.gitlab/ci/seo-automation.yml'

stages:
  - sync
  - validate
  - test
  - build
  - security
  - quality
  - deploy
  - release

variables:
  NODE_VERSION: "20"
  PLAYWRIGHT_BROWSERS_PATH: "$CI_PROJECT_DIR/.cache/ms-playwright"
  # Auto DevOps variables
  SAST_EXCLUDED_PATHS: "spec, test, tests, tmp, node_modules, .cache"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules, .cache"
  DS_EXCLUDED_PATHS: "spec, test, tests, tmp"
  CODE_QUALITY_DISABLED: "false"
  SAST_DISABLED: "false"
  SECRET_DETECTION_DISABLED: "false"
  DEPENDENCY_SCANNING_DISABLED: "false"
  CONTAINER_SCANNING_DISABLED: "false"

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^(feature|bugfix|hotfix|chore)\/.+/

# =============================================================================
# BRANCH PROTECTION & MR VALIDATION
# =============================================================================
validate:mr-target:
  stage: validate
  image: alpine:latest
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  before_script:
    - apk add --no-cache bash
  script:
    - |
      /bin/bash <<'BASH_SCRIPT'
      # Feature branches â†’ release/* (latest milestone)
      if [[ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" =~ \
        ^(feature|bugfix|chore|hotfix|fix)/ ]]; then
        if [[ ! "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" =~ ^release/v ]]; then
          echo "âŒ Feature branches must target release/* branches"
          echo "   Current target: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
          echo "   Expected: release/v*.*.x"
          exit 1
        fi
      fi

      # release/* â†’ main ONLY
      if [[ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" =~ ^release/ ]]; then
        if [ "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" != "main" ]; then
          echo "âŒ Release branches must target main"
          echo "   Current target: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
          exit 1
        fi
      fi
      
      echo "âœ… MR target validation passed"
      BASH_SCRIPT

enforce-main-branch-policy:
  stage: validate
  image: alpine:latest
  rules:
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH == "main"
  before_script:
    - apk add --no-cache bash
  script:
    - |
      /bin/bash <<'BASH_SCRIPT'
      if [[ ! "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" =~ ^release/ ]]; then
        echo "âŒ ERROR: Main branch only accepts merges from 'release/*'"
        echo "   Source: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME"
        echo "   Target: $CI_MERGE_REQUEST_TARGET_BRANCH"
        exit 1
      fi
      BASH_SCRIPT
    - echo "âœ… Branch policy check passed"

# =============================================================================
# TEMPLATES
# =============================================================================
.node-setup:
  image: node:${NODE_VERSION}-alpine
  variables:
    NODE_ENV: production
  before_script:
    - cd website
    - npm ci --prefer-offline --no-audit

# =============================================================================
# SYNC - Automated version, spec, schema, and examples sync
# =============================================================================
sync:auto:
  stage: sync
  image: node:${NODE_VERSION}-alpine
  variables:
    NODE_ENV: production
    GIT_STRATEGY: clone
  before_script:
    - apk add --no-cache git
    - git config user.email "ci@blueflyio.com"
    - git config user.name "GitLab CI"
    - cd website
    - npm ci --prefer-offline --no-audit
  script:
    - echo "ðŸ”„ Syncing OSSA spec, versions, examples, and wiki..."
    - npm run fetch-spec
    - npm run fetch-versions
    - npm run sync-version
    - npm run fetch-examples
    - npm run sync-wiki
    - |
      if [ -n "$(git status --porcelain)" ]; then
        echo "ðŸ“ Changes detected, committing..."
        git add -A
        git commit -m "chore(ci): auto-sync OSSA spec, versions, examples, and wiki [skip ci]"
        git remote set-url origin "https://oauth2:${CI_JOB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git"
        git push origin HEAD:${CI_COMMIT_REF_NAME}
        echo "âœ… Synced and committed"
      else
        echo "âœ… Already up to date"
      fi
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /\[skip ci\]/
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: false

# =============================================================================
# VALIDATE
# =============================================================================

# =============================================================================
# TEST
# =============================================================================
test:unit:
  extends: .node-setup
  stage: test
  script:
    - npm run test
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

test:e2e:
  stage: test
  image: mcr.microsoft.com/playwright:v1.48.0-jammy
  variables:
    NODE_ENV: development  # Required for Next.js dev server
  cache:
    key: playwright-cache
    paths:
      - .cache/ms-playwright
  before_script:
    - cd website
    - npm ci --prefer-offline --no-audit
    - npm run fetch-spec
    - npm run fetch-examples
    - npm run fetch-versions
    - npm run sync-version
  script:
    - npx playwright install --with-deps
    - npm run test:e2e -- --reporter=junit --reporter=html
  artifacts:
    when: always
    reports:
      junit: website/playwright-report/results.xml
    paths:
      - website/playwright-report
      - website/test-results
    expire_in: 30 days
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# BUILD
# =============================================================================
build:website:
  stage: build
  image: node:20-alpine
  variables:
    NODE_ENV: production
    GITLAB_TOKEN: $CI_JOB_TOKEN  # Enable authenticated access to private repos
  before_script:
    - cd website
    - npm ci --prefer-offline --no-audit
  script:
    - npm run build:no-wiki
    - mkdir -p ../website-build
    - cp -r out/* ../website-build/
  artifacts:
    paths:
      - website-build
    expire_in: 1 day

build:docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
    IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  script:
    - cd website
    - |
      cat > Dockerfile << 'EOF'
      FROM node:20-alpine
      WORKDIR /app
      COPY out ./out
      RUN npm install -g serve
      EXPOSE 3000
      CMD ["serve", "-s", "out", "-l", "3000"]
      EOF
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
  dependencies:
    - build:website
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# SECURITY
# =============================================================================
# SAST, Secret Detection, Dependency Scanning are included from templates
# Container Scanning needs the image to be built first
container_scanning:
  stage: security
  variables:
    CS_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    CS_REGISTRY_USER: gitlab-ci-token
    CS_REGISTRY_PASSWORD: $CI_JOB_TOKEN
  dependencies:
    - build:docker
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# QUALITY
# =============================================================================
quality:browser-performance:
  stage: quality
  image: docker:latest
  services:
    - docker:dind
  dependencies:
    - build:website
  variables:
    DOCKER_DRIVER: overlay2
  script:
    - mkdir -p sitespeed-results
    # Start a simple HTTP server to serve static files, then run sitespeed
    - |
      docker network create perf-net || true
      docker run -d --name static-server --network perf-net \
        -v "$(pwd)/website-build":/usr/share/nginx/html:ro \
        nginx:alpine
      sleep 3
      docker run --network perf-net --shm-size=1g --rm \
        -v "$(pwd)/sitespeed-results":/sitespeed.io \
        sitespeedio/sitespeed.io:latest \
        http://static-server/index.html \
        --outputFolder /sitespeed.io \
        -n 1 || true
      docker stop static-server || true
      docker rm static-server || true
  artifacts:
    reports:
      browser_performance: sitespeed-results/data/performance.json
    paths:
      - sitespeed-results
    expire_in: 30 days
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

quality:accessibility:
  stage: quality
  image: node:${NODE_VERSION}
  dependencies:
    - build:website
  before_script:
    - npm install -g pa11y-ci
  script:
    - pa11y-ci --sitemap website-build/sitemap.xml --json > accessibility.json || true
  artifacts:
    reports:
      accessibility: accessibility.json
    paths:
      - accessibility.json
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

quality:metrics:
  extends: .node-setup
  stage: quality
  script:
    - |
      cat > metrics.txt << EOF
      # TYPE deployment_frequency counter
      # HELP deployment_frequency Number of deployments
      deployment_frequency{environment="$CI_ENVIRONMENT_NAME"} 1
      # TYPE build_duration_seconds gauge
      # HELP build_duration_seconds Build duration in seconds
      build_duration_seconds{job="$CI_JOB_NAME"} $CI_JOB_DURATION
      EOF
  artifacts:
    reports:
      metrics: metrics.txt
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# REVIEW - Disabled (GitLab artifact URLs don't work for SPAs)
# Use OrbStack environment for local testing instead
# =============================================================================

# =============================================================================
# STAGING - GitLab Pages from release branches
# =============================================================================
pages:
  stage: deploy
  image: alpine:latest
  dependencies:
    - build:website
  script:
    - mkdir -p public
    - cp -r website-build/* public/
    - echo "âœ… Deployed to staging"
  artifacts:
    paths:
      - public
    expire_in: 30 days
  environment:
    name: orbstack
    url: http://ossa.orb.local
    deployment_tier: staging
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\//

# =============================================================================
# PRODUCTION - Manual approval required
# =============================================================================
deploy:production:
  stage: deploy
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - detect:version
    - build:website
  before_script:
    - |
      if [ -f build.env ]; then
        source build.env
        echo "Deploying version: ${RELEASE_TAG:-latest}"
      fi
  script:
    - |
      echo "ðŸš€ Deploying to production"
      echo "Version: ${RELEASE_TAG:-latest}"
      echo "Commit: ${CI_COMMIT_SHA}"
      # Production deployment commands go here
      # Example: npm run deploy:production
      echo "âœ… Production deployment completed"
  artifacts:
    paths:
      - public
    expire_in: 90 days
  environment:
    name: production
    action: start
    url: https://openstandardagents.org
    deployment_tier: production
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual  # Requires manual trigger + DAP approval
  resource_group: production

# =============================================================================
# NOTIFICATIONS
# =============================================================================
notify:discord:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [ -z "$DISCORD_WEBHOOK_URL" ]; then
        echo "âš ï¸  DISCORD_WEBHOOK_URL not set"
        exit 0
      fi

      # Determine deployment type
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        ENV="Production"
        COLOR=5763719  # Green
        URL="https://openstandardagents.org"
      elif echo "$CI_COMMIT_BRANCH" | grep -q "^release/"; then
        ENV="Staging"
        COLOR=15844367  # Gold
        URL="https://staging.openstandardagents.org"
      else
        exit 0
      fi

      # Build Discord embed
      PAYLOAD=$(cat <<EOF
      {
        "embeds": [{
          "title": "ðŸš€ ${ENV} Deployment",
          "description": "**openstandardagents.org** has been deployed",
          "color": ${COLOR},
          "fields": [
            {
              "name": "Environment",
              "value": "${ENV}",
              "inline": true
            },
            {
              "name": "Branch",
              "value": "${CI_COMMIT_BRANCH}",
              "inline": true
            },
            {
              "name": "Commit",
              "value": "[${CI_COMMIT_SHORT_SHA}](${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA})",
              "inline": true
            },
            {
              "name": "Pipeline",
              "value": "[#${CI_PIPELINE_ID}](${CI_PIPELINE_URL})",
              "inline": true
            },
            {
              "name": "Deployed By",
              "value": "${GITLAB_USER_NAME:-CI}",
              "inline": true
            },
            {
              "name": "URL",
              "value": "[${URL}](${URL})",
              "inline": true
            }
          ],
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }]
      }
      EOF
      )

      # Send to Discord
      curl -H "Content-Type: application/json" \
        -d "$PAYLOAD" \
        "$DISCORD_WEBHOOK_URL"

      echo "âœ… Discord notification sent"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: on_success
  allow_failure: true

# =============================================================================
# AGENT AUTOMATION
# =============================================================================
mr-manager-agent:
  stage: .pre
  image: node:20-alpine
  before_script:
    - npm install -g pnpm
  script:
    - |
      echo "MR Manager Agent triggered"
      echo "MR: $CI_MERGE_REQUEST_IID"
      echo "Pipeline: $CI_PIPELINE_ID"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: true

# =============================================================================
# VERSION DETECTION
# =============================================================================
detect:version:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache git bash
  script:
    - chmod +x .gitlab/scripts/detect-version.sh
    - .gitlab/scripts/detect-version.sh
  artifacts:
    reports:
      dotenv: build.env
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^release\/v/ && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"

# =============================================================================
# CHANGELOG AUTOMATION (git-cliff)
# =============================================================================
changelog:generate:
  stage: release
  image: alpine:latest
  dependencies:
    - detect:version
  before_script:
    - apk add --no-cache git bash curl
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    # Install git-cliff
    - curl -sSfL https://github.com/orhun/git-cliff/releases/download/v2.7.0/git-cliff-2.7.0-x86_64-unknown-linux-musl.tar.gz | tar -xz
    - mv git-cliff-2.7.0/git-cliff /usr/local/bin/
    - chmod +x /usr/local/bin/git-cliff
  script:
    - |
      echo "ðŸ“ Generating CHANGELOG.md with git-cliff..."

      # Fetch all tags for proper changelog generation
      git fetch --tags

      # Generate changelog
      if [ -f build.env ]; then
        source build.env
        git cliff --tag "${RELEASE_TAG}" -o CHANGELOG.md
      else
        git cliff -o CHANGELOG.md
      fi

      # Check if changelog changed
      if [ -n "$(git status --porcelain CHANGELOG.md)" ]; then
        echo "ðŸ“ Changelog updated, committing..."
        git add CHANGELOG.md
        git commit -m "chore(release): update CHANGELOG.md [skip ci]"
        git push origin HEAD:${CI_COMMIT_REF_NAME}
        echo "âœ… Changelog committed and pushed"
      else
        echo "âœ… Changelog already up to date"
      fi
  artifacts:
    paths:
      - CHANGELOG.md
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/ && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/
      when: on_success

# =============================================================================
# RELEASE TAGGING
# =============================================================================
# On release/* branches: Create pre-release tags (v0.3.0-dev, v0.3.0-dev1, etc.)
release:pre-release:
  stage: release
  image: alpine:latest
  dependencies:
    - detect:version
  before_script:
    - apk add --no-cache git bash curl
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - |
      if [ -f build.env ]; then
        source build.env
        echo "Creating pre-release tag: ${RELEASE_TAG}"
        
        # Check if tag already exists
        if git rev-parse "${RELEASE_TAG}" >/dev/null 2>&1; then
          echo "Tag ${RELEASE_TAG} already exists, skipping"
          exit 0
        fi
        
        # Create annotated tag
        git tag -a "${RELEASE_TAG}" \
          -m "Pre-release: ${RELEASE_TAG}" \
          -m "Branch: ${CI_COMMIT_BRANCH}" \
          -m "Commit: ${CI_COMMIT_SHA}" \
          -m "Pipeline: ${CI_PIPELINE_ID}"
        
        # Push tag
        git push origin "${RELEASE_TAG}"
        
        echo "âœ… Created pre-release tag: ${RELEASE_TAG}"
      else
        echo "âš ï¸ build.env not found, skipping tag creation"
      fi
  rules:
    # Auto-create dev tags on release branches (no manual approval needed)
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: on_success

# On main: Create final release tag + GitLab Release
release:final:
  stage: release
  image: alpine:latest
  dependencies:
    - detect:version
    - build:website
  before_script:
    - apk add --no-cache git bash curl jq
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - |
      if [ -f build.env ]; then
        source build.env
        
        if [ "$IS_RELEASE" != "true" ]; then
          echo "Not on main branch, skipping final release"
          exit 0
        fi
        
        echo "Creating final release tag: ${RELEASE_TAG}"
        
        # Check if tag already exists
        if git rev-parse "${RELEASE_TAG}" >/dev/null 2>&1; then
          echo "Tag ${RELEASE_TAG} already exists, skipping"
          exit 0
        fi
        
        # Create annotated tag
        git tag -a "${RELEASE_TAG}" \
          -m "Release: ${RELEASE_TAG}" \
          -m "Commit: ${CI_COMMIT_SHA}" \
          -m "Pipeline: ${CI_PIPELINE_ID}"
        
        # Push tag
        git push origin "${RELEASE_TAG}"
        
        # Generate release notes from commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -n "$LAST_TAG" ]; then
          RELEASE_NOTES=$(git log --pretty=format:"- %s (%h)" ${LAST_TAG}..HEAD)
        else
          RELEASE_NOTES=$(git log --pretty=format:"- %s (%h)" -10)
        fi
        
        # Create GitLab Release via API
        RELEASE_RESPONSE=$(curl -s --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "{
            \"name\": \"Release ${RELEASE_TAG}\",
            \"tag_name\": \"${RELEASE_TAG}\",
            \"description\": \"## Release ${RELEASE_TAG}\n\n${RELEASE_NOTES}\",
            \"assets\": {
              \"links\": []
            }
          }" \
          "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/releases")
        
        if echo "$RELEASE_RESPONSE" | jq -e '.tag_name' >/dev/null 2>&1; then
          echo "âœ… Created GitLab Release: ${RELEASE_TAG}"
        else
          echo "âš ï¸ Failed to create GitLab Release: ${RELEASE_RESPONSE}"
        fi
        
        echo "âœ… Created release tag: ${RELEASE_TAG}"
      else
        echo "âš ï¸ build.env not found, skipping release"
      fi
  release:
    tag_name: $RELEASE_TAG
    description: "Release $RELEASE_TAG"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: on_success

# =============================================================================
# BRANCH PROTECTION - Prevent release branch deletion
# =============================================================================
protect:release-branches:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [[ "$CI_COMMIT_BRANCH" =~ ^release/v ]]; then
        echo "Protecting release branch: $CI_COMMIT_BRANCH"

        # Check if branch protection exists
        PROTECTION_RESPONSE=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
          "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/protected_branches/${CI_COMMIT_BRANCH}" 2>/dev/null || echo "{}")

        if echo "$PROTECTION_RESPONSE" | jq -e '.name' >/dev/null 2>&1; then
          echo "Branch protection already exists for $CI_COMMIT_BRANCH"
        else
          echo "Creating branch protection for $CI_COMMIT_BRANCH"

          # Create branch protection with prevent deletion
          PROTECT_RESPONSE=$(curl -s -X POST \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{
              \"name\": \"${CI_COMMIT_BRANCH}\",
              \"allow_force_push\": false,
              \"allowed_to_merge\": [{\"access_level\": 40}],
              \"allowed_to_push\": [{\"access_level\": 40}],
              \"code_owner_approval_required\": false
            }" \
            "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/protected_branches" 2>/dev/null || echo "{}")

          if echo "$PROTECT_RESPONSE" | jq -e '.name' >/dev/null 2>&1; then
            echo "âœ… Branch protection created for $CI_COMMIT_BRANCH"
          else
            echo "âš ï¸  Could not create branch protection (may require maintainer/admin access)"
            echo "Response: $PROTECT_RESPONSE"
          fi
        fi

        # Ensure MR doesn't delete the branch
        if [ -n "$CI_MERGE_REQUEST_IID" ]; then
          echo "Updating MR #$CI_MERGE_REQUEST_IID to prevent branch deletion"
          curl -s -X PUT \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
            --header "Content-Type: application/json" \
            --data '{"remove_source_branch": false}' \
            "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}" >/dev/null || true
        fi
      else
        echo "Not a release branch, skipping protection"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: on_success
  allow_failure: true
