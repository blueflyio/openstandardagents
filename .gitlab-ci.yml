# =============================================================================
# OSSA Website CI/CD Pipeline with Auto DevOps Integration
# =============================================================================
#
# Auto DevOps Features Enabled:
# - Auto Build: Cloud Native Buildpacks (CNB) with Heroku builder
# - Auto Test: Herokuish-based test detection
# - Auto Code Quality: Static analysis with GitLab Code Quality
# - Auto SAST: Static application security testing
# - Auto Secret Detection: Credential leak detection
# - Auto Dependency Scanning: Vulnerability scanning for dependencies
# - Auto Container Scanning: Docker image vulnerability scanning
# - Auto Browser Performance: Sitespeed.io performance testing
# - Auto Deploy: Kubernetes deployment with Helm
#
# GitLab Ultimate Features:
# - Unit Test Reports: JUnit XML format with coverage
# - Test Cases: Playwright E2E tests with JUnit reports
# - Metrics Reports: Custom deployment and build metrics
# - Code Quality: Docker-based code quality analysis
# - Browser Performance: Sitespeed.io performance testing
# - Accessibility Testing: Pa11y automated WCAG 2.1 AA compliance
#
# Pipeline Stages:
# 1. validate - Lint, typecheck, branch protection
# 2. test - Unit tests + E2E tests (Playwright)
# 3. build - Next.js static export
# 4. security - SAST, Secret Detection, Dependency Scanning
# 5. quality - Code quality, performance, accessibility
# 6. deploy - Staging (release branches) and Production (main)
# 7. release - Release automation
# =============================================================================

include:
  # Auto DevOps templates
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  - template: Jobs/Container-Scanning.gitlab-ci.yml
  - template: Jobs/Code-Quality.gitlab-ci.yml
  # Review Apps (OrbStack K8s)
  - local: .gitlab/ci/review-apps.yml
  # OSSA Agent Pipelines
  #- local: .gitlab/ci/seo-automation.yml

stages:
  - sync
  - validate
  - test
  - build
  - security
  - quality
  - deploy
  - release

variables:
  NODE_VERSION: "20"
  PLAYWRIGHT_BROWSERS_PATH: "$CI_PROJECT_DIR/.cache/ms-playwright"
  # Auto DevOps variables
  SAST_EXCLUDED_PATHS: "spec, test, tests, tmp, node_modules, .cache"
  SECRET_DETECTION_EXCLUDED_PATHS: "node_modules, .cache"
  DS_EXCLUDED_PATHS: "spec, test, tests, tmp"
  CODE_QUALITY_DISABLED: "false"
  SAST_DISABLED: "false"
  SECRET_DETECTION_DISABLED: "false"
  DEPENDENCY_SCANNING_DISABLED: "false"
  CONTAINER_SCANNING_DISABLED: "false"

workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^(feature|bugfix|hotfix|chore)\/.+/

# Use GitLab SaaS shared runners by default (local runners as backup)
default:
  tags:
    - local

# =============================================================================
# BRANCH PROTECTION & MR VALIDATION
# =============================================================================
validate:mr-target:
  stage: validate
  image: alpine:latest
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  before_script:
    - apk add --no-cache bash
  allow_failure: true
  script:
    - |
      /bin/bash <<'BASH_SCRIPT'
      # Feature branches ‚Üí release/* (latest milestone)
      if [[ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" =~ \
        ^(feature|bugfix|chore|hotfix|fix)/ ]]; then
        if [[ ! "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" =~ ^release/v ]]; then
          echo "‚ùå Feature branches must target release/* branches"
          echo "   Current target: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
          echo "   Expected: release/v*.*.x"
          exit 1
        fi
      fi

      # release/* ‚Üí main ONLY
      if [[ "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" =~ ^release/ ]]; then
        if [ "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" != "main" ]; then
          echo "‚ùå Release branches must target main"
          echo "   Current target: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
          exit 1
        fi
      fi
      
      echo "‚úÖ MR target validation passed"
      BASH_SCRIPT

enforce-main-branch-policy:
  stage: validate
  image: alpine:latest
  rules:
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH == "main"
  before_script:
    - apk add --no-cache bash
  allow_failure: true
  script:
    - |
      /bin/bash <<'BASH_SCRIPT'
      if [[ ! "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" =~ ^release/ ]]; then
        echo "‚ùå ERROR: Main branch only accepts merges from 'release/*'"
        echo "   Source: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME"
        echo "   Target: $CI_MERGE_REQUEST_TARGET_BRANCH"
        exit 1
      fi
      BASH_SCRIPT
    - echo "‚úÖ Branch policy check passed"

# =============================================================================
# TEMPLATES
# =============================================================================
.node-setup:
  image: node:${NODE_VERSION}-alpine
  variables:
    NODE_ENV: production
  before_script:
    - cd website
    - npm ci --prefer-offline --no-audit

# =============================================================================
# SYNC - Automated version, spec, schema, and examples sync
# =============================================================================
sync:auto:
  stage: sync
  image: node:${NODE_VERSION}-alpine
  variables:
    NODE_ENV: production
    GIT_STRATEGY: clone
  before_script:
    - apk add --no-cache git
    - git config user.email "ci@blueflyio.com"
    - git config user.name "GitLab CI"
    - cd website
    - npm ci --prefer-offline --no-audit
  script:
    - echo "üîÑ Syncing OSSA spec, versions, examples, and wiki..."
    - npm run fetch-spec
    - npm run fetch-versions
    - npm run sync-version
    - npm run fetch-examples
    - npm run sync-wiki
    - |
      if [ -n "$(git status --porcelain)" ]; then
        echo "üìù Changes detected, committing..."
        git add -A
        git commit -m "chore(ci): auto-sync OSSA spec, versions, examples, and wiki [skip ci]"
        git remote set-url origin "https://oauth2:${CI_JOB_TOKEN}@gitlab.com/${CI_PROJECT_PATH}.git"
        git push origin HEAD:${CI_COMMIT_REF_NAME}
        echo "‚úÖ Synced and committed"
      else
        echo "‚úÖ Already up to date"
      fi
  rules:
    - if: $CI_COMMIT_MESSAGE =~ /\[skip ci\]/
      when: never
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"
  allow_failure: false

# =============================================================================
# VALIDATE
# =============================================================================

# =============================================================================
# TEST
# =============================================================================
test:unit:
  extends: .node-setup
  stage: test
  script:
    - npm run test
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

test:e2e:
  stage: test
  image: mcr.microsoft.com/playwright:v1.48.0-jammy
  variables:
    NODE_ENV: development  # Required for Next.js dev server
  cache:
    key: playwright-cache
    paths:
      - .cache/ms-playwright
  before_script:
    - cd website
    - npm ci --prefer-offline --no-audit
    - npm run fetch-spec
    - npm run fetch-examples
    - npm run fetch-versions
    - npm run sync-version
  script:
    - npx playwright install --with-deps
    - npm run test:e2e -- --reporter=junit --reporter=html
  artifacts:
    when: always
    reports:
      junit: website/playwright-report/results.xml
    paths:
      - website/playwright-report
      - website/test-results
    expire_in: 30 days
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# BUILD
# =============================================================================
build:website:
  stage: build
  image: node:20-alpine
  variables:
    NODE_ENV: production
    GITLAB_TOKEN: $CI_JOB_TOKEN  # Enable authenticated access to private repos
    WEB_TOKEN: $WEB_TOKEN  # Cross-project access to openstandardagents project
  before_script:
    - cd website
    - npm ci --prefer-offline --no-audit
  script:
    - npm run build:no-wiki
    - mkdir -p ../website-build
    - cp -r out/* ../website-build/
  artifacts:
    paths:
      - website-build
    expire_in: 1 day
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

build:docker:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
    IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  script:
    - cd website
    - mkdir -p out && cp -r ../website-build/* out/
    - |
      cat > Dockerfile << 'EOF'
      FROM node:20-alpine
      WORKDIR /app
      COPY out ./out
      RUN npm install -g serve
      EXPOSE 3000
      CMD ["serve", "-s", "out", "-l", "3000"]
      EOF
    - echo $CI_JOB_TOKEN | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
    - |
      # Also tag as MR-specific for review apps
      if [ -n "$CI_MERGE_REQUEST_IID" ]; then
        docker tag $IMAGE_TAG $CI_REGISTRY_IMAGE:mr-$CI_MERGE_REQUEST_IID
        docker push $CI_REGISTRY_IMAGE:mr-$CI_MERGE_REQUEST_IID
      fi
  needs:
    - build:website
  allow_failure: false
  rules:
    # Build for MRs (needed for review apps)
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# SECURITY
# =============================================================================
# SAST, Secret Detection, Dependency Scanning are included from templates
# Container Scanning needs the image to be built first
container_scanning:
  stage: security
  variables:
    CS_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    CS_REGISTRY_USER: gitlab-ci-token
    CS_REGISTRY_PASSWORD: $CI_JOB_TOKEN
  needs:
    - build:docker
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# QUALITY
# =============================================================================
quality:browser-performance:
  stage: quality
  image: docker:latest
  services:
    - docker:dind
  needs:
    - build:website
  variables:
    DOCKER_DRIVER: overlay2
  script:
    - mkdir -p sitespeed-results
    # Start a simple HTTP server to serve static files, then run sitespeed
    - |
      docker network create perf-net || true
      docker run -d --name static-server --network perf-net \
        -v "$(pwd)/website-build":/usr/share/nginx/html:ro \
        nginx:alpine
      sleep 3
      docker run --network perf-net --shm-size=1g --rm \
        -v "$(pwd)/sitespeed-results":/sitespeed.io \
        sitespeedio/sitespeed.io:latest \
        http://static-server/index.html \
        --outputFolder /sitespeed.io \
        -n 1 || true
      docker stop static-server || true
      docker rm static-server || true
  artifacts:
    reports:
      browser_performance: sitespeed-results/data/performance.json
    paths:
      - sitespeed-results
    expire_in: 30 days
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

quality:accessibility:
  stage: quality
  image: node:${NODE_VERSION}
  needs:
    - build:website
  before_script:
    - npm install -g pa11y-ci
  script:
    - pa11y-ci --sitemap website-build/sitemap.xml --json > accessibility.json || true
  artifacts:
    reports:
      accessibility: accessibility.json
    paths:
      - accessibility.json
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

quality:metrics:
  extends: .node-setup
  stage: quality
  script:
    - |
      cat > metrics.txt << EOF
      # TYPE deployment_frequency counter
      # HELP deployment_frequency Number of deployments
      deployment_frequency{environment="$CI_ENVIRONMENT_NAME"} 1
      # TYPE build_duration_seconds gauge
      # HELP build_duration_seconds Build duration in seconds
      build_duration_seconds{job="$CI_JOB_NAME"} $CI_JOB_DURATION
      EOF
  artifacts:
    reports:
      metrics: metrics.txt
    expire_in: 30 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    - if: $CI_COMMIT_BRANCH == "main"

# =============================================================================
# REVIEW APPS - Deployed via .gitlab/ci/review-apps.yml
# =============================================================================
# - Feature MRs ‚Üí release: Deploys to http://ossa-mr-<ID>.orb.local
# - Release MRs ‚Üí main: Deploys to http://ossa-staging.orb.local
# - Main branch: Manual "Go Live" button deploys to GitLab Pages

# =============================================================================
# PRODUCTION - GitLab Pages (Manual Deploy)
# =============================================================================
# The special "pages" job name triggers GitLab Pages deployment
# This creates the public/ artifact that becomes the live site
pages:
  stage: deploy
  image: alpine:latest
  tags:
    - local
  needs:
    - build:website
  script:
    - |
      echo "üöÄ Deploying to GitLab Pages (Production)"
      mkdir -p public
      cp -r website-build/* public/

      echo ""
      echo "=============================================="
      echo "‚úÖ PRODUCTION DEPLOYMENT COMPLETE!"
      echo "=============================================="
      echo "üåê URL: https://openstandardagents.org"
      echo "üìù Commit: ${CI_COMMIT_SHORT_SHA}"
      echo "üè∑Ô∏è  Branch: ${CI_COMMIT_BRANCH}"
      echo "=============================================="
  artifacts:
    paths:
      - public
    expire_in: 30 days
  environment:
    name: production
    url: https://openstandardagents.org
    deployment_tier: production
  rules:
    # Manual deploy button on main branch
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  resource_group: production

# =============================================================================
# NOTIFICATIONS
# =============================================================================
notify:discord:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [ -z "$DISCORD_WEBHOOK_URL" ]; then
        echo "‚ö†Ô∏è  DISCORD_WEBHOOK_URL not set"
        exit 0
      fi

      # Determine deployment type
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        ENV="Production"
        COLOR=5763719  # Green
        URL="https://openstandardagents.org"
      elif echo "$CI_COMMIT_BRANCH" | grep -q "^release/"; then
        ENV="Staging"
        COLOR=15844367  # Gold
        URL="https://staging.openstandardagents.org"
      else
        exit 0
      fi

      # Build Discord embed
      PAYLOAD=$(cat <<EOF
      {
        "embeds": [{
          "title": "üöÄ ${ENV} Deployment",
          "description": "**openstandardagents.org** has been deployed",
          "color": ${COLOR},
          "fields": [
            {
              "name": "Environment",
              "value": "${ENV}",
              "inline": true
            },
            {
              "name": "Branch",
              "value": "${CI_COMMIT_BRANCH}",
              "inline": true
            },
            {
              "name": "Commit",
              "value": "[${CI_COMMIT_SHORT_SHA}](${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA})",
              "inline": true
            },
            {
              "name": "Pipeline",
              "value": "[#${CI_PIPELINE_ID}](${CI_PIPELINE_URL})",
              "inline": true
            },
            {
              "name": "Deployed By",
              "value": "${GITLAB_USER_NAME:-CI}",
              "inline": true
            },
            {
              "name": "URL",
              "value": "[${URL}](${URL})",
              "inline": true
            }
          ],
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }]
      }
      EOF
      )

      # Send to Discord
      curl -H "Content-Type: application/json" \
        -d "$PAYLOAD" \
        "$DISCORD_WEBHOOK_URL"

      echo "‚úÖ Discord notification sent"
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: on_success
  allow_failure: true

# =============================================================================
# AGENT AUTOMATION
# =============================================================================
# Conditional agent jobs - only run if GitLab Ultimate + Agents available
# Otherwise skip with warning

.agent-job-template:
  stage: .pre
  allow_failure: true

mr-manager-agent:
  extends: .agent-job-template
  image: node:20-alpine
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  before_script:
    - apk add --no-cache curl jq
    - |
      echo "Checking GitLab Ultimate + Agent availability..."
      LICENSE_CHECK=$(curl -s --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}" 2>/dev/null | jq -r '.namespace.plan // "free"' || echo "free")
      
      if [[ "$LICENSE_CHECK" != "ultimate" ]]; then
        echo "WARNING: GitLab Ultimate not detected (plan: $LICENSE_CHECK)"
        echo "Skipping agent job - requires GitLab Ultimate + Duo Agents"
        echo "This is not a failure - agent features are optional"
        exit 0
      fi
      
      echo "GitLab Ultimate detected - agent features available"
    - npm install -g pnpm
  script:
    - |
      echo "MR Manager Agent triggered"
      echo "MR: $CI_MERGE_REQUEST_IID"
      echo "Pipeline: $CI_PIPELINE_ID"
      echo "Agent job completed (or skipped if Ultimate not available)"

# =============================================================================
# VERSION DETECTION
# =============================================================================
detect:version:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache git bash
  script:
    - |
      # Inline version detection
      if [ -f website/package.json ]; then
        VERSION=$(grep '"version"' website/package.json | head -1 | sed 's/.*": *"\([^"]*\)".*/\1/')
      else
        VERSION="0.0.0"
      fi
      echo "VERSION=$VERSION" > build.env
      echo "Detected version: $VERSION"
  artifacts:
    reports:
      dotenv: build.env
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^release\/v/ && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"

# =============================================================================
# CHANGELOG AUTOMATION (git-cliff)
# =============================================================================
changelog:generate:
  stage: release
  image: alpine:latest
  needs:
    - detect:version
  before_script:
    - apk add --no-cache git bash curl
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    # Install git-cliff
    - curl -sSfL https://github.com/orhun/git-cliff/releases/download/v2.7.0/git-cliff-2.7.0-x86_64-unknown-linux-musl.tar.gz | tar -xz
    - mv git-cliff-2.7.0/git-cliff /usr/local/bin/
    - chmod +x /usr/local/bin/git-cliff
  script:
    - |
      echo "üìù Generating CHANGELOG.md with git-cliff..."

      # Fetch all tags for proper changelog generation
      git fetch --tags

      # Generate changelog
      if [ -f build.env ]; then
        source build.env
        git cliff --tag "${RELEASE_TAG}" -o CHANGELOG.md
      else
        git cliff -o CHANGELOG.md
      fi

      # Check if changelog changed
      if [ -n "$(git status --porcelain CHANGELOG.md)" ]; then
        echo "üìù Changelog updated, committing..."
        git add CHANGELOG.md
        git commit -m "chore(release): update CHANGELOG.md [skip ci]"
        git push origin HEAD:${CI_COMMIT_REF_NAME}
        echo "‚úÖ Changelog committed and pushed"
      else
        echo "‚úÖ Changelog already up to date"
      fi
  artifacts:
    paths:
      - CHANGELOG.md
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/ && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/
      when: on_success

# =============================================================================
# RELEASE TAGGING
# =============================================================================
# On release/* branches: Create pre-release tags (v0.3.0-dev, v0.3.0-dev1, etc.)
release:pre-release:
  stage: release
  image: alpine:latest
  needs:
    - detect:version
  before_script:
    - apk add --no-cache git bash curl
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - |
      if [ -f build.env ]; then
        source build.env
        echo "Creating pre-release tag: ${RELEASE_TAG}"
        
        # Check if tag already exists
        if git rev-parse "${RELEASE_TAG}" >/dev/null 2>&1; then
          echo "Tag ${RELEASE_TAG} already exists, skipping"
          exit 0
        fi
        
        # Create annotated tag
        git tag -a "${RELEASE_TAG}" \
          -m "Pre-release: ${RELEASE_TAG}" \
          -m "Branch: ${CI_COMMIT_BRANCH}" \
          -m "Commit: ${CI_COMMIT_SHA}" \
          -m "Pipeline: ${CI_PIPELINE_ID}"
        
        # Push tag
        git push origin "${RELEASE_TAG}"
        
        echo "‚úÖ Created pre-release tag: ${RELEASE_TAG}"
      else
        echo "‚ö†Ô∏è build.env not found, skipping tag creation"
      fi
  rules:
    # Auto-create dev tags on release branches (no manual approval needed)
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: on_success

# On main: Create RC (release candidate) tag automatically
# Flow: release/v0.3.x ‚Üí main ‚Üí v0.3.X-rc.N (auto)
#       Then manually: promote-rc-to-final ‚Üí v0.3.X (final)
release:rc:
  stage: release
  image: alpine:latest
  needs:
    - detect:version
    - build:website
  before_script:
    - apk add --no-cache git bash curl jq
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - |
      if [ -f build.env ]; then
        source build.env

        if [ "$IS_RC" != "true" ]; then
          echo "Not an RC context, skipping RC tag creation"
          exit 0
        fi

        echo "Creating RC tag: ${RELEASE_TAG}"

        # Check if tag already exists
        if git rev-parse "${RELEASE_TAG}" >/dev/null 2>&1; then
          echo "Tag ${RELEASE_TAG} already exists, skipping"
          exit 0
        fi

        # Create annotated RC tag
        git tag -a "${RELEASE_TAG}" \
          -m "Release Candidate: ${RELEASE_TAG}" \
          -m "Commit: ${CI_COMMIT_SHA}" \
          -m "Pipeline: ${CI_PIPELINE_ID}"

        # Push tag
        git push origin "${RELEASE_TAG}"

        echo "‚úÖ Created RC tag: ${RELEASE_TAG}"
        echo "üìã To promote to final: Click 'release:promote-rc-to-final' job"
      else
        echo "‚ö†Ô∏è build.env not found, skipping RC tag"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success

# Manual: Promote latest RC to final release
# Creates v0.3.X tag + GitLab Release
release:promote-rc-to-final:
  stage: release
  image: alpine:latest
  needs:
    - detect:version
  before_script:
    - apk add --no-cache git bash curl jq
    - git config user.email "ci@gitlab.com"
    - git config user.name "GitLab CI"
    - git remote set-url origin "https://oauth2:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch --tags
  script:
    - |
      if [ -f build.env ]; then
        source build.env

        FINAL_TAG="v${VERSION}"
        echo "Promoting to final release: ${FINAL_TAG}"

        # Check if final tag already exists
        if git rev-parse "${FINAL_TAG}" >/dev/null 2>&1; then
          echo "Final tag ${FINAL_TAG} already exists!"
          exit 1
        fi

        # Find latest RC tag for this version
        LATEST_RC=$(git tag -l "v${VERSION}-rc.*" | sort -V | tail -1)
        if [ -z "$LATEST_RC" ]; then
          echo "‚ùå No RC tags found for v${VERSION}"
          exit 1
        fi

        echo "Promoting ${LATEST_RC} ‚Üí ${FINAL_TAG}"

        # Create final tag pointing to same commit as latest RC
        RC_COMMIT=$(git rev-list -n 1 "${LATEST_RC}")
        git tag -a "${FINAL_TAG}" "${RC_COMMIT}" \
          -m "Release: ${FINAL_TAG}" \
          -m "Promoted from: ${LATEST_RC}" \
          -m "Pipeline: ${CI_PIPELINE_ID}"

        # Push final tag
        git push origin "${FINAL_TAG}"

        # Generate release notes
        PREV_TAG=$(git tag -l "v*" | grep -v rc | grep -v dev | sort -V | tail -2 | head -1)
        if [ -n "$PREV_TAG" ] && [ "$PREV_TAG" != "$FINAL_TAG" ]; then
          RELEASE_NOTES=$(git log --pretty=format:"- %s (%h)" ${PREV_TAG}..${RC_COMMIT})
        else
          RELEASE_NOTES=$(git log --pretty=format:"- %s (%h)" -20 ${RC_COMMIT})
        fi

        # Create GitLab Release
        # Create GitLab Release
        RELEASE_DESC="## Release ${FINAL_TAG}\n\nPromoted from ${LATEST_RC}\n\n### Changes\n\n${RELEASE_NOTES}"
        RELEASE_RESPONSE=$(curl -s --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "{\"name\": \"Release ${FINAL_TAG}\", \"tag_name\": \"${FINAL_TAG}\", \"description\": \"${RELEASE_DESC}\"}" \
          "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/releases")

        if echo "$RELEASE_RESPONSE" | jq -e '.tag_name' >/dev/null 2>&1; then
          echo "‚úÖ Created GitLab Release: ${FINAL_TAG}"
        else
          echo "‚ö†Ô∏è Failed to create GitLab Release: ${RELEASE_RESPONSE}"
        fi

        echo "‚úÖ Promoted ${LATEST_RC} ‚Üí ${FINAL_TAG}"
        echo "üìã To publish to npm: Click 'release:npm' job"
      else
        echo "‚ö†Ô∏è build.env not found"
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

# Manual: Publish to npm
release:npm:
  stage: release
  image: node:20-alpine
  needs:
    - detect:version
    - build:website
  before_script:
    - apk add --no-cache git
    - git fetch --tags
  script:
    - |
      if [ -f build.env ]; then
        source build.env

        FINAL_TAG="v${VERSION}"

        # Verify final tag exists (must promote RC first)
        if ! git rev-parse "${FINAL_TAG}" >/dev/null 2>&1; then
          echo "‚ùå Final tag ${FINAL_TAG} not found!"
          echo "   You must run 'release:promote-rc-to-final' first"
          exit 1
        fi

        echo "Publishing ${FINAL_TAG} to npm..."

        # Configure npm auth
        echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc

        # Publish packages (add your publish commands here)
        # Example for monorepo:
        # cd website && npm publish --access public

        echo "‚úÖ Published ${FINAL_TAG} to npm"
      else
        echo "‚ö†Ô∏è build.env not found"
        exit 1
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true

# =============================================================================
# BRANCH PROTECTION - Prevent release branch deletion
# =============================================================================
protect:release-branches:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [[ "$CI_COMMIT_BRANCH" =~ ^release/v ]]; then
        echo "Protecting release branch: $CI_COMMIT_BRANCH"

        # Check if branch protection exists
        PROTECTION_RESPONSE=$(curl -s --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
          "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/protected_branches/${CI_COMMIT_BRANCH}" 2>/dev/null || echo "{}")

        if echo "$PROTECTION_RESPONSE" | jq -e '.name' >/dev/null 2>&1; then
          echo "Branch protection already exists for $CI_COMMIT_BRANCH"
        else
          echo "Creating branch protection for $CI_COMMIT_BRANCH"

          # Create branch protection with prevent deletion
          PROTECT_RESPONSE=$(curl -s -X POST \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
            --header "Content-Type: application/json" \
            --data "{
              \"name\": \"${CI_COMMIT_BRANCH}\",
              \"allow_force_push\": false,
              \"allowed_to_merge\": [{\"access_level\": 40}],
              \"allowed_to_push\": [{\"access_level\": 40}],
              \"code_owner_approval_required\": false
            }" \
            "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/protected_branches" 2>/dev/null || echo "{}")

          if echo "$PROTECT_RESPONSE" | jq -e '.name' >/dev/null 2>&1; then
            echo "‚úÖ Branch protection created for $CI_COMMIT_BRANCH"
          else
            echo "‚ö†Ô∏è  Could not create branch protection (may require maintainer/admin access)"
            echo "Response: $PROTECT_RESPONSE"
          fi
        fi

        # Ensure MR doesn't delete the branch
        if [ -n "$CI_MERGE_REQUEST_IID" ]; then
          echo "Updating MR #$CI_MERGE_REQUEST_IID to prevent branch deletion"
          curl -s -X PUT \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN:-$CI_JOB_TOKEN}" \
            --header "Content-Type: application/json" \
            --data '{"remove_source_branch": false}' \
            "https://${CI_SERVER_HOST}/api/v4/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}" >/dev/null || true
        fi
      else
        echo "Not a release branch, skipping protection"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\/v/
      when: on_success
  allow_failure: true
