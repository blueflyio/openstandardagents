# GitLab CI/CD Pipeline for OSSA
# Decoupled Release Model
# - Code flows freely - Feature â†’ release/* â†’ main (CI validates, no auto-release)
# - Website deployment - Manual button (independent of releases)
# - NPM releases - Milestone-gated + ENABLE_RELEASE variable required
#
# Workflow
# 1. Feature branches â†’ merge to release/* branch based on milestone/issue/MR (CI validates)
# 2. Release/* branches â†’ merge to main via merge train (CI validates)
# 3. Click "Deploy Website" button â†’ GitLab Pages deploys
# 4. To release - Set ENABLE_RELEASE=true + close milestone â†’ automatic npm publish + git tag
#
# Release Gate
# Releases require BOTH conditions
#   - Milestone must be 100% complete and closed

include:
  - local: '.gitlab/ci/agents.yml'
  - local: '.gitlab/ci/branch-policy.yml'
  - local: '.gitlab/ci/release-automation.yml'  # Release automation agents
  # TODO: Add merge-train component when gitlab_components is made public/internal
  # - component: gitlab.com/blueflyio/agent-platform/gitlab_components/merge-train@main

#   - CI/CD variable ENABLE_RELEASE must be set to "true"
# This allows deploying to main without releasing. Set the variable only when ready to release.
#
# To set ENABLE_RELEASE
#   GitLab UI - Settings â†’ CI/CD â†’ Variables â†’ Add variable
#   Variable - ENABLE_RELEASE
#   Value - true
#   Protected - Yes (recommended)
#   Masked - No
#
# Status - ACTIVE MODE
# Last updated - 2025-11-25

stages:
  - setup
  - version-detect
  - validate
  - build
  - test
  - quality
  - deploy
  - release
  - mirror

variables:
  NODE_VERSION: "22"
  NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  HUSKY: "0"
  LEFTHOOK: "0"

# ============================================================================
# STAGE 0 - VERSION DETECTION & TAG MANAGEMENT (Dynamic from Branch Names)
# ============================================================================

detect:version-and-tags:
  stage: version-detect
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set +e
      
      echo "VERSION DETECTION & TAG MANAGEMENT"
      echo "==================================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo ""

      # Initialize env file
      cat > version.env << 'EOF'
      RELEASE_VERSION=
      VERSION_TAG=
      IS_RELEASE=false
      IS_DEV_TAG=false
      MILESTONE_READY=false
      MILESTONE_TITLE=
      MILESTONE_ID=
      MILESTONE_URL=
      IS_MINOR_RELEASE=false
      EOF

      # Extract base minor version from branch name
      # release/v0.3.x â†’ 0.3.0 (base minor version)
      # release/v1.0.x â†’ 1.0.0 (base minor version)
      # main â†’ detect from merge commit or latest release branch
      
      if [[ "$CI_COMMIT_BRANCH" =~ ^release/v([0-9]+)\.([0-9]+)\.x$ ]]; then
        MAJOR="${BASH_REMATCH[1]}"
        MINOR="${BASH_REMATCH[2]}"
        BASE_MINOR_VERSION="${MAJOR}.${MINOR}.0"
        
        echo "ðŸ“¦ Release branch detected: ${CI_COMMIT_BRANCH}"
        echo "   Base minor version: ${BASE_MINOR_VERSION}"
        
        # Check milestone for this minor version (e.g., v0.3.0)
        MILESTONE_TITLE="v${BASE_MINOR_VERSION}"
        echo "ðŸ” Checking milestone: ${MILESTONE_TITLE}"
        
        # Get milestone details
        MILESTONE_DATA=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --data-urlencode "title=${MILESTONE_TITLE}" \
          --data-urlencode "per_page=1" 2>/dev/null || echo "[]")
        
        MILESTONE_ID=$(echo "$MILESTONE_DATA" | jq -r '.[0].id // empty' 2>/dev/null || echo "")
        MILESTONE_STATE=$(echo "$MILESTONE_DATA" | jq -r '.[0].state // "active"' 2>/dev/null || echo "active")
        MILESTONE_URL=$(echo "$MILESTONE_DATA" | jq -r '.[0].web_url // ""' 2>/dev/null || echo "")
        
        if [ -n "$MILESTONE_ID" ]; then
          # Get milestone statistics
          MILESTONE_STATS=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${MILESTONE_ID}" \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" 2>/dev/null || echo "{}")
          
          TOTAL_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.total_issues_count // 0' 2>/dev/null || echo "0")
          CLOSED_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.closed_issues_count // 0' 2>/dev/null || echo "0")
          OPEN_ISSUES=$((TOTAL_ISSUES - CLOSED_ISSUES))
          
          echo "   Milestone state: ${MILESTONE_STATE}"
          echo "   Total issues: ${TOTAL_ISSUES}"
          echo "   Closed issues: ${CLOSED_ISSUES}"
          echo "   Open issues: ${OPEN_ISSUES}"
          
          # Check if milestone is ready (closed AND all issues completed)
          if [ "$MILESTONE_STATE" = "closed" ] && [ "$OPEN_ISSUES" -eq 0 ] && [ "$TOTAL_ISSUES" -gt 0 ]; then
            echo "   âœ… Milestone ready for minor release"
            echo "MILESTONE_READY=true" >> version.env
            echo "MILESTONE_TITLE=${MILESTONE_TITLE}" >> version.env
            echo "MILESTONE_ID=${MILESTONE_ID}" >> version.env
            echo "MILESTONE_URL=${MILESTONE_URL}" >> version.env
          else
            echo "   âš ï¸  Milestone not ready (state: ${MILESTONE_STATE}, open issues: ${OPEN_ISSUES})"
            echo "MILESTONE_READY=false" >> version.env
            echo "MILESTONE_TITLE=${MILESTONE_TITLE}" >> version.env
            echo "MILESTONE_ID=${MILESTONE_ID}" >> version.env
            echo "MILESTONE_URL=${MILESTONE_URL}" >> version.env
          fi
        else
          echo "   âš ï¸  Milestone ${MILESTONE_TITLE} not found"
          echo "MILESTONE_READY=false" >> version.env
        fi
        
        # For release branches, always use base minor version for dev tags
        # Dev tags: v0.3.0-dev, v0.3.0-dev1, etc. (regardless of milestone status)
        LATEST_DEV_TAG=$(git tag -l "v${BASE_MINOR_VERSION}-dev*" 2>/dev/null | sort -V | tail -1)
        
        if [ -z "$LATEST_DEV_TAG" ]; then
          NEW_TAG="v${BASE_MINOR_VERSION}-dev"
          DEV_COUNT=0
        else
          DEV_COUNT=$(echo "$LATEST_DEV_TAG" | sed -n "s/^v${BASE_MINOR_VERSION}-dev\([0-9]*\)$/\1/p")
          if [ -z "$DEV_COUNT" ]; then
            DEV_COUNT=1
          else
            DEV_COUNT=$((DEV_COUNT + 1))
          fi
          NEW_TAG="v${BASE_MINOR_VERSION}-dev${DEV_COUNT}"
        fi
        
        # Check if tag already exists for this commit
        EXISTING_TAG=$(git tag --points-at "$CI_COMMIT_SHA" 2>/dev/null | grep "^v${BASE_MINOR_VERSION}-dev" || echo "")
        if [ -n "$EXISTING_TAG" ]; then
          echo "âœ… Tag already exists for this commit: ${EXISTING_TAG}"
          NEW_TAG="$EXISTING_TAG"
        else
          # Create and push dev tag
          echo "ðŸ·ï¸  Creating dev tag: ${NEW_TAG}"
          if git tag -a "$NEW_TAG" -m "Dev build for ${CI_COMMIT_BRANCH}" -m "Commit: ${CI_COMMIT_SHA}" "$CI_COMMIT_SHA" 2>/dev/null; then
            if git push origin "$NEW_TAG" 2>/dev/null; then
              echo "âœ… Created dev tag: ${NEW_TAG}"
            else
              echo "âš ï¸  Failed to push tag ${NEW_TAG}"
              git tag -d "$NEW_TAG" 2>/dev/null || true
            fi
          else
            echo "âš ï¸  Tag ${NEW_TAG} already exists or failed to create"
          fi
        fi
        
        echo "RELEASE_VERSION=${BASE_MINOR_VERSION}" >> version.env
        echo "VERSION_TAG=${NEW_TAG}" >> version.env
        echo "IS_RELEASE=false" >> version.env
        echo "IS_DEV_TAG=true" >> version.env
        
      elif [ "$CI_COMMIT_BRANCH" = "main" ]; then
        echo "ðŸš€ Main branch detected"
        
        # Detect base minor version from merge commit or latest release branch
        MERGE_BRANCH=$(git log -1 --pretty=%B | grep -oE "Merge branch 'release/v[0-9]+\.[0-9]+\.x'" | sed "s/Merge branch 'release\/v\([0-9]\+\.[0-9]\+\).x'/\1.0/" || echo "")
        
        if [ -n "$MERGE_BRANCH" ]; then
          BASE_MINOR_VERSION="$MERGE_BRANCH"
        else
          # Fallback: get latest release branch
          LATEST_RELEASE_BRANCH=$(git branch -r | grep 'origin/release/v' | sed 's|origin/release/v||' | sed 's|\.x||' | sort -V | tail -1)
          if [ -n "$LATEST_RELEASE_BRANCH" ]; then
            BASE_MINOR_VERSION="${LATEST_RELEASE_BRANCH}.0"
          else
            BASE_MINOR_VERSION="0.3.0"
            echo "âš ï¸  Could not detect version, using fallback: ${BASE_MINOR_VERSION}"
          fi
        fi
        
        echo "   Base minor version: ${BASE_MINOR_VERSION}"
        
        # Check milestone for this minor version
        MILESTONE_TITLE="v${BASE_MINOR_VERSION}"
        echo "ðŸ” Checking milestone: ${MILESTONE_TITLE}"
        
        MILESTONE_DATA=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --data-urlencode "title=${MILESTONE_TITLE}" \
          --data-urlencode "per_page=1" 2>/dev/null || echo "[]")
        
        MILESTONE_ID=$(echo "$MILESTONE_DATA" | jq -r '.[0].id // empty' 2>/dev/null || echo "")
        MILESTONE_STATE=$(echo "$MILESTONE_DATA" | jq -r '.[0].state // "active"' 2>/dev/null || echo "active")
        MILESTONE_URL=$(echo "$MILESTONE_DATA" | jq -r '.[0].web_url // ""' 2>/dev/null || echo "")
        
        if [ -n "$MILESTONE_ID" ]; then
          MILESTONE_STATS=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${MILESTONE_ID}" \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" 2>/dev/null || echo "{}")
          
          TOTAL_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.total_issues_count // 0' 2>/dev/null || echo "0")
          CLOSED_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.closed_issues_count // 0' 2>/dev/null || echo "0")
          OPEN_ISSUES=$((TOTAL_ISSUES - CLOSED_ISSUES))
          
          echo "   Milestone state: ${MILESTONE_STATE}"
          echo "   Total issues: ${TOTAL_ISSUES}"
          echo "   Closed issues: ${CLOSED_ISSUES}"
          echo "   Open issues: ${OPEN_ISSUES}"
          
          if [ "$MILESTONE_STATE" = "closed" ] && [ "$OPEN_ISSUES" -eq 0 ] && [ "$TOTAL_ISSUES" -gt 0 ]; then
            # Check if minor version already released
            if git tag -l "v${BASE_MINOR_VERSION}" 2>/dev/null | grep -q "^v${BASE_MINOR_VERSION}$"; then
              echo "   âš ï¸  Minor version ${BASE_MINOR_VERSION} already released - releasing PATCH version"
              # Milestone ready but minor already released, use patch
              LATEST_PATCH_TAG=$(git tag -l "v${BASE_MINOR_VERSION}.*" 2>/dev/null | grep -v "dev" | sort -V | tail -1)
              if [ -z "$LATEST_PATCH_TAG" ]; then
                FINAL_VERSION=$(echo "$BASE_MINOR_VERSION" | awk -F. '{print $1"."$2".1"}')
              else
                PATCH_NUM=$(echo "$LATEST_PATCH_TAG" | sed 's/^v//' | awk -F. '{print $3}')
                NEXT_PATCH=$((PATCH_NUM + 1))
                FINAL_VERSION=$(echo "$BASE_MINOR_VERSION" | awk -F. -v p="$NEXT_PATCH" '{print $1"."$2"."p}')
              fi
              echo "MILESTONE_READY=true" >> version.env
              echo "IS_MINOR_RELEASE=false" >> version.env
            else
              echo "   âœ… Milestone ready - releasing MINOR version: ${BASE_MINOR_VERSION}"
              FINAL_VERSION="${BASE_MINOR_VERSION}"
              echo "MILESTONE_READY=true" >> version.env
              echo "IS_MINOR_RELEASE=true" >> version.env
            fi
          else
            echo "   âš ï¸  Milestone not ready - releasing PATCH version"
            # Find latest patch version for this minor version (including the minor version itself if it exists)
            LATEST_PATCH_TAG=$(git tag -l "v${BASE_MINOR_VERSION}" "v${BASE_MINOR_VERSION}.*" 2>/dev/null | grep -v "dev" | sort -V | tail -1)
            
            if [ -z "$LATEST_PATCH_TAG" ]; then
              # No patch tags yet, start with .1
              FINAL_VERSION=$(echo "$BASE_MINOR_VERSION" | awk -F. '{print $1"."$2".1"}')
            else
              # Extract patch number and increment
              PATCH_NUM=$(echo "$LATEST_PATCH_TAG" | sed 's/^v//' | awk -F. '{print $3}')
              NEXT_PATCH=$((PATCH_NUM + 1))
              FINAL_VERSION=$(echo "$BASE_MINOR_VERSION" | awk -F. -v p="$NEXT_PATCH" '{print $1"."$2"."p}')
            fi
            echo "   Patch version: ${FINAL_VERSION}"
            echo "MILESTONE_READY=false" >> version.env
            echo "IS_MINOR_RELEASE=false" >> version.env
          fi
          
          echo "MILESTONE_TITLE=${MILESTONE_TITLE}" >> version.env
          echo "MILESTONE_ID=${MILESTONE_ID}" >> version.env
          echo "MILESTONE_URL=${MILESTONE_URL}" >> version.env
        else
          echo "   âš ï¸  Milestone ${MILESTONE_TITLE} not found - using patch version"
          # No milestone found, use patch version
          LATEST_PATCH_TAG=$(git tag -l "v${BASE_MINOR_VERSION}" "v${BASE_MINOR_VERSION}.*" 2>/dev/null | grep -v "dev" | sort -V | tail -1)
          if [ -z "$LATEST_PATCH_TAG" ]; then
            FINAL_VERSION=$(echo "$BASE_MINOR_VERSION" | awk -F. '{print $1"."$2".1"}')
          else
            PATCH_NUM=$(echo "$LATEST_PATCH_TAG" | sed 's/^v//' | awk -F. '{print $3}')
            NEXT_PATCH=$((PATCH_NUM + 1))
            FINAL_VERSION=$(echo "$BASE_MINOR_VERSION" | awk -F. -v p="$NEXT_PATCH" '{print $1"."$2"."p}')
          fi
          echo "MILESTONE_READY=false" >> version.env
          echo "IS_MINOR_RELEASE=false" >> version.env
        fi
        
        # Check if already tagged
        FINAL_TAG="v${FINAL_VERSION}"
        if git tag -l "$FINAL_TAG" 2>/dev/null | grep -q "^${FINAL_TAG}$"; then
          echo "âš ï¸  Version ${FINAL_VERSION} already tagged"
          echo "RELEASE_VERSION=${FINAL_VERSION}" >> version.env
          echo "VERSION_TAG=${FINAL_TAG}" >> version.env
        else
          echo "   Final version: ${FINAL_VERSION}"
          echo "   Will create release tag: ${FINAL_TAG}"
          echo "RELEASE_VERSION=${FINAL_VERSION}" >> version.env
          echo "VERSION_TAG=${FINAL_TAG}" >> version.env
        fi
        
        echo "IS_RELEASE=true" >> version.env
        echo "IS_DEV_TAG=false" >> version.env
        
      else
        echo "â„¹ï¸  Not a release or main branch - skipping version detection"
      fi
      
      echo ""
      echo "ðŸ“‹ Version Summary:"
      cat version.env
  artifacts:
    reports:
      dotenv: version.env
    paths:
      - version.env
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: always
  allow_failure: true

# ============================================================================
# STAGE 1 - SETUP & VALIDATE
# ============================================================================

validate:node:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - node --version
    - npm --version
    - echo "Node.js ${NODE_VERSION} ready"
  rules:
    - when: always

validate:ossa:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Validating example manifests..."
    - node dist/cli/index.js validate examples/getting-started/hello-world-complete.ossa.yaml || echo "âš ï¸  Validation warnings (non-blocking)"
  allow_failure: true
  rules:
    - when: always

# Check for divergent branches before merging to protected branches
check:divergence:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      if [ "$CI_MERGE_REQUEST_TARGET_BRANCH" = "main" ] || [[ "$CI_MERGE_REQUEST_TARGET_BRANCH" =~ ^release/ ]]; then
        echo "ðŸ” Checking for divergent branches..."
        git fetch origin
        
        BEHIND=$(git log --oneline origin/$CI_MERGE_REQUEST_SOURCE_BRANCH..origin/$CI_MERGE_REQUEST_TARGET_BRANCH 2>/dev/null | wc -l)
        AHEAD=$(git log --oneline origin/$CI_MERGE_REQUEST_TARGET_BRANCH..origin/$CI_MERGE_REQUEST_SOURCE_BRANCH 2>/dev/null | wc -l)
        
        if [ $BEHIND -gt 0 ] && [ $AHEAD -gt 0 ]; then
          echo "âŒ DIVERGENT BRANCHES DETECTED"
          echo "Target has $BEHIND commits not in source"
          echo "Source has $AHEAD commits not in target"
          echo "Use squash merge or force push recovery"
          exit 1
        fi
        
        if [ $BEHIND -gt 0 ]; then
          echo "âš ï¸  Source behind target by $BEHIND commits"
          exit 1
        fi
        
        echo "âœ… No divergence detected"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Check for .DS_Store files
check:ds-store:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      echo "ðŸ” Checking for .DS_Store files..."
      if git diff --name-only $CI_MERGE_REQUEST_DIFF_BASE_SHA 2>/dev/null | grep -q "\.DS_Store"; then
        echo "âŒ .DS_Store files in MR"
        exit 1
      fi
      echo "âœ… No .DS_Store files"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

validate:version-sync:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - echo "Checking version consistency..."
    - npm run version:check
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: always
    - changes:
      - package.json
      - README.md
      - spec/**/*
      when: always

# ============================================================================
# VERSION MANAGEMENT VIA GITLAB AGENTS (Dogfooding)
# ============================================================================
# TODO: Enable after component is published to main
# include:
#   - component: gitlab.com/blueflyio/openstandardagents/version-management/version-bump-agent@main

# version:bump:agent:
#   extends: .version-bump-agent
#   variables:
#     BUMP_TYPE: "patch"
#     TARGET_BRANCH: "release/0.3.0"
#   rules:
#     - if: '$BUMP_VERSION == "true"'
#       when: manual
#       allow_failure: false
    - if: '$CI_MERGE_REQUEST_TITLE =~ /^chore:.*version/i'
      when: manual
      allow_failure: false

# version:sync:agent:
#   extends: .version-sync-agent
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "push"'
#       when: always
#     - if: '$VERSION_SYNC == "true"'
#       when: manual

# version:consistency:check:
#   extends: .version-consistency-check

validate:scripts-version:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Validating npm scripts use dynamic version..."
      VERSION=$(node -p "require('./package.json').version")
      echo "Current version: ${VERSION}"
      
      # Verify exports["./schema"] matches current version
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"
      ACTUAL_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''")
      if [ "$ACTUAL_EXPORT" != "$EXPECTED_EXPORT" ] && [ -n "$ACTUAL_EXPORT" ]; then
        echo "âŒ ERROR: package.json exports[\"./schema\"] is \"${ACTUAL_EXPORT}\", should be \"${EXPECTED_EXPORT}\""
        exit 1
      fi

      # Check scripts don't have hardcoded version paths
      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "âœ… Scripts field does not contain hardcoded version paths"
      else
        echo "âŒ ERROR: package.json scripts contain hardcoded version paths"
        exit 1
      fi

      echo "âœ… All scripts use dynamic version detection"
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: always
    - changes:
      - package.json
      - scripts/**/*
      when: always

validate:docs-consistency:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Pre-Release Documentation Validation"
      echo "========================================"
      
      VERSION=$(node -p "require('./package.json').version")
      echo "Package version: v${VERSION}"

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo ""
        echo "âŒ ERROR: Documentation is out of sync!"
        echo ""
        echo "FIX REQUIRED:"
        echo " 1. Run locally: npx tsx scripts/sync-versions.ts --fix"
        echo " 2. Commit the changes"
        echo " 3. Push and re-run pipeline"
        exit 1
      fi

      echo "âœ… ALL DOCUMENTATION CONSISTENCY CHECKS PASSED"
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^release\//
      when: always

# ============================================================================
# STAGE 2 - BUILD
# ============================================================================

build:dist:
  stage: build
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - test -f dist/cli/index.js || (echo "âŒ ERROR dist/cli/index.js missing" && exit 1)
    - echo "âœ… Build completed"
  artifacts:
    paths:
      - dist/
      - package.json
      - package-lock.json
    expire_in: 1 hour
  rules:
    - when: always

# ============================================================================
# STAGE 3 - TEST
# ============================================================================

test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm run lint || echo "âš ï¸  Lint warnings"
    - npm run typecheck || echo "âš ï¸  Typecheck warnings"
  allow_failure: true
  rules:
    - when: always

test:code-quality:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npx eslint src/ -f json -o eslint-report.json || true
    - node scripts/eslint-to-codequality.cjs
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json
      - eslint-report.json
    expire_in: 7 days
  rules:
    - when: always

test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - npm run build
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: test-results/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
      - test-results/
    expire_in: 7 days
  allow_failure: false
  rules:
    - when: always

test:security:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm audit --production || echo "âš ï¸  Security vulnerabilities"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 4 - QUALITY GATES
# ============================================================================

quality:gates:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  script:
    - echo "âœ… Quality gates passed"
  rules:
    - when: always
  needs:
    - job: test:unit
      optional: true
    - job: test:lint
      optional: true
    - job: test:security
      optional: true

# ============================================================================
# STAGE 5 - DEPLOY (Removed - Website moved to openstandardagents.org)
# ============================================================================
# Website deployment is now handled by the openstandardagents.org repository.
# This repo (openstandardagents) is the spec/CLI npm package only.

# ============================================================================
# STAGE 6 - RELEASE (NPM - Milestone-Gated)
# ============================================================================

# GENERATE CHANGELOG from milestone issues
release:changelog:
  stage: release
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - npm install -g tsx
  script:
    - |
      #!/bin/bash
      set -e

      echo "ðŸ“ CHANGELOG GENERATION"
      echo "======================="

      if [ -z "$RELEASE_VERSION" ]; then
        echo "âš ï¸  No version detected - skipping changelog"
        exit 0
      fi

      echo "Version: v${RELEASE_VERSION}"
      echo ""

      # Generate changelog from git commits since last release
      LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
      RELEASE_VERSION=${RELEASE_VERSION} \
      CHANGELOG_OUTPUT="RELEASE_NOTES.md" \
      tsx .gitlab/release-automation/scripts/generate-changelog.ts || echo "Changelog generation skipped"

      # Also create version-specific changelog
      VERSION_CHANGELOG="spec/v${RELEASE_VERSION}/CHANGELOG.md"
      mkdir -p "spec/v${RELEASE_VERSION}"
      cp RELEASE_NOTES.md "$VERSION_CHANGELOG"

      echo ""
      echo "âœ… Changelog generated successfully"
      cat RELEASE_NOTES.md
  artifacts:
    paths:
      - RELEASE_NOTES.md
      - spec/v*/CHANGELOG.md
      - changelog.env
    reports:
      dotenv: changelog.env
    expire_in: 30 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  needs:
    - job: detect:version-and-tags
      optional: true
      artifacts: true
  allow_failure: false

# PRE-RELEASE VALIDATION - Critical checks before any release
release:validate:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git jq bash curl
    - npm ci --legacy-peer-deps
  script:
    - |
      #!/bin/bash
      set -e

      echo "ðŸ”’ PRE-RELEASE VALIDATION"
      echo "========================="
      echo ""

      ERRORS=0
      WARNINGS=0

      # 0. VERSION & MILESTONE VALIDATION
      echo "ðŸ“‹ 0. Version & Milestone Validation"
      if [ -z "$RELEASE_VERSION" ]; then
        echo "   âŒ ERROR: Could not detect version from branch"
        ERRORS=$((ERRORS + 1))
      else
        echo "   âœ… Version detected: v${RELEASE_VERSION}"
        
        # Check milestone status for minor releases
        if [ "$IS_MINOR_RELEASE" = "true" ]; then
          if [ "$MILESTONE_READY" = "true" ]; then
            echo "   âœ… Minor release: Milestone ${MILESTONE_TITLE} is closed and all issues completed"
          else
            echo "   âŒ ERROR: Cannot release minor version - milestone ${MILESTONE_TITLE} not ready"
            echo "      Milestone must be closed and all issues completed/merged"
            ERRORS=$((ERRORS + 1))
          fi
        else
          echo "   â„¹ï¸  Patch release: Milestone ${MILESTONE_TITLE:-not found} not ready, releasing patch version"
        fi
      fi
      echo ""

      # 1. VERSION CONSISTENCY CHECK
      echo "ðŸ“‹ 1. Version Consistency"
      VERSION=$(node -p "require('./package.json').version")
      echo "   Package version: v${VERSION}"

      # Check schema exists for this version
      SCHEMA_PATH="spec/v${VERSION}/ossa-${VERSION}.schema.json"
      if [ ! -f "$SCHEMA_PATH" ]; then
        echo "   âŒ ERROR: Schema not found: ${SCHEMA_PATH}"
        ERRORS=$((ERRORS + 1))
      else
        echo "   âœ… Schema exists: ${SCHEMA_PATH}"
      fi

      # Check README version badge matches
      if grep -q "v${VERSION}" README.md; then
        echo "   âœ… README version badge matches"
      else
        echo "   âš ï¸  WARNING: README may not reference v${VERSION}"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 2. SCHEMA VALIDATION
      echo ""
      echo "ðŸ“‹ 2. Schema Validation"

      # Check schema is valid JSON
      if jq empty "$SCHEMA_PATH" 2>/dev/null; then
        echo "   âœ… Schema is valid JSON"
      else
        echo "   âŒ ERROR: Schema is not valid JSON"
        ERRORS=$((ERRORS + 1))
      fi

      # Check schema has required fields
      SCHEMA_VERSION=$(jq -r '.properties.apiVersion.const // .properties.apiVersion.enum[0] // ""' "$SCHEMA_PATH" 2>/dev/null || echo "")
      if [ -n "$SCHEMA_VERSION" ]; then
        echo "   âœ… Schema apiVersion: ${SCHEMA_VERSION}"
      else
        echo "   âš ï¸  WARNING: Could not detect apiVersion in schema"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 3. EXAMPLES VALIDATION
      echo ""
      echo "ðŸ“‹ 3. Examples Validation"

      EXAMPLE_ERRORS=0
      for example in examples/**/*.ossa.yaml examples/**/*.ossa.json; do
        [ ! -f "$example" ] && continue

        # Check apiVersion matches
        if grep -q "apiVersion.*ossa/v${VERSION}" "$example" 2>/dev/null || \
           jq -e ".apiVersion == \"ossa/v${VERSION}\"" "$example" 2>/dev/null; then
          echo "   âœ… ${example}"
        else
          EXAMPLE_API=$(grep -oE "apiVersion.*ossa/v[0-9.]+" "$example" 2>/dev/null | head -1 || \
                        jq -r '.apiVersion // "unknown"' "$example" 2>/dev/null || echo "unknown")
          echo "   âŒ ERROR: ${example} has ${EXAMPLE_API}, expected ossa/v${VERSION}"
          EXAMPLE_ERRORS=$((EXAMPLE_ERRORS + 1))
        fi
      done

      if [ $EXAMPLE_ERRORS -gt 0 ]; then
        echo "   âŒ ${EXAMPLE_ERRORS} examples have wrong apiVersion"
        ERRORS=$((ERRORS + EXAMPLE_ERRORS))
      fi

      # 4. BUILD ARTIFACTS CHECK
      echo ""
      echo "ðŸ“‹ 4. Build Artifacts"

      if [ -f "dist/cli/index.js" ]; then
        echo "   âœ… CLI built: dist/cli/index.js"
      else
        echo "   âŒ ERROR: CLI not built"
        ERRORS=$((ERRORS + 1))
      fi

      if [ -d "dist/lib" ]; then
        echo "   âœ… Library built: dist/lib/"
      else
        echo "   âš ï¸  WARNING: dist/lib/ not found"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 5. PACKAGE.JSON EXPORTS CHECK
      echo ""
      echo "ðŸ“‹ 5. Package Exports"

      SCHEMA_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''" 2>/dev/null || echo "")
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"

      if [ "$SCHEMA_EXPORT" = "$EXPECTED_EXPORT" ]; then
        echo "   âœ… Schema export correct: ${SCHEMA_EXPORT}"
      elif [ -z "$SCHEMA_EXPORT" ]; then
        echo "   âš ï¸  WARNING: No ./schema export defined"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "   âŒ ERROR: Schema export mismatch"
        echo "      Expected: ${EXPECTED_EXPORT}"
        echo "      Got: ${SCHEMA_EXPORT}"
        ERRORS=$((ERRORS + 1))
      fi

      # 6. TEST RUN
      echo ""
      echo "ðŸ“‹ 6. Test Suite"

      if npm run test 2>&1; then
        echo "   âœ… All tests passed"
      else
        echo "   âŒ ERROR: Tests failed"
        ERRORS=$((ERRORS + 1))
      fi

      # 7. TYPECHECK
      echo ""
      echo "ðŸ“‹ 7. TypeScript Validation"

      if npm run typecheck 2>&1; then
        echo "   âœ… TypeScript compilation clean"
      else
        echo "   âŒ ERROR: TypeScript errors"
        ERRORS=$((ERRORS + 1))
      fi

      # 8. NO HARDCODED VERSIONS IN SCRIPTS
      echo ""
      echo "ðŸ“‹ 8. Script Version Check"

      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "   âœ… No hardcoded versions in scripts"
      else
        echo "   âŒ ERROR: Hardcoded versions found in package.json scripts"
        ERRORS=$((ERRORS + 1))
      fi

      # SUMMARY
      echo ""
      echo "========================================"
      echo "ðŸ“Š VALIDATION SUMMARY"
      echo "========================================"
      echo "   Errors: ${ERRORS}"
      echo "   Warnings: ${WARNINGS}"
      echo ""

      if [ $ERRORS -gt 0 ]; then
        echo "âŒ RELEASE BLOCKED: ${ERRORS} error(s) must be fixed"
        echo ""
        echo "Fix the errors above before releasing."
        exit 1
      fi

      if [ $WARNINGS -gt 0 ]; then
        echo "âš ï¸  RELEASE APPROVED WITH WARNINGS: ${WARNINGS} warning(s)"
      else
        echo "âœ… RELEASE APPROVED: All checks passed"
      fi
  artifacts:
    reports:
      dotenv: validation-report.env
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  needs:
    - build:dist
    - test:unit
    - job: detect:version-and-tags
      optional: true
      artifacts: true

release:preview:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Release Preview (Dry-Run)"
      echo "============================"
      
      if [ "$ENABLE_RELEASE" = "true" ]; then
        echo "âœ… ENABLE_RELEASE: ${ENABLE_RELEASE} (releases enabled)"
      else
        echo "âš ï¸  ENABLE_RELEASE: ${ENABLE_RELEASE:-not set} (releases disabled)"
      fi
      
      if [ -n "$RELEASE_VERSION" ]; then
        echo "ðŸ“¦ Detected version:"
        echo "   Version: v${RELEASE_VERSION}"
        echo "   Branch: ${CI_COMMIT_BRANCH}"
      fi

      CURRENT_VERSION=$(node -p "require('./package.json').version")
      echo "ðŸ“„ Current package.json: v${CURRENT_VERSION}"
      
      if [ "$ENABLE_RELEASE" = "true" ] && [ -n "$RELEASE_VERSION" ]; then
        echo "âœ… Release will proceed automatically"
      else
        echo "âš ï¸  Release blocked (ENABLE_RELEASE=${ENABLE_RELEASE:-not set}, VERSION=${RELEASE_VERSION:-not detected})"
      fi
      
      npx semantic-release --dry-run || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  allow_failure: true
  needs:
    - build:dist
    - job: detect:version-and-tags
      optional: true
      artifacts: true

release:npm:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
    - detect:version-and-tags
    - release:changelog
  before_script:
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI Release"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
    - git checkout -B main origin/main
  script:
    - |
      #!/bin/bash
      set -e

      echo "ðŸš€ MILESTONE-GATED RELEASE"
      echo "=========================="

      # Check ENABLE_RELEASE gate
      if [ "$ENABLE_RELEASE" != "true" ]; then
        echo "ðŸš« RELEASE BLOCKED: ENABLE_RELEASE not set"
        echo ""
        echo "To enable releases:"
        echo " Settings â†’ CI/CD â†’ Variables â†’ Add variable"
        echo " Variable: ENABLE_RELEASE"
        echo " Value: true"
        exit 0
      fi

      # Check version detection
      if [ -z "$RELEASE_VERSION" ]; then
        echo "ðŸš« RELEASE BLOCKED: Could not detect version from branch"
        exit 0
      fi

      # Validate milestone for minor releases
      if [ "$IS_MINOR_RELEASE" = "true" ] && [ "$MILESTONE_READY" != "true" ]; then
        echo "ðŸš« RELEASE BLOCKED: Minor release requires milestone to be closed and all issues completed"
        echo ""
        echo "Milestone: ${MILESTONE_TITLE}"
        echo "State: ${MILESTONE_STATE:-unknown}"
        echo "Open issues: ${OPEN_ISSUES:-unknown}"
        echo ""
        echo "Close the milestone and complete all issues to release minor version ${RELEASE_VERSION}"
        echo "Or merge to main will create patch version instead"
        exit 0
      fi

      echo "âœ… Release gate passed"
      echo "   ENABLE_RELEASE: ${ENABLE_RELEASE}"
      echo "   Version: v${RELEASE_VERSION}"
      echo "   Release type: $([ "$IS_MINOR_RELEASE" = "true" ] && echo "MINOR" || echo "PATCH")"
      echo "   Milestone: ${MILESTONE_TITLE:-N/A}"
      echo "   Branch: ${CI_COMMIT_BRANCH}"

      # Update package.json
      npm version ${RELEASE_VERSION} --no-git-tag-version --allow-same-version

      # Sync documentation
      echo "ðŸ“ Syncing documentation..."
      npx tsx scripts/sync-versions.ts --fix

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo "âŒ ERROR: Documentation sync failed"
        exit 1
      fi

      # Configure npm
      GITLAB_HOST="${CI_SERVER_HOST}"
      if [ -n "$NPM_TOKEN" ]; then
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      //registry.npmjs.org/:_authToken=${NPM_TOKEN}
      EOF
      else
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      EOF
      fi

      # Final tests
      echo "ðŸ§ª Running final tests..."
      npm run test || (echo "âŒ Tests failed" && exit 1)

      # Publish to npm
      echo "ðŸ“¦ Publishing v${RELEASE_VERSION} to npm..."
      if ! npm publish --access public; then
        echo "âŒ npm publish failed"
        exit 1
      fi

      # Create git tag with comprehensive release information
      PROD_TAG="v${RELEASE_VERSION}"
      RELEASE_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

      # Load changelog content if available
      CHANGELOG_CONTENT=""
      if [ -f "RELEASE_NOTES.md" ]; then
        CHANGELOG_CONTENT=$(cat RELEASE_NOTES.md)
      fi

      # Build comprehensive tag message using heredoc
      read -r -d '' TAG_MESSAGE << EOF || true
      Release v${RELEASE_VERSION}

      Pipeline: ${CI_PIPELINE_ID}
      Released: ${RELEASE_DATE}
      Commit: ${CI_COMMIT_SHA}

      See full changelog: https://gitlab.com/${CI_PROJECT_PATH}/-/blob/main/spec/v${RELEASE_VERSION}/CHANGELOG.md

      Links:
      - npm Package: https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}
      - Documentation: https://openstandardagents.org/
      EOF

      git tag -a "$PROD_TAG" -m "$TAG_MESSAGE" "$CI_COMMIT_SHA"

      # Commit and push
      git add package.json package-lock.json README.md spec/ RELEASE_NOTES.md || true
      git commit -m "chore(release): v${RELEASE_VERSION} [skip ci]" || echo "No changes to commit"
      git push origin main --tags

      # Create GitLab Release with auto-generated changelog
      echo "ðŸ“‹ Creating GitLab Release with milestone integration..."

      # Prepare changelog for release description
      RELEASE_DESCRIPTION="${CHANGELOG_CONTENT}"

      # If no changelog, use fallback
      if [ -z "$RELEASE_DESCRIPTION" ]; then
        RELEASE_DESCRIPTION="## Release v${RELEASE_VERSION}\n\nSee CHANGELOG.md for details."
      fi

      # Create release
      RELEASE_PAYLOAD=$(jq -n \
        --arg name "Release v${RELEASE_VERSION}" \
        --arg tag "v${RELEASE_VERSION}" \
        --arg desc "$RELEASE_DESCRIPTION" \
        --arg npm_url "https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}" \
        --arg schema_url "https://openstandardagents.org/schema/" \
        --arg docs_url "https://openstandardagents.org/" \
        '{
          name: $name,
          tag_name: $tag,
          description: $desc,
          assets: {
            links: [
              {
                name: "npm package",
                url: $npm_url,
                link_type: "package"
              },
              {
                name: "JSON Schema",
                url: $schema_url,
                link_type: "other"
              },
              {
                name: "Documentation",
                url: $docs_url,
                link_type: "other"
              }
            ]
          }
        }')

      curl --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "$RELEASE_PAYLOAD" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases"

      echo "âœ… GitLab Release created: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"

      echo ""
      echo "âœ… Release v${RELEASE_VERSION} completed!"
      echo ""
      echo "ðŸ“Š Release Summary:"
      echo "   Version: v${RELEASE_VERSION}"
      echo "   npm: https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}"
      echo "   Release: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true" && $RELEASE_VERSION
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual
  needs:
    - quality:gates
    - build:dist
    - release:preview
    - release:validate
    - release:changelog
    - validate:docs-consistency
    - detect:version-and-tags

# ============================================================================
# STAGE 7 - MIRROR
# ============================================================================

mirror:github:
  stage: mirror
  image: alpine:latest
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
  script:
    - |
      # Use GH_TOKEN (group variable) or GITHUB_MIRROR_TOKEN (legacy)
      MIRROR_TOKEN="${GH_TOKEN:-$GITHUB_MIRROR_TOKEN}"

      if [ -z "$MIRROR_TOKEN" ]; then
        echo "â„¹ï¸  No GitHub token set (GH_TOKEN or GITHUB_MIRROR_TOKEN) - skipping"
        exit 0
      fi

      echo "ðŸ”„ Syncing to GitHub..."
      git remote add github https://${MIRROR_TOKEN}@github.com/blueflyio/openstandardagents.git || true
      git push github --all --force || true
      git push github --tags --force || true
      echo "âœ… GitHub mirror synced"
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true

# ============================================================================
# POST-RELEASE CLEANUP
# ============================================================================
# After successful release:
# 1. Tag all issues with released::v{VERSION}
# 2. Tag all MRs with released::v{VERSION}
# 3. Create next milestone (patch increment)

post-release:cleanup:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      #!/bin/bash
      set -e

      echo "ðŸ§¹ POST-RELEASE CLEANUP"
      echo "======================="

      # Check if release just happened
      if [ -z "$RELEASE_VERSION" ]; then
        echo "â„¹ï¸  No release detected - skipping cleanup"
        exit 0
      fi

      VERSION="${RELEASE_VERSION}"
      LABEL_NAME="released::v${VERSION}"

      echo "ðŸ“Œ Version: v${VERSION}"
      echo ""

      # 1. Create release label if not exists
      echo "Creating label: ${LABEL_NAME}"
      curl --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data "name=${LABEL_NAME}&color=#00FF00&description=Released in v${VERSION}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/labels" 2>/dev/null || echo "Label may already exist"

      # 2. Tag MRs merged in this release (from commit messages)
      echo ""
      echo "ðŸ“Œ Tagging merge requests from release commits..."
      git log --format=%B --grep="Merge branch" | grep -oE "Merge branch '[^']+'" | sed "s/Merge branch '//" | sed "s/'//" | while read BRANCH; do
        MR_IID=$(curl -sS -G \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests" \
          --data-urlencode "source_branch=${BRANCH}" \
          --data-urlencode "state=merged" \
          --data-urlencode "per_page=1" | jq -r '.[0].iid // empty')
        
        if [ -n "$MR_IID" ]; then
          curl -sS --request PUT \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
            --data "add_labels=${LABEL_NAME}" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${MR_IID}" > /dev/null
          echo "  âœ“ Tagged MR !${MR_IID}"
        fi
      done

      echo ""
      echo "âœ… POST-RELEASE CLEANUP COMPLETE"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true" && $RELEASE_VERSION
      when: on_success
  needs:
    - job: release:npm
      artifacts: true
    - job: detect:version-and-tags
      artifacts: true
  allow_failure: true

# ============================================================================
# WORKFLOW - MERGE TRAINS ENABLED
# ============================================================================
# Merge trains prevent branch divergence by:
# 1. Queuing MRs instead of racing to merge
# 2. Testing merged state before allowing merge
# 3. Auto-rebasing when target branch updates
# 4. Failing fast on conflicts
#
# Enabled for: release/*, main branches
# Eliminates: Manual sync commits between releases
# See: https://docs.gitlab.com/ee/ci/pipelines/merge_trains.html
# ============================================================================

workflow:
  rules:
    # Merge train pipelines (combined state testing)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merge_train"
    # Merged result pipelines (pre-merge validation)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"
    # Regular MR pipelines
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # Prevent duplicate pipelines (skip branch pipeline if MR is open)
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    # Tag pipelines
    - if: $CI_COMMIT_TAG
    # Regular branch pipelines (main and release/*)
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH =~ /^release\//
    # Always allow other pipeline sources (API, web, scheduled, etc.)
    - when: always

# ============================================================================
# RELEASE AUTOMATION - Enterprise Grade
# ============================================================================

# Legacy dev tag increment (replaced by auto-tag:on-merge)
# Kept for backwards compatibility - can be removed after verification
increment-dev-tag:
  stage: .post
  image: node:${NODE_VERSION}
  before_script:
    - apk add --no-cache git bash
    # Configure git authentication
    - git config --global credential.helper store
    - echo "https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}" > ~/.git-credentials
    - npm ci
    - npm install -g tsx
  script:
    - echo "â„¹ï¸  This job is replaced by auto-tag:on-merge"
    - echo "   Keeping for backwards compatibility"
    # - tsx .gitlab/release-automation/scripts/increment-dev-tag.ts
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\// && $CI_PIPELINE_SOURCE == "push"
      when: manual
  allow_failure: true

# Manual release buttons (main branch only)
release-to-npm:
  stage: release
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=npm tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production

release-to-github:
  stage: release
  image: node:${NODE_VERSION}
  needs: [release-to-npm]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=github tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: github
    url: https://github.com/blueflyio/openstandardagents
    deployment_tier: production

# Website deployment moved to openstandardagents.org repository
# See: https://gitlab.com/blueflyio/openstandardagents.org

announce-release:
  stage: .post
  image: node:${NODE_VERSION}
  needs: [release-to-github]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=announce tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
# ============================================================================
# AUTOMATED RELEASE MR CREATION
# ============================================================================

create-release-mrs:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      echo "ðŸš€ Checking for milestones needing release MRs..."
      
      MILESTONES=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/milestones?state=active")
      
      echo "$MILESTONES" | jq -r '.[] | select(.title | startswith("v")) | .id + " " + .title' | while read MILESTONE_ID MILESTONE_TITLE; do
        # Extract version from milestone title (e.g., "v0.3.0" -> "release/0.3.0")
        RELEASE_BRANCH="release/$(echo "$MILESTONE_TITLE" | sed 's/^v//')"
        
        EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened&source_branch=$RELEASE_BRANCH&target_branch=main&milestone=$MILESTONE_TITLE" \
          | jq -r '.[0].iid // empty')
        
        if [ -z "$EXISTING_MR" ]; then
          curl --request POST \
            --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
            --header "Content-Type: application/json" \
            --data "{
              \"source_branch\": \"$RELEASE_BRANCH\",
              \"target_branch\": \"main\",
              \"title\": \"Draft: ðŸš€ Release $MILESTONE_TITLE\",
              \"description\": \"## Release $MILESTONE_TITLE\\n\\nDraft MR for next release. Features merge to $RELEASE_BRANCH based on milestone/issue/MR.\\n\\n### When Ready\\n1. Mark as ready\\n2. Add to merge train\\n3. Train merges to main\\n4. Release automation runs\",
              \"milestone_id\": $MILESTONE_ID,
              \"draft\": true,
              \"labels\": \"type::release,status::draft\"
            }" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests"
        fi
      done
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: manual

# Generate llms.txt context files
generate:llms-txt:
  stage: build
  image: python:3.11-slim
  script:
    - pip install llms-txt
    - llms_txt2ctx llms.txt > llms-ctx.txt
    - llms_txt2ctx llms.txt --optional True > llms-ctx-full.txt
  artifacts:
    paths:
      - llms.txt
      - llms-ctx.txt
      - llms-ctx-full.txt
    expire_in: never
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_COMMIT_BRANCH =~ /^release\//
      when: on_success

# ============================================================================
# POST-RELEASE SYNC - Removed (no development branch)
# ============================================================================
# Release branches merge directly to main, no sync needed
