# GitLab CI/CD Pipeline for OSSA
# Implements semantic release workflow: development (dev) â†’ main (RC) â†’ production (manual)

stages:
  - setup
  - validate
  - build
  - test
  - promote
  - release-dev
  - release-rc
  - release-prod
  - mirror-github

variables:
  NODE_VERSION: "20"
  NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  HUSKY: "0"
  LEFTHOOK: "0"

# ============================================================================
# STAGE 1: VALIDATE
# ============================================================================

validate:node:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - node --version
    - npm --version
    - echo "Node.js ${NODE_VERSION} ready"
  rules:
    - when: always

validate:ossa:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Validating example manifests..."
    - node dist/cli/index.js validate examples/getting-started/hello-world-complete.ossa.yaml || echo "WARNING Validation warnings (non-blocking)"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 2: TEST
# ============================================================================

test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm run lint || echo "WARNING Lint warnings detected (non-blocking)"
    - npm run typecheck || echo "WARNING Typecheck warnings detected (non-blocking)"
  allow_failure: true
  rules:
    - when: always

test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - npm run build
    - test -f dist/cli/index.js || (echo "ERROR dist/cli/index.js missing after build" && exit 1)
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 7 days
  allow_failure: true
  rules:
    - when: always

test:security:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm audit --production || echo "WARNING Security vulnerabilities detected (review required)"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 3: BUILD
# ============================================================================

build:dist:
  stage: build
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Build completed successfully"
  artifacts:
    paths:
      - dist/
      - spec/
      - bin/
      - package.json
      - package-lock.json
      - README.md
      - LICENSE
      - CHANGELOG.md
    expire_in: 1 day
  rules:
    - when: always

# ============================================================================
# STAGE 4: RELEASE DEV (development branch only)
# Auto-publishes semantic pre-release: 0.2.3-dev.1, 0.2.3-dev.2, etc.
# ============================================================================

release:dev:
  stage: release-dev
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Publishing development pre-release..."

      # Configure git
      git config --global user.email "ci@gitlab.bluefly.io"
      git config --global user.name "GitLab CI"

      # Get current version and increment dev
      CURRENT_VERSION=$(node -p "require('./package.json').version")
      DEV_VERSION="${CURRENT_VERSION}-dev.${CI_PIPELINE_IID}"

      echo "Version: ${DEV_VERSION}"

      # Update package.json version
      npm version ${DEV_VERSION} --no-git-tag-version

      # Configure npm to use GitLab Package Registry
      echo "@bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/" > .npmrc
      echo "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> .npmrc

      # Publish to GitLab Package Registry
      echo "Publishing to GitLab Package Registry..."
      npm publish --tag dev

      echo "Development release ${DEV_VERSION} published"
  only:
    - development
  except:
    - tags

# ============================================================================
# STAGE 5: RELEASE RC (main branch only)
# Auto-publishes release candidate: 0.2.3-rc.1, 0.2.3-rc.2, etc.
# ============================================================================

release:rc:
  stage: release-rc
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Using semantic-release for version management..."

      # Configure git
      git config --global user.email "ci@gitlab.bluefly.io"
      git config --global user.name "GitLab CI"

      # Configure npm for GitLab Package Registry
      echo "@bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/" > .npmrc
      echo "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> .npmrc

      # Run semantic-release (dry-run on main to preview next version)
      echo "Next version will be determined by conventional commits..."
      npx semantic-release --dry-run || true

      echo "Release candidates are managed via semantic-release in GitHub Actions"
      echo "See: https://github.com/BlueflyCollective/openstandardagents/actions"
  only:
    - main
  except:
    - tags
  allow_failure: true

# ============================================================================
# STAGE 6: RELEASE PROD (main branch - MANUAL TRIGGER)
# Publishes stable production release: 0.2.3
# Publishes to both GitLab Package Registry AND npmjs.org
# Creates git tag
# ============================================================================

release:prod:
  stage: release-prod
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Production releases managed via semantic-release in GitHub Actions"
      echo ""
      echo "To create a production release:"
      echo "1. Merge to main with conventional commit messages"
      echo "2. GitHub Actions will automatically:"
      echo "   - Determine version based on commits (feat=minor, fix=patch, BREAKING=major)"
      echo "   - Update CHANGELOG.md"
      echo "   - Create GitHub release"
      echo "   - Publish to npm"
      echo "   - Deploy website to GitHub Pages"
      echo ""
      echo "See: https://github.com/BlueflyCollective/openstandardagents/actions"

      # Configure npm to use GitLab Package Registry
      echo "@bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/" > .npmrc
      echo "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> .npmrc

      # Publish to GitLab Package Registry
      echo "Publishing to GitLab Package Registry..."
      npm publish --tag latest

      # Publish to npmjs.org (if NPM_TOKEN is configured)
      if [ -n "$NPM_TOKEN" ]; then
        echo "Publishing to npmjs.org..."
        echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc
        npm publish --registry=https://registry.npmjs.org/ --tag latest
        echo "Published to npmjs.org"
      else
        echo "WARNING: NPM_TOKEN not set - skipping npmjs.org publish"
        echo "To publish to npm, add NPM_TOKEN to GitLab CI/CD variables"
      fi

      echo "Production release v${CURRENT_VERSION} completed"
      echo "GitLab Package: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages"
      echo "npm Package: https://www.npmjs.com/package/@bluefly/open-standards-scalable-agents"
  only:
    - main
  except:
    - tags
  when: manual
  allow_failure: false

# ============================================================================
# STAGE: PROMOTE (development -> main)
# Fast-forwards development to main, or creates MR if conflicts
# ============================================================================

promote-to-main:
  stage: promote
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache git curl
    - git config --global user.email "thomas.scola@bluefly.io"
    - git config --global user.name "Thomas Scola, Founder & CEO of Bluefly.io"
    - git remote set-url origin https://oauth2:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      set -e
      echo "Attempting fast-forward merge of development -> main..."
      git fetch --all --prune --unshallow || true
      git checkout -B main origin/main
      # Try fast-forward only
      if git merge --ff-only origin/development; then
        git push origin main
        echo "Fast-forward merge completed"
      else
        echo "WARNING: Fast-forward not possible. Creating Merge Request instead."
        # Create MR via GitLab API using job token
        MR_TITLE="chore: merge development to main"
        MR_DESC="Automated MR created by CI promote-to-main job when fast-forward was not possible. Please resolve conflicts and merge."
        # First, check if an open MR already exists
        EXISTING_MR_RESPONSE=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests" \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --data-urlencode "source_branch=development" \
          --data-urlencode "target_branch=main" \
          --data-urlencode "state=opened")
        EXISTING_MR_URL=$(echo "$EXISTING_MR_RESPONSE" | node -e "process.stdin.on('data',d=>{try{const j=JSON.parse(d);if(Array.isArray(j)&&j.length){console.log(j[0].web_url||'');}else{console.log('');}}catch(e){}})")
        if [ -n "$EXISTING_MR_URL" ]; then
          echo "Existing Merge Request found: $EXISTING_MR_URL"
          exit 0
        fi

        # Create a new MR via GitLab API using CI job token as PRIVATE-TOKEN
        CREATE_MR_RESPONSE=$(curl -sS -X POST "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests" \
          --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
          --data-urlencode "source_branch=development" \
          --data-urlencode "target_branch=main" \
          --data-urlencode "title=${MR_TITLE}" \
          --data-urlencode "remove_source_branch=false" \
          --data-urlencode "squash=false" \
          --data-urlencode "description=${MR_DESC}" \
          --data-urlencode "allow_collaboration=true")
        echo "MR create response: ${CREATE_MR_RESPONSE}"
        MR_WEB_URL=$(echo "$CREATE_MR_RESPONSE" | node -e "process.stdin.on('data',d=>{try{const j=JSON.parse(d);console.log(j.web_url||'');}catch(e){}})")
        if [ -n "$MR_WEB_URL" ]; then
          echo "Merge Request created: $MR_WEB_URL"
          # Succeed the job; manual review will handle conflicts
          exit 0
        else
          echo "ERROR: Failed to create Merge Request (unauthorized or permissions). Please create MR from development -> main manually."
          exit 1
        fi
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "development"
      when: manual
      allow_failure: false
  environment:
    name: production
    action: start
  needs:
    - build:dist

# ============================================================================
# MANUAL: RELEASE TO ALL PLATFORMS
# Comprehensive release button that publishes an existing git tag to all platforms:
# 1. Publishes to npmjs.org
# 2. Publishes to GitLab Package Registry
# 3. Creates GitLab Release
# 4. Syncs to GitHub (automatic via mirror)
#
# WORKFLOW - Run these commands locally first:
#   npm version patch              # 0.2.3 â†’ 0.2.4 (creates tag locally)
#   git push --follow-tags         # Pushes commit + tag
#   Then click this button in GitLab CI
#
# NOTE: Currently releasing PATCH versions only (0.2.3 â†’ 0.2.4 â†’ 0.2.5)
#       For minor/major releases, coordinate first.
# ============================================================================

release-all-platforms:
  stage: release-prod
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git curl jq
    - git config --global user.email "ci@gitlab.bluefly.io"
    - git config --global user.name "GitLab CI"
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸš€ RELEASE TO ALL PLATFORMS"
      echo "============================="
      echo ""

      # Get current version from package.json
      CURRENT_VERSION=$(node -p "require('./package.json').version")
      TAG_NAME="v${CURRENT_VERSION}"

      echo "ðŸ“¦ Version: ${CURRENT_VERSION}"
      echo "ðŸ·ï¸  Tag: ${TAG_NAME}"
      echo ""

      # Verify tag exists (should be created locally with `npm version patch && git push --follow-tags`)
      git fetch --tags
      if ! git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
        echo "âŒ ERROR: Tag $TAG_NAME does not exist!"
        echo ""
        echo "Please create the tag locally first:"
        echo "  npm version patch              # Creates tag locally"
        echo "  git push --follow-tags         # Pushes commit + tag"
        echo ""
        echo "Then run this job again."
        exit 1
      fi

      echo "âœ… Tag $TAG_NAME exists"
      echo ""

      # Step 1: Publish to GitLab Package Registry
      echo "ðŸ“¦ Step 1/4: Publishing to GitLab Package Registry..."
      echo "@bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/" > .npmrc
      echo "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> .npmrc
      npm publish --tag latest
      echo "âœ… Published to GitLab Package Registry"
      echo ""

      # Step 2: Publish to npmjs.org
      echo "ðŸ“¦ Step 2/4: Publishing to npmjs.org..."
      if [ -n "$NPM_TOKEN" ]; then
        echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > .npmrc
        npm publish --registry=https://registry.npmjs.org/ --tag latest
        echo "âœ… Published to npmjs.org"
        echo "   View at: https://www.npmjs.com/package/@bluefly/open-standards-scalable-agents"
      else
        echo "âš ï¸  NPM_TOKEN not set - skipping npmjs.org publish"
        echo "   To enable, add NPM_TOKEN to GitLab CI/CD variables"
      fi
      echo ""

      # Step 3: Create GitLab Release
      echo "ðŸ“‹ Step 3/4: Creating GitLab Release..."
      CHANGELOG_EXCERPT=$(cat CHANGELOG.md | head -100 || echo "See CHANGELOG.md for full details")

      RELEASE_RESPONSE=$(curl -sS -X POST "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases" \
        --header "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        --data "tag_name=${TAG_NAME}" \
        --data "name=Release ${TAG_NAME}" \
        --data-urlencode "description=## Release v${CURRENT_VERSION}

      ${CHANGELOG_EXCERPT}

      ### Links
      - [npm Package](https://www.npmjs.com/package/@bluefly/open-standards-scalable-agents)
      - [GitHub Mirror](https://github.com/BlueflyCollective/OSSA)
      - [Documentation](https://ossa.ai)
      ")

      if echo "$RELEASE_RESPONSE" | jq -e '.tag_name' > /dev/null 2>&1; then
        echo "âœ… GitLab Release created"
        echo "   View at: ${CI_PROJECT_URL}/-/releases/${TAG_NAME}"
      else
        echo "âš ï¸  GitLab Release creation failed (may already exist)"
      fi
      echo ""

      # Step 4: GitHub Mirror Sync (Automatic)
      echo "ðŸ”„ Step 4/4: GitHub Mirror Sync..."
      echo "âœ… GitLab â†’ GitHub mirror configured"
      echo "   Tag will sync automatically to GitHub"
      echo "   View at: https://github.com/BlueflyCollective/OSSA/releases/tag/${TAG_NAME}"
      echo ""

      # Summary
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo "ðŸŽ‰ RELEASE COMPLETE: v${CURRENT_VERSION}"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo ""
      echo "âœ… Git Tag: ${TAG_NAME}"
      echo "âœ… GitLab Package Registry"
      if [ -n "$NPM_TOKEN" ]; then
        echo "âœ… npmjs.org: https://www.npmjs.com/package/@bluefly/open-standards-scalable-agents"
      fi
      echo "âœ… GitLab Release: ${CI_PROJECT_URL}/-/releases/${TAG_NAME}"
      echo "âœ… GitHub Mirror: https://github.com/BlueflyCollective/OSSA/releases/tag/${TAG_NAME}"
      echo ""
      echo "ðŸ“š Next steps:"
      echo "   - Update documentation if needed"
      echo "   - Announce release on social media"
      echo "   - Monitor npm downloads and issues"
  only:
    - main
  when: manual
  allow_failure: false
  environment:
    name: production
    url: https://www.npmjs.com/package/@bluefly/open-standards-scalable-agents

# ============================================================================
# MANUAL: CREATE RELEASE TAG (Legacy - use release-all-platforms instead)
# Creates a new version tag (v0.2.4, v0.3.0, etc)
# ============================================================================

create-release-tag:
  stage: release-prod
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci@gitlab.bluefly.io"
    - git config --global user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      echo "ðŸ·ï¸  Creating Release Tag"
      echo "======================="

      # Get current version from package.json
      CURRENT_VERSION=$(node -p "require('./package.json').version")
      TAG_NAME="v${CURRENT_VERSION}"

      echo "Current version: ${CURRENT_VERSION}"
      echo "Tag to create: ${TAG_NAME}"

      # Check if tag already exists
      if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
        echo "âŒ ERROR: Tag $TAG_NAME already exists!"
        echo "Please bump the version in package.json first:"
        echo "  npm version patch  # 0.2.3 â†’ 0.2.4"
        echo "  npm version minor  # 0.2.3 â†’ 0.3.0"
        echo "  npm version major  # 0.2.3 â†’ 1.0.0"
        exit 1
      fi

      # Create annotated tag
      git tag -a "$TAG_NAME" -m "Release $TAG_NAME

      ## Changes in this release

      See CHANGELOG.md for full details.

      GitLab Release: ${CI_PROJECT_URL}/-/releases/${TAG_NAME}
      Package Registry: ${CI_PROJECT_URL}/-/packages
      "

      # Push tag to GitLab
      git push origin "$TAG_NAME"

      echo "âœ… Tag ${TAG_NAME} created and pushed!"
      echo "ðŸ“¦ This will trigger:"
      echo "   - GitLab Release creation"
      echo "   - GitHub mirror sync"
      echo "   - npm package publish (if configured)"
      echo ""
      echo "View release: ${CI_PROJECT_URL}/-/releases/${TAG_NAME}"
  only:
    - main
  when: manual
  allow_failure: false

# ============================================================================
# STAGE: MIRROR GITHUB
# Syncs releases and tags to GitHub repository
# ============================================================================

mirror:github:
  stage: mirror-github
  image: curlimages/curl:latest
  before_script:
    - apk add --no-cache jq git
  script:
    - |
      set -e
      echo "Syncing to GitHub repository..."
      
      # Validate required variables
      if [ -z "$GITHUB_MIRROR_TOKEN" ]; then
        echo "WARNING: GITHUB_MIRROR_TOKEN not set - skipping GitHub mirror"
        echo "To enable GitHub mirroring, add GITHUB_MIRROR_TOKEN to GitLab CI/CD variables"
        exit 0
      fi
      
      GITHUB_OWNER="${GITHUB_ORG:-BlueflyCollective}"
      GITHUB_REPO_NAME="${GITHUB_REPO:-OSSA}"
      GITHUB_API="https://api.github.com"
      
      echo "GitHub Repository: ${GITHUB_OWNER}/${GITHUB_REPO_NAME}"
      
      # Determine tag from CI environment
      if [ -n "$CI_COMMIT_TAG" ]; then
        TAG_NAME="$CI_COMMIT_TAG"
        echo "Processing tag: ${TAG_NAME}"
      elif [ -n "$CI_COMMIT_REF_NAME" ] && [[ "$CI_COMMIT_REF_NAME" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+ ]]; then
        TAG_NAME="$CI_COMMIT_REF_NAME"
        echo "Processing version tag: ${TAG_NAME}"
      else
        echo "WARNING: No tag detected - skipping GitHub release sync"
        echo "CI_COMMIT_TAG: ${CI_COMMIT_TAG:-not set}"
        echo "CI_COMMIT_REF_NAME: ${CI_COMMIT_REF_NAME:-not set}"
        exit 0
      fi
      
      # Fetch GitLab release data if available
      echo "Fetching GitLab release data..."
      GITLAB_RELEASE_RESPONSE=$(curl -sS -H "PRIVATE-TOKEN: ${CI_JOB_TOKEN}" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases/${TAG_NAME}" || echo "")
      
      RELEASE_NAME="${TAG_NAME}"
      RELEASE_BODY=""
      
      if [ -n "$GITLAB_RELEASE_RESPONSE" ] && echo "$GITLAB_RELEASE_RESPONSE" | jq -e '.name' > /dev/null 2>&1; then
        RELEASE_NAME=$(echo "$GITLAB_RELEASE_RESPONSE" | jq -r '.name // "'"${TAG_NAME}"'"')
        RELEASE_BODY=$(echo "$GITLAB_RELEASE_RESPONSE" | jq -r '.description // ""')
        echo "Found GitLab release: ${RELEASE_NAME}"
      else
        # Fallback: use CHANGELOG.md if available
        if [ -f "CHANGELOG.md" ]; then
          echo "Extracting release notes from CHANGELOG.md..."
          RELEASE_BODY=$(awk "/^## \[${TAG_NAME#v}\]/,/^## /" CHANGELOG.md | head -n -1 || echo "")
          if [ -z "$RELEASE_BODY" ]; then
            RELEASE_BODY="Release ${TAG_NAME}"
          fi
        else
          RELEASE_BODY="Release ${TAG_NAME}"
        fi
      fi
      
      # Check if GitHub release already exists
      echo "Checking if GitHub release exists..."
      EXISTING_RELEASE=$(curl -sS -H "Authorization: token ${GITHUB_MIRROR_TOKEN}" \
        "${GITHUB_API}/repos/${GITHUB_OWNER}/${GITHUB_REPO_NAME}/releases/tags/${TAG_NAME}" || echo "")
      
      if echo "$EXISTING_RELEASE" | jq -e '.id' > /dev/null 2>&1; then
        RELEASE_ID=$(echo "$EXISTING_RELEASE" | jq -r '.id')
        echo "Updating existing GitHub release (ID: ${RELEASE_ID})..."
        
        # Update release
        UPDATE_RESPONSE=$(curl -sS -X PATCH \
          -H "Authorization: token ${GITHUB_MIRROR_TOKEN}" \
          -H "Content-Type: application/json" \
          -d "{\"tag_name\":\"${TAG_NAME}\",\"name\":\"${RELEASE_NAME}\",\"body\":$(echo "$RELEASE_BODY" | jq -Rs .),\"draft\":false,\"prerelease\":false}" \
          "${GITHUB_API}/repos/${GITHUB_OWNER}/${GITHUB_REPO_NAME}/releases/${RELEASE_ID}")
        
        if echo "$UPDATE_RESPONSE" | jq -e '.id' > /dev/null 2>&1; then
          echo "GitHub release updated successfully"
          echo "Release URL: $(echo "$UPDATE_RESPONSE" | jq -r '.html_url')"
        else
          echo "ERROR: Failed to update GitHub release"
          echo "Response: ${UPDATE_RESPONSE}"
          exit 1
        fi
      else
        echo "Creating new GitHub release..."
        
        # Create release
        CREATE_RESPONSE=$(curl -sS -X POST \
          -H "Authorization: token ${GITHUB_MIRROR_TOKEN}" \
          -H "Content-Type: application/json" \
          -d "{\"tag_name\":\"${TAG_NAME}\",\"name\":\"${RELEASE_NAME}\",\"body\":$(echo "$RELEASE_BODY" | jq -Rs .),\"draft\":false,\"prerelease\":false}" \
          "${GITHUB_API}/repos/${GITHUB_OWNER}/${GITHUB_REPO_NAME}/releases")
        
        if echo "$CREATE_RESPONSE" | jq -e '.id' > /dev/null 2>&1; then
          echo "GitHub release created successfully"
          echo "Release URL: $(echo "$CREATE_RESPONSE" | jq -r '.html_url')"
        else
          echo "ERROR: Failed to create GitHub release"
          echo "Response: ${CREATE_RESPONSE}"
          exit 1
        fi
      fi
      
      echo "GitHub mirroring completed"
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_REF_NAME =~ /^v?[0-9]+\.[0-9]+\.[0-9]+$/
      when: on_success
  needs:
    - job: release:prod
      optional: true
  allow_failure: true

# ============================================================================
# GLOBAL SETTINGS
# ============================================================================

# Workflow rules
workflow:
  rules:
    # Run on branches
    - if: $CI_COMMIT_BRANCH
    # Run on merge requests
    - if: $CI_MERGE_REQUEST_IID
    # Run on tags
    - if: $CI_COMMIT_TAG
    # Default: run
    - when: always

# GitLab Pages deployment
pages:
  stage: .post
  image: node:20-alpine
  before_script:
    - cd website
    - npm ci
  script:
    - npm run build
    - mv out ../public
  artifacts:
    paths:
      - public
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always  # Run even if previous stages failed
