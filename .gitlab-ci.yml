# GitLab CI/CD Pipeline for OSSA
# Decoupled Release Model
# - Code flows freely - Feature â†’ development â†’ main (CI validates, no auto-release)
# - Website deployment - Manual button (independent of releases)
# - NPM releases - Milestone-gated + ENABLE_RELEASE variable required
#
# Workflow
# 1. Feature branches â†’ merge to development (CI validates)
# 2. Development â†’ merge to main via merge train (CI validates)
# 3. Click "Deploy Website" button â†’ GitLab Pages deploys
# 4. To release - Set ENABLE_RELEASE=true + close milestone â†’ automatic npm publish + git tag
#
# Release Gate
# Releases require BOTH conditions
#   - Milestone must be 100% complete and closed

include:
  - local: '.gitlab/ci/agents.yml'
  - local: '.gitlab/ci/branch-policy.yml'
  - local: '.gitlab/ci/webhook-agents.yml'  # OSSA v0.2.8 webhook-triggered agents
  # Security scanning from Auto DevOps
  - template: Jobs/SAST.gitlab-ci.yml
  - template: Jobs/Secret-Detection.gitlab-ci.yml
  - template: Jobs/Dependency-Scanning.gitlab-ci.yml
  # Merge trains enabled via workflow rules (see workflow section at bottom)
  # Component available but private - uncomment when gitlab_components is public
  # - component: gitlab.com/blueflyio/agent-platform/gitlab_components/merge-train@main

#   - CI/CD variable ENABLE_RELEASE must be set to "true"
# This allows deploying to main without releasing. Set the variable only when ready to release.
#
# To set ENABLE_RELEASE
#   GitLab UI - Settings â†’ CI/CD â†’ Variables â†’ Add variable
#   Variable - ENABLE_RELEASE
#   Value - true
#   Protected - Yes (recommended)
#   Masked - No
#
# Status - ACTIVE MODE
# Last updated - 2025-11-25

stages:
  - setup
  - version-detect
  - validate
  - build
  - test
  - quality
  - deploy
  - release
  - mirror

variables:
  NODE_VERSION: "22"
  NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  HUSKY: "0"
  LEFTHOOK: "0"

# ============================================================================
# STAGE 0 - VERSION DETECTION & DEV TAG MANAGEMENT
# ============================================================================

detect:milestone-and-tags:
  stage: version-detect
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set +e  # Don't exit on error - we handle errors manually
      
      echo "DEV TAG MANAGEMENT"
      echo "=================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo "Pipeline: ${CI_PIPELINE_ID}"
      echo ""

      # Initialize env files
      cat > dev-tags.env << 'EOF'
      DEV_TAG_VERSION=
      DEV_TAG_NAME=
      DEV_TAG_BUILD=
      DEV_MILESTONE_ID=
      EOF

      # Only run on main and development branches
      if [ "$CI_COMMIT_BRANCH" != "main" ] && [ "$CI_COMMIT_BRANCH" != "development" ]; then
        echo "Skipping dev tag management (not on main/development branch)"
      else
        # Get all milestones
        DEV_MILESTONES=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data-urlencode "per_page=100" \
          --data-urlencode "state=all" 2>/dev/null || echo "[]")

        if [ "$DEV_MILESTONES" != "[]" ] && [ -n "$DEV_MILESTONES" ]; then
          # Process milestones - use process substitution to avoid subshell
          while read -r dev_milestone_json; do
            [ -z "$dev_milestone_json" ] && continue

            DEV_TITLE=$(echo "$dev_milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
            DEV_ID=$(echo "$dev_milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
            DEV_VERSION=$(echo "$DEV_TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

            [ -z "$DEV_VERSION" ] && continue

        # Skip if already released
            if git tag -l 2>/dev/null | grep -qE "^v?${DEV_VERSION}$"; then
              echo "Skipping ${DEV_VERSION} (already released)"
          continue
        fi

            # Get latest dev tag for this version
            LATEST_DEV_TAG=$(git tag -l "${DEV_VERSION}-dev-*" 2>/dev/null | sort -V | tail -1)
            CURRENT_BUILD=$(echo "$LATEST_DEV_TAG" | sed "s/.*-dev-//" | grep -E '^[0-9]+$' || echo "0")
            [ -z "$CURRENT_BUILD" ] && CURRENT_BUILD=0
            NEXT_BUILD=$((CURRENT_BUILD + 1))

            # Check if we need a new tag
            if [ -n "$LATEST_DEV_TAG" ]; then
              TAG_COMMIT=$(git rev-list -n 1 "$LATEST_DEV_TAG" 2>/dev/null || echo "")
              if [ "$CI_COMMIT_SHA" = "$TAG_COMMIT" ]; then
                echo "No changes since ${LATEST_DEV_TAG}, skipping"
                continue
              fi
            fi

            NEW_TAG="${DEV_VERSION}-dev-${NEXT_BUILD}"
            echo "Creating dev tag: ${NEW_TAG}"

            # Create and push tag
            if git tag -a "$NEW_TAG" -m "Dev build ${NEXT_BUILD} for milestone ${DEV_ID}" "$CI_COMMIT_SHA" 2>/dev/null; then
              if git push origin "$NEW_TAG" 2>/dev/null; then
                echo "Created dev tag: ${NEW_TAG}"
                cat > dev-tags.env << EOF
      DEV_TAG_VERSION=${DEV_VERSION}
      DEV_TAG_NAME=${NEW_TAG}
      DEV_TAG_BUILD=${NEXT_BUILD}
      DEV_MILESTONE_ID=${DEV_ID}
      EOF
              else
                echo "Failed to push tag ${NEW_TAG}"
                git tag -d "$NEW_TAG" 2>/dev/null || true
              fi
            else
              echo "Tag ${NEW_TAG} already exists or failed to create"
            fi

            break  # Only create one dev tag per pipeline
          done < <(echo "$DEV_MILESTONES" | jq -c '.[]' 2>/dev/null || echo "")
        fi
      fi
      
      # Also detect closed milestones for release readiness
      echo ""
      echo "RELEASE READINESS CHECK"
      echo "========================"

      # Get all milestones
      ALL_MILESTONES=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones" \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --data-urlencode "per_page=100" \
        --data-urlencode "state=all")
      
      # Initialize milestone env file
      cat > milestone-version.env << 'EOF'
      RELEASE_VERSION=
      MILESTONE_TITLE=
      MILESTONE_ID=
      MILESTONE_READY=false
      EOF
      
      # Find closed milestone ready for release - use process substitution to avoid subshell
      FOUND_MILESTONE=false
      while read -r milestone_json; do
        [ -z "$milestone_json" ] && continue
        [ "$FOUND_MILESTONE" = "true" ] && break
      
        TITLE=$(echo "$milestone_json" | jq -r '.title // ""' 2>/dev/null || echo "")
        ID=$(echo "$milestone_json" | jq -r '.id // ""' 2>/dev/null || echo "")
        STATE=$(echo "$milestone_json" | jq -r '.state // ""' 2>/dev/null || echo "")
      
        VERSION=$(echo "$TITLE" | grep -oE 'v?[0-9]+\.[0-9]+\.[0-9]+(-[A-Za-z0-9]+)?' | head -1 | sed 's/^v//')

        if [ -n "$VERSION" ] && [ "$STATE" = "closed" ]; then
          # Skip if already released
          if git tag -l 2>/dev/null | grep -qE "^v?${VERSION}$"; then
            continue
          fi

          # Get milestone stats
          MILESTONE_STATS=$(curl -sS -G "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/milestones/${ID}" \
            --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" 2>/dev/null || echo "{}")
      
          TOTAL_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.total_issues_count // 0' 2>/dev/null || echo "0")
          CLOSED_ISSUES=$(echo "$MILESTONE_STATS" | jq -r '.closed_issues_count // 0' 2>/dev/null || echo "0")
          OPEN_ISSUES=$((TOTAL_ISSUES - CLOSED_ISSUES))

          # Check if 100% complete
          if [ "$OPEN_ISSUES" -eq 0 ] && [ "$TOTAL_ISSUES" -gt 0 ]; then
            cat > milestone-version.env << EOF
      RELEASE_VERSION=${VERSION}
      MILESTONE_TITLE=${TITLE}
      MILESTONE_ID=${ID}
      MILESTONE_READY=true
      EOF
            echo "Release-ready milestone found: v${VERSION}"
            FOUND_MILESTONE=true
            break
          elif [ "$TOTAL_ISSUES" -eq 0 ]; then
            cat > milestone-version.env << EOF
      RELEASE_VERSION=${VERSION}
      MILESTONE_TITLE=${TITLE}
      MILESTONE_ID=${ID}
      MILESTONE_READY=true
      EOF
            echo "Release-ready milestone found: v${VERSION} (empty milestone)"
            FOUND_MILESTONE=true
            break
          fi
        fi
      done < <(echo "$ALL_MILESTONES" | jq -c '.[] | select(.state == "closed")' 2>/dev/null || echo "")
      
      # If no milestone found, ensure env file exists
      if [ ! -s milestone-version.env ]; then
        cat > milestone-version.env << 'EOF'
      RELEASE_VERSION=
      MILESTONE_TITLE=
      MILESTONE_ID=
      MILESTONE_READY=false
      EOF
        echo "â„¹ï¸  No release-ready milestone found"
      fi
      
      # Merge dev-tags.env into milestone-version.env
      if [ -s dev-tags.env ]; then
        cat dev-tags.env >> milestone-version.env
      fi
      
      echo ""
      echo "ðŸ“‹ Summary:"
      cat milestone-version.env
  artifacts:
    reports:
      dotenv: milestone-version.env
    paths:
      - milestone-version.env
      - dev-tags.env
    expire_in: 1 day
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "development"
      when: always
  allow_failure: true

# ============================================================================
# STAGE 1 - SETUP & VALIDATE
# ============================================================================

validate:node:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - node --version
    - npm --version
    - echo "Node.js ${NODE_VERSION} ready"
  rules:
    - when: always

validate:ossa:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - echo "Validating example manifests..."
    - node dist/cli/index.js validate examples/getting-started/hello-world-complete.ossa.yaml || echo "âš ï¸  Validation warnings (non-blocking)"
  allow_failure: true
  rules:
    - when: always

# Check for divergent branches before merging to protected branches
check:divergence:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      if [ "$CI_MERGE_REQUEST_TARGET_BRANCH" = "main" ] || [ "$CI_MERGE_REQUEST_TARGET_BRANCH" = "development" ]; then
        echo "ðŸ” Checking for divergent branches..."
        git fetch origin
        
        BEHIND=$(git log --oneline origin/$CI_MERGE_REQUEST_SOURCE_BRANCH..origin/$CI_MERGE_REQUEST_TARGET_BRANCH 2>/dev/null | wc -l)
        AHEAD=$(git log --oneline origin/$CI_MERGE_REQUEST_TARGET_BRANCH..origin/$CI_MERGE_REQUEST_SOURCE_BRANCH 2>/dev/null | wc -l)
        
        if [ $BEHIND -gt 0 ] && [ $AHEAD -gt 0 ]; then
          echo "âŒ DIVERGENT BRANCHES DETECTED"
          echo "Target has $BEHIND commits not in source"
          echo "Source has $AHEAD commits not in target"
          echo "Use squash merge or force push recovery"
          exit 1
        fi
        
        if [ $BEHIND -gt 0 ]; then
          echo "âš ï¸  Source behind target by $BEHIND commits"
          exit 1
        fi
        
        echo "âœ… No divergence detected"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Check for .DS_Store files
check:ds-store:
  stage: validate
  image: alpine:latest
  before_script:
    - apk add --no-cache git
  script:
    - |
      echo "ðŸ” Checking for .DS_Store files..."
      if git diff --name-only $CI_MERGE_REQUEST_DIFF_BASE_SHA 2>/dev/null | grep -q "\.DS_Store"; then
        echo "âŒ .DS_Store files in MR"
        exit 1
      fi
      echo "âœ… No .DS_Store files"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

validate:version-sync:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - echo "Checking version consistency..."
    - npm run version:check
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - README.md
      - spec/**/*
      when: always

# ============================================================================
# VERSION MANAGEMENT VIA GITLAB AGENTS (Dogfooding)
# ============================================================================
# TODO: Enable after component is published to main
# include:
#   - component: gitlab.com/blueflyio/openstandardagents/version-management/version-bump-agent@main

# version:bump:agent:
#   extends: .version-bump-agent
#   variables:
#     BUMP_TYPE: "patch"
#     TARGET_BRANCH: "development"
#   rules:
#     - if: '$BUMP_VERSION == "true"'
#       when: manual
#       allow_failure: false
    - if: '$CI_MERGE_REQUEST_TITLE =~ /^chore:.*version/i'
      when: manual
      allow_failure: false

# version:sync:agent:
#   extends: .version-sync-agent
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "push"'
#       when: always
#     - if: '$VERSION_SYNC == "true"'
#       when: manual

# version:consistency:check:
#   extends: .version-consistency-check

validate:scripts-version:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "Validating npm scripts use dynamic version..."
      VERSION=$(node -p "require('./package.json').version")
      echo "Current version: ${VERSION}"
      
      # Verify exports["./schema"] matches current version
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"
      ACTUAL_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''")
      if [ "$ACTUAL_EXPORT" != "$EXPECTED_EXPORT" ] && [ -n "$ACTUAL_EXPORT" ]; then
        echo "âŒ ERROR: package.json exports[\"./schema\"] is \"${ACTUAL_EXPORT}\", should be \"${EXPECTED_EXPORT}\""
        exit 1
      fi

      # Check scripts don't have hardcoded version paths
      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "âœ… Scripts field does not contain hardcoded version paths"
      else
        echo "âŒ ERROR: package.json scripts contain hardcoded version paths"
        exit 1
      fi

      echo "âœ… All scripts use dynamic version detection"
  allow_failure: false
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - changes:
      - package.json
      - scripts/**/*
      when: always

validate:docs-consistency:
  stage: validate
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Pre-Release Documentation Validation"
      echo "========================================"
      
      VERSION=$(node -p "require('./package.json').version")
      echo "Package version: v${VERSION}"

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo ""
        echo "âŒ ERROR: Documentation is out of sync!"
        echo ""
        echo "FIX REQUIRED:"
        echo " 1. Run locally: npx tsx scripts/sync-versions.ts --fix"
        echo " 2. Commit the changes"
        echo " 3. Push and re-run pipeline"
        exit 1
      fi

      echo "âœ… ALL DOCUMENTATION CONSISTENCY CHECKS PASSED"
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
    - if: $CI_COMMIT_BRANCH == "development"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
      when: always
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "development"
      when: always

# ============================================================================
# STAGE 2 - BUILD
# ============================================================================

build:dist:
  stage: build
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - test -f dist/cli/index.js || (echo "âŒ ERROR dist/cli/index.js missing" && exit 1)
    - echo "âœ… Build completed"
  artifacts:
    paths:
      - dist/
      - package.json
      - package-lock.json
    expire_in: 1 hour
  rules:
    - when: always

# ============================================================================
# STAGE 3 - TEST
# ============================================================================

test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm run lint || echo "âš ï¸  Lint warnings"
    - npm run typecheck || echo "âš ï¸  Typecheck warnings"
  allow_failure: true
  rules:
    - when: always

test:code-quality:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npx eslint src/ -f json -o eslint-report.json || true
    - node scripts/eslint-to-codequality.cjs
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    paths:
      - gl-code-quality-report.json
      - eslint-report.json
    expire_in: 7 days
  rules:
    - when: always

test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - npm run build
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      junit: test-results/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
      - test-results/
    expire_in: 7 days
  allow_failure: false
  rules:
    - when: always

test:security:
  stage: test
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm audit --production || echo "âš ï¸  Security vulnerabilities"
  allow_failure: true
  rules:
    - when: always

# ============================================================================
# STAGE 4 - QUALITY GATES
# ============================================================================

quality:gates:
  stage: quality
  image: node:${NODE_VERSION}-alpine
  script:
    - echo "âœ… Quality gates passed"
  rules:
    - when: always
  needs:
    - job: test:unit
      optional: true
    - job: test:lint
      optional: true
    - job: test:security
      optional: true

# ============================================================================
# STAGE 5 - DEPLOY (Removed - Website moved to openstandardagents.org)
# ============================================================================
# Website deployment is now handled by the openstandardagents.org repository.
# This repo (openstandardagents) is the spec/CLI npm package only.

# ============================================================================
# STAGE 6 - RELEASE (NPM - Milestone-Gated)
# ============================================================================

# PRE-RELEASE VALIDATION - Critical checks before any release
release:validate:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git jq bash curl
    - npm ci --legacy-peer-deps
  script:
    - |
      #!/bin/bash
      set -e

      echo "ðŸ”’ PRE-RELEASE VALIDATION"
      echo "========================="
      echo ""

      ERRORS=0
      WARNINGS=0

      # 1. VERSION CONSISTENCY CHECK
      echo "ðŸ“‹ 1. Version Consistency"
      VERSION=$(node -p "require('./package.json').version")
      echo "   Package version: v${VERSION}"

      # Check schema exists for this version
      SCHEMA_PATH="spec/v${VERSION}/ossa-${VERSION}.schema.json"
      if [ ! -f "$SCHEMA_PATH" ]; then
        echo "   âŒ ERROR: Schema not found: ${SCHEMA_PATH}"
        ERRORS=$((ERRORS + 1))
      else
        echo "   âœ… Schema exists: ${SCHEMA_PATH}"
      fi

      # Check README version badge matches
      if grep -q "v${VERSION}" README.md; then
        echo "   âœ… README version badge matches"
      else
        echo "   âš ï¸  WARNING: README may not reference v${VERSION}"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 2. SCHEMA VALIDATION
      echo ""
      echo "ðŸ“‹ 2. Schema Validation"

      # Check schema is valid JSON
      if jq empty "$SCHEMA_PATH" 2>/dev/null; then
        echo "   âœ… Schema is valid JSON"
      else
        echo "   âŒ ERROR: Schema is not valid JSON"
        ERRORS=$((ERRORS + 1))
      fi

      # Check schema has required fields
      SCHEMA_VERSION=$(jq -r '.properties.apiVersion.const // .properties.apiVersion.enum[0] // ""' "$SCHEMA_PATH" 2>/dev/null || echo "")
      if [ -n "$SCHEMA_VERSION" ]; then
        echo "   âœ… Schema apiVersion: ${SCHEMA_VERSION}"
      else
        echo "   âš ï¸  WARNING: Could not detect apiVersion in schema"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 3. EXAMPLES VALIDATION
      echo ""
      echo "ðŸ“‹ 3. Examples Validation"

      EXAMPLE_ERRORS=0
      for example in examples/**/*.ossa.yaml examples/**/*.ossa.json; do
        [ ! -f "$example" ] && continue

        # Check apiVersion matches
        if grep -q "apiVersion.*ossa/v${VERSION}" "$example" 2>/dev/null || \
           jq -e ".apiVersion == \"ossa/v${VERSION}\"" "$example" 2>/dev/null; then
          echo "   âœ… ${example}"
        else
          EXAMPLE_API=$(grep -oE "apiVersion.*ossa/v[0-9.]+" "$example" 2>/dev/null | head -1 || \
                        jq -r '.apiVersion // "unknown"' "$example" 2>/dev/null || echo "unknown")
          echo "   âŒ ERROR: ${example} has ${EXAMPLE_API}, expected ossa/v${VERSION}"
          EXAMPLE_ERRORS=$((EXAMPLE_ERRORS + 1))
        fi
      done

      if [ $EXAMPLE_ERRORS -gt 0 ]; then
        echo "   âŒ ${EXAMPLE_ERRORS} examples have wrong apiVersion"
        ERRORS=$((ERRORS + EXAMPLE_ERRORS))
      fi

      # 4. BUILD ARTIFACTS CHECK
      echo ""
      echo "ðŸ“‹ 4. Build Artifacts"

      if [ -f "dist/cli/index.js" ]; then
        echo "   âœ… CLI built: dist/cli/index.js"
      else
        echo "   âŒ ERROR: CLI not built"
        ERRORS=$((ERRORS + 1))
      fi

      if [ -d "dist/lib" ]; then
        echo "   âœ… Library built: dist/lib/"
      else
        echo "   âš ï¸  WARNING: dist/lib/ not found"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 5. PACKAGE.JSON EXPORTS CHECK
      echo ""
      echo "ðŸ“‹ 5. Package Exports"

      SCHEMA_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''" 2>/dev/null || echo "")
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"

      if [ "$SCHEMA_EXPORT" = "$EXPECTED_EXPORT" ]; then
        echo "   âœ… Schema export correct: ${SCHEMA_EXPORT}"
      elif [ -z "$SCHEMA_EXPORT" ]; then
        echo "   âš ï¸  WARNING: No ./schema export defined"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "   âŒ ERROR: Schema export mismatch"
        echo "      Expected: ${EXPECTED_EXPORT}"
        echo "      Got: ${SCHEMA_EXPORT}"
        ERRORS=$((ERRORS + 1))
      fi

      # 6. TEST RUN
      echo ""
      echo "ðŸ“‹ 6. Test Suite"

      if npm run test 2>&1; then
        echo "   âœ… All tests passed"
      else
        echo "   âŒ ERROR: Tests failed"
        ERRORS=$((ERRORS + 1))
      fi

      # 7. TYPECHECK
      echo ""
      echo "ðŸ“‹ 7. TypeScript Validation"

      if npm run typecheck 2>&1; then
        echo "   âœ… TypeScript compilation clean"
      else
        echo "   âŒ ERROR: TypeScript errors"
        ERRORS=$((ERRORS + 1))
      fi

      # 8. NO HARDCODED VERSIONS IN SCRIPTS
      echo ""
      echo "ðŸ“‹ 8. Script Version Check"

      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\\/v0\\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "   âœ… No hardcoded versions in scripts"
      else
        echo "   âŒ ERROR: Hardcoded versions found in package.json scripts"
        ERRORS=$((ERRORS + 1))
      fi

      # SUMMARY
      echo ""
      echo "========================================"
      echo "ðŸ“Š VALIDATION SUMMARY"
      echo "========================================"
      echo "   Errors: ${ERRORS}"
      echo "   Warnings: ${WARNINGS}"
      echo ""

      if [ $ERRORS -gt 0 ]; then
        echo "âŒ RELEASE BLOCKED: ${ERRORS} error(s) must be fixed"
        echo ""
        echo "Fix the errors above before releasing."
        exit 1
      fi

      if [ $WARNINGS -gt 0 ]; then
        echo "âš ï¸  RELEASE APPROVED WITH WARNINGS: ${WARNINGS} warning(s)"
      else
        echo "âœ… RELEASE APPROVED: All checks passed"
      fi
  artifacts:
    reports:
      dotenv: validation-report.env
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  needs:
    - build:dist
    - test:unit

release:preview:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Release Preview (Dry-Run)"
      echo "============================"
      
      if [ "$ENABLE_RELEASE" = "true" ]; then
        echo "âœ… ENABLE_RELEASE: ${ENABLE_RELEASE} (releases enabled)"
      else
        echo "âš ï¸  ENABLE_RELEASE: ${ENABLE_RELEASE:-not set} (releases disabled)"
      fi
      
      if [ -n "$RELEASE_VERSION" ]; then
        echo "ðŸ“¦ Detected from closed milestone:"
        echo "   Milestone: ${MILESTONE_TITLE}"
        echo "   Version: v${RELEASE_VERSION}"
        echo "   Ready: ${MILESTONE_READY:-false}"
      fi

      CURRENT_VERSION=$(node -p "require('./package.json').version")
      echo "ðŸ“„ Current package.json: v${CURRENT_VERSION}"
      
      if [ "$ENABLE_RELEASE" = "true" ] && [ "$MILESTONE_READY" = "true" ]; then
        echo "âœ… Release will proceed automatically"
      else
        echo "âš ï¸  Release blocked (see conditions above)"
      fi
      
      npx semantic-release --dry-run || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  allow_failure: true
  needs:
    - build:dist
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:npm:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
    - detect:milestone-and-tags
  before_script:
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI Release"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags || git fetch --tags || true
    - git checkout -B main origin/main
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "ðŸš€ MILESTONE-GATED RELEASE"
      echo "=========================="
      
      # Check ENABLE_RELEASE gate
      if [ "$ENABLE_RELEASE" != "true" ]; then
        echo "ðŸš« RELEASE BLOCKED: ENABLE_RELEASE not set"
        echo ""
        echo "To enable releases:"
        echo " Settings â†’ CI/CD â†’ Variables â†’ Add variable"
        echo " Variable: ENABLE_RELEASE"
        echo " Value: true"
        exit 0
      fi
      
      # Check milestone readiness
      if [ "$MILESTONE_READY" != "true" ]; then
        echo "ðŸš« RELEASE BLOCKED: No release-ready milestone"
        echo ""
        echo "Requirements:"
        echo " 1. âœ… ENABLE_RELEASE = true"
        echo " 2. âŒ Milestone must be closed and 100% complete"
        exit 0
      fi
      
      echo "âœ… Release gate passed"
      echo "   ENABLE_RELEASE: ${ENABLE_RELEASE}"
      echo "   Milestone: ${MILESTONE_TITLE}"
      echo "   Version: v${RELEASE_VERSION}"

      # Update package.json
      npm version ${RELEASE_VERSION} --no-git-tag-version --allow-same-version

      # Sync documentation
      echo "ðŸ“ Syncing documentation..."
      npx tsx scripts/sync-versions.ts --fix

      if ! npx tsx scripts/sync-versions.ts --check; then
        echo "âŒ ERROR: Documentation sync failed"
        exit 1
      fi

      # Configure npm
      GITLAB_HOST="${CI_SERVER_HOST}"
      if [ -n "$NPM_TOKEN" ]; then
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      //registry.npmjs.org/:_authToken=${NPM_TOKEN}
      EOF
      else
        cat > .npmrc << EOF
      @bluefly:registry=${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/npm/
      //${GITLAB_HOST}/api/v4/projects/${CI_PROJECT_ID}/packages/npm/:_authToken=${CI_JOB_TOKEN}
      EOF
      fi

      # Final tests
      echo "ðŸ§ª Running final tests..."
      npm run test || (echo "âŒ Tests failed" && exit 1)

      # Publish to npm
      echo "ðŸ“¦ Publishing v${RELEASE_VERSION} to npm..."
      if ! npm publish --access public; then
        echo "âŒ npm publish failed"
        exit 1
      fi
      
      # Create git tag with comprehensive release information
      PROD_TAG="v${RELEASE_VERSION}"
      RELEASE_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      
      # Extract release notes from CHANGELOG if available
      CHANGELOG_FILE="spec/v${RELEASE_VERSION}/CHANGELOG.md"
      if [ ! -f "$CHANGELOG_FILE" ]; then
        CHANGELOG_FILE="spec/v${RELEASE_VERSION}-RC/CHANGELOG.md"
      fi
      
      if [ -f "$CHANGELOG_FILE" ]; then
        # Extract overview and key features from CHANGELOG
        OVERVIEW=$(grep -A 5 "^## Overview" "$CHANGELOG_FILE" 2>/dev/null | head -6 | tail -5 | sed 's/^/  /' || echo "")
        KEY_FEATURES=$(grep -A 20 "^## What's New" "$CHANGELOG_FILE" 2>/dev/null | head -21 | tail -20 | sed 's/^/  /' || echo "")
      else
        OVERVIEW=""
        KEY_FEATURES=""
      fi
      
      # Build comprehensive tag message using heredoc
      read -r -d '' TAG_MESSAGE << EOF || true
      Release v${RELEASE_VERSION}

      Milestone - ${MILESTONE_TITLE}
      Pipeline - ${CI_PIPELINE_ID}
      Released - ${RELEASE_DATE}
      Commit - ${CI_COMMIT_SHA}

      ${OVERVIEW}

      ${KEY_FEATURES}

      Documentation
      - Schema - https://openstandardagents.org/schema/
      - Changelog - https://github.com/blueflyio/openstandardagents/blob/main/CHANGELOG.md
      - Migration Guide - https://openstandardagents.org/docs/migration-guides/
      - Examples - https://openstandardagents.org/examples/

      npm Package - @bluefly/openstandardagents@${RELEASE_VERSION}
      GitLab Release - https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}
      EOF
      
      git tag -a "$PROD_TAG" -m "$TAG_MESSAGE" "$CI_COMMIT_SHA"
      
      # Commit and push
      git add package.json package-lock.json README.md spec/ || true
      git commit -m "chore(release): v${RELEASE_VERSION} [skip ci]" || echo "No changes to commit"
      git push origin main --tags

      # Create GitLab Release
      echo "ðŸ“‹ Creating GitLab Release..."
      curl --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"name\": \"Release v${RELEASE_VERSION}\",
          \"tag_name\": \"v${RELEASE_VERSION}\",
          \"description\": \"## What's Changed\\n\\nSee [CHANGELOG.md](https://gitlab.com/${CI_PROJECT_PATH}/-/blob/main/spec/v${RELEASE_VERSION}/CHANGELOG.md) for details.\\n\\n## Milestone\\n\\n${MILESTONE_TITLE}\\n\\n## Assets\\n- [npm package](https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION})\\n- [JSON Schema](https://openstandardagents.org/schema/)\",
          \"assets\": {
            \"links\": [
              {
                \"name\": \"npm package\",
                \"url\": \"https://www.npmjs.com/package/@bluefly/openstandardagents/v/${RELEASE_VERSION}\",
                \"link_type\": \"package\"
              },
              {
                \"name\": \"JSON Schema\",
                \"url\": \"https://openstandardagents.org/schema/\",
                \"link_type\": \"other\"
              }
            ]
          }
        }" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases"

      echo "âœ… GitLab Release created: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/v${RELEASE_VERSION}"

      echo "âœ… Release v${RELEASE_VERSION} completed!"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true" && $ENABLE_RELEASE == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual
  needs:
    - quality:gates
    - build:dist
    - release:preview
    - release:validate
    - validate:docs-consistency
    - detect:milestone-and-tags

# ============================================================================
# STAGE 7 - MIRROR
# ============================================================================

mirror:github:
  stage: mirror
  image: alpine:latest
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
  script:
    - |
      if [ -z "$GITHUB_MIRROR_TOKEN" ]; then
        echo "â„¹ï¸  GITHUB_MIRROR_TOKEN not set - skipping"
        exit 0
      fi

      echo "ðŸ”„ Syncing to GitHub..."
      git remote add github https://${GITHUB_MIRROR_TOKEN}@github.com/blueflyio/openstandardagents.git || true
      git push github --all --force || true
      git push github --tags --force || true
      echo "âœ… GitHub mirror synced"
  rules:
    - if: $CI_COMMIT_TAG
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true

# ============================================================================
# WORKFLOW - MERGE TRAINS ENABLED
# ============================================================================
# Merge trains prevent branch divergence by:
# 1. Queuing MRs instead of racing to merge
# 2. Testing merged state before allowing merge
# 3. Auto-rebasing when target branch updates
# 4. Failing fast on conflicts
#
# Enabled for: development, main branches
# Eliminates: Manual sync commits between releases
# See: https://docs.gitlab.com/ee/ci/pipelines/merge_trains.html
# ============================================================================

workflow:
  rules:
    # Merge train pipelines (combined state testing)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merge_train"
    # Merged result pipelines (pre-merge validation)
    - if: $CI_MERGE_REQUEST_EVENT_TYPE == "merged_result"
    # Regular MR pipelines
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    # Prevent duplicate pipelines (skip branch pipeline if MR is open)
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    # Regular branch pipelines
    - if: $CI_COMMIT_BRANCH
    # Tag pipelines
    - if: $CI_COMMIT_TAG
    - when: always

# ============================================================================
# RELEASE AUTOMATION - Enterprise Grade
# ============================================================================

# Auto-increment dev tag on merge to development
increment-dev-tag:
  stage: .post
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
    - npm install -g tsx
  script:
    - tsx .gitlab/release-automation/scripts/increment-dev-tag.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "development" && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: true

# Manual release buttons (main branch only)
release-to-npm:
  stage: release
  image: node:${NODE_VERSION}
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=npm tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: npm-registry
    url: https://www.npmjs.com/package/@bluefly/openstandardagents
    deployment_tier: production

release-to-github:
  stage: release
  image: node:${NODE_VERSION}
  needs: [release-to-npm]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=github tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  environment:
    name: github
    url: https://github.com/blueflyio/openstandardagents
    deployment_tier: production

# Website deployment moved to openstandardagents.org repository
# See: https://gitlab.com/blueflyio/openstandardagents.org

announce-release:
  stage: .post
  image: node:${NODE_VERSION}
  needs: [release-to-github]
  before_script:
    - npm ci
  script:
    - RELEASE_ACTION=announce tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
# ============================================================================
# AUTOMATED RELEASE MR CREATION
# ============================================================================

create-release-mrs:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      echo "ðŸš€ Checking for milestones needing release MRs..."
      
      MILESTONES=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
        "$CI_API_V4_URL/projects/$CI_PROJECT_ID/milestones?state=active")
      
      echo "$MILESTONES" | jq -r '.[] | select(.title | startswith("v")) | .id + " " + .title' | while read MILESTONE_ID MILESTONE_TITLE; do
        EXISTING_MR=$(curl -s --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
          "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=opened&source_branch=development&target_branch=main&milestone=$MILESTONE_TITLE" \
          | jq -r '.[0].iid // empty')
        
        if [ -z "$EXISTING_MR" ]; then
          curl --request POST \
            --header "PRIVATE-TOKEN: $CI_JOB_TOKEN" \
            --header "Content-Type: application/json" \
            --data "{
              \"source_branch\": \"development\",
              \"target_branch\": \"main\",
              \"title\": \"Draft: ðŸš€ Release $MILESTONE_TITLE\",
              \"description\": \"## Release $MILESTONE_TITLE\\n\\nDraft MR for next release. Features merge to development and accumulate here.\\n\\n### When Ready\\n1. Mark as ready\\n2. Add to merge train\\n3. Train merges to main\\n4. Release automation runs\",
              \"milestone_id\": $MILESTONE_ID,
              \"draft\": true,
              \"labels\": \"type::release,status::draft\"
            }" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests"
        fi
      done
  rules:
    - if: $CI_COMMIT_BRANCH == "development"
      when: manual

# Generate llms.txt context files
generate:llms-txt:
  stage: build
  image: python:3.11-slim
  script:
    - pip install llms-txt
    - llms_txt2ctx llms.txt -o llms-ctx.txt
    - llms_txt2ctx llms.txt -o llms-ctx-full.txt --include-optional
  artifacts:
    paths:
      - llms.txt
      - llms-ctx.txt
      - llms-ctx-full.txt
    expire_in: never
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "development"
      when: on_success

# ============================================================================
# POST-RELEASE SYNC - Sync main back to development after releases
# ============================================================================

sync:main-to-development:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache git curl jq
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      echo "ðŸ”„ Syncing main â†’ development..."

      git fetch origin main development
      git checkout development
      git pull origin development

      # Check if main has commits not in development
      BEHIND=$(git rev-list --count development..origin/main)

      if [ "$BEHIND" -gt 0 ]; then
        echo "development is $BEHIND commits behind main"

        # Create sync MR automatically
        curl --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --header "Content-Type: application/json" \
          --data '{
            "source_branch": "main",
            "target_branch": "development",
            "title": "chore: sync main â†’ development post-release [skip ci]",
            "description": "Automated sync after release. Contains release commits.",
            "remove_source_branch": false,
            "squash": true
          }' \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests"
      else
        echo "âœ… development is up-to-date with main"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_TAG
      when: on_success
    - when: never
