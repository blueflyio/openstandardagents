[{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/export.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/generate.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/github-sync.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/gitlab-agent.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/import.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/init.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/migrate.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/release.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/run.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/schema.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/setup.command.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":214,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":214,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OSSA Setup Command\n * Professional setup commands for branch protection and release automation\n * Follows DRY, OpenAPI, Zod, CRUD principles\n */\n\nimport chalk from 'chalk';\nimport { Command } from 'commander';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { execSync } from 'child_process';\nimport { z } from 'zod';\n\n/**\n * Zod Schema for Setup Options\n */\nconst SetupOptionsSchema = z.object({\n  force: z.boolean().optional().default(false),\n  verbose: z.boolean().optional().default(false),\n});\n\ntype SetupOptions = z.infer<typeof SetupOptionsSchema>;\n\n/**\n * Base Setup Service (DRY)\n */\nclass SetupService {\n  protected projectRoot: string;\n\n  constructor() {\n    this.projectRoot = this.findProjectRoot();\n  }\n\n  protected findProjectRoot(): string {\n    let current = process.cwd();\n    for (let i = 0; i < 10; i++) {\n      const packageJson = path.join(current, 'package.json');\n      if (fs.existsSync(packageJson)) {\n        return current;\n      }\n      const parent = path.dirname(current);\n      if (parent === current) break;\n      current = parent;\n    }\n    return process.cwd();\n  }\n\n  protected log(message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info'): void {\n    const colors = {\n      info: chalk.blue,\n      success: chalk.green,\n      warning: chalk.yellow,\n      error: chalk.red,\n    };\n    console.log(colors[type](message));\n  }\n\n  protected exec(command: string, options?: { cwd?: string; silent?: boolean }): string {\n    try {\n      const result = execSync(command, {\n        cwd: options?.cwd || this.projectRoot,\n        encoding: 'utf-8',\n        stdio: options?.silent ? 'pipe' : 'inherit',\n      });\n      return result.toString();\n    } catch {\n      throw new Error(`Command failed: ${command}`);\n    }\n  }\n\n  protected fileExists(filePath: string): boolean {\n    return fs.existsSync(path.resolve(this.projectRoot, filePath));\n  }\n\n  protected ensureDirectory(dirPath: string): void {\n    const fullPath = path.resolve(this.projectRoot, dirPath);\n    if (!fs.existsSync(fullPath)) {\n      fs.mkdirSync(fullPath, { recursive: true });\n    }\n  }\n}\n\n/**\n * Branch Protection Setup Service\n */\nclass BranchProtectionService extends SetupService {\n  private readonly protectedBranches = ['main', 'development'];\n  private readonly hooksDir = '.git/hooks';\n  private readonly hookFile = 'post-checkout';\n\n  async setup(options: SetupOptions): Promise<void> {\n    this.log('üîí Setting up branch protection for main and development...', 'info');\n    this.log('');\n\n    // Ensure hooks directory exists\n    this.ensureDirectory(this.hooksDir);\n\n    // Create post-checkout hook\n    await this.createPostCheckoutHook(options.force);\n\n    // Configure git hooks path\n    this.exec('git config core.hooksPath .git/hooks', { silent: true });\n\n    this.log('');\n    this.log('‚úÖ Branch protection installed!', 'success');\n    this.log('');\n    this.log(`Protected branches: ${this.protectedBranches.join(', ')}`);\n    this.log('');\n    this.log(\n      'The hook will automatically switch you back if you try to checkout these branches.'\n    );\n    this.log('');\n  }\n\n  private async createPostCheckoutHook(force: boolean): Promise<void> {\n    const hookPath = path.resolve(this.projectRoot, this.hooksDir, this.hookFile);\n\n    if (fs.existsSync(hookPath) && !force) {\n      this.log(`‚úÖ Post-checkout hook already exists`, 'info');\n      // Ensure it's executable\n      fs.chmodSync(hookPath, 0o755);\n      return;\n    }\n\n    const hookContent = this.generateHookContent();\n    fs.writeFileSync(hookPath, hookContent, { mode: 0o755 });\n\n    this.log(`‚úÖ Created post-checkout hook`, 'success');\n  }\n\n  private generateHookContent(): string {\n    return `#!/bin/bash\n#\n# Git Post-Checkout Hook\n# Prevents checking out main and development branches locally\n# Enforces feature branch workflow\n#\n\n# Post-checkout hook receives:\n# $1 = previous HEAD\n# $2 = new HEAD\n# $3 = flag (0=file checkout, 1=branch checkout)\n\n# Only block branch checkouts, not file checkouts\nif [ \"$3\" != \"1\" ]; then\n  exit 0\nfi\n\n# Get current branch name\nCURRENT_BRANCH=$(git branch --show-current 2>/dev/null)\n\n# Protected branches that cannot be checked out locally\nPROTECTED_BRANCHES=\"main development\"\n\n# Check if we're on a protected branch\nfor PROTECTED in $PROTECTED_BRANCHES; do\n  if [ \"$CURRENT_BRANCH\" = \"$PROTECTED\" ]; then\n    echo \"\"\n    echo \"‚ùå ERROR: Cannot work on '$PROTECTED' branch locally\"\n    echo \"\"\n    echo \"This project enforces a feature branch workflow:\"\n    echo \"  ‚Ä¢ Work is done on feature branches\"\n    echo \"  ‚Ä¢ Feature branches ‚Üí merge to development (via MR)\"\n    echo \"  ‚Ä¢ Development ‚Üí merge to main (via MR)\"\n    echo \"\"\n    echo \"Switching you back to your previous branch...\"\n    echo \"\"\n    \n    # Switch back to previous branch or a safe default\n    PREVIOUS_BRANCH=$(git reflog | grep \"checkout:\" | head -2 | tail -1 | awk '{print $NF}' | sed 's|.*:||')\n    \n    if [ -n \"$PREVIOUS_BRANCH\" ] && [ \"$PREVIOUS_BRANCH\" != \"$PROTECTED\" ]; then\n      git checkout \"$PREVIOUS_BRANCH\" 2>/dev/null\n      echo \"‚úÖ Switched back to: $PREVIOUS_BRANCH\"\n    else\n      # Try to find a feature branch\n      FEATURE_BRANCH=$(git branch -a | grep -E \"feat/|feature/\" | head -1 | sed 's|.*/||' | xargs)\n      if [ -n \"$FEATURE_BRANCH\" ]; then\n        git checkout \"$FEATURE_BRANCH\" 2>/dev/null\n        echo \"‚úÖ Switched to feature branch: $FEATURE_BRANCH\"\n      else\n        echo \"‚ö†Ô∏è  Could not auto-switch. Please manually checkout a feature branch:\"\n        echo \"   git checkout -b feat/your-feature development\"\n      fi\n    fi\n    \n    echo \"\"\n    echo \"To work on this project:\"\n    echo \"  1. Create a feature branch: git checkout -b feat/your-feature development\"\n    echo \"  2. Make your changes\"\n    echo \"  3. Push and create a merge request\"\n    echo \"\"\n    echo \"If you need to view $PROTECTED:\"\n    echo \"  ‚Ä¢ Use: git worktree add ../project-$PROTECTED $PROTECTED\"\n    echo \"  ‚Ä¢ Or view on GitLab: https://gitlab.com/blueflyio/openstandardagents/-/tree/$PROTECTED\"\n    echo \"\"\n    exit 1\n  fi\ndone\n\n# Allow checkout\nexit 0\n`;\n  }\n}\n\n/**\n * Release Automation Setup Service\n */\nclass ReleaseAutomationService extends SetupService {\n  private readonly requiredDependencies = ['@gitbeaker/rest', '@octokit/rest'];\n  private readonly requiredEnvVars = ['GITLAB_TOKEN', 'NPM_TOKEN', 'GITHUB_TOKEN'];\n\n  async setup(options: SetupOptions): Promise<void> {\n    this.log('üöÄ Release Automation Setup', 'info');\n    this.log('==============================', 'info');\n    this.log('');\n\n    // Check branch\n    await this.checkBranch();\n\n    // Check dependencies\n    await this.checkDependencies();\n\n    // Check CI/CD variables\n    this.checkCICDVariables();\n\n    // Check webhooks\n    this.checkWebhooks();\n\n    // Run tests\n    await this.runTests();\n\n    this.log('');\n    this.log('==============================', 'info');\n    this.log('‚úÖ Setup checks complete!', 'success');\n    this.log('');\n    this.log('Next steps:');\n    this.log('  1. Configure webhooks in GitLab UI');\n    this.log('  2. Set CI/CD variables in GitLab UI');\n    this.log('  3. Create test milestone: v0.2.8-test');\n    this.log('  4. Verify automation works');\n    this.log('');\n  }\n\n  private async checkBranch(): Promise<void> {\n    try {\n      const branch = this.exec('git branch --show-current', { silent: true }).trim();\n      if (branch !== 'development') {\n        this.log(\n          `‚ö†Ô∏è  Warning: Not on development branch (current: ${branch})`,\n          'warning'\n        );\n        this.log('   Switch to development first: git checkout development', 'warning');\n        throw new Error('Must be on development branch');\n      }\n      this.log('‚úÖ On development branch', 'success');\n      this.log('');\n    } catch (error) {\n      if (error instanceof Error && error.message === 'Must be on development branch') {\n        throw error;\n      }\n      throw new Error('Failed to check git branch');\n    }\n  }\n\n  private async checkDependencies(): Promise<void> {\n    this.log('üì¶ Checking dependencies...', 'info');\n\n    for (const dep of this.requiredDependencies) {\n      try {\n        this.exec(`npm list ${dep}`, { silent: true });\n        this.log(`  ‚úÖ ${dep}`, 'success');\n      } catch {\n        this.log(`  ‚ùå ${dep} not found`, 'error');\n        this.log('   Run: npm install', 'error');\n        throw new Error(`Missing dependency: ${dep}`);\n      }\n    }\n\n    this.log('‚úÖ Dependencies installed', 'success');\n    this.log('');\n  }\n\n  private checkCICDVariables(): void {\n    this.log('üîê Checking CI/CD variables...', 'info');\n    this.log('');\n    this.log('Required variables (set in GitLab UI):');\n    for (const varName of this.requiredEnvVars) {\n      const exists = !!process.env[varName];\n      const status = exists ? '‚úÖ' : '‚ùå';\n      this.log(`  ${status} ${varName}${exists ? ' (set)' : ' (missing)'}`);\n    }\n    this.log('');\n    this.log('To set these:');\n    this.log('  1. Go to: Settings ‚Üí CI/CD ‚Üí Variables');\n    this.log('  2. Add each variable');\n    this.log('  3. Mark as \\'Protected\\' and \\'Masked\\'');\n    this.log('');\n  }\n\n  private checkWebhooks(): void {\n    this.log('üîó Webhooks to configure:', 'info');\n    this.log('');\n    this.log('Webhook 1: Milestone Events');\n    this.log('  URL: https://your-webhook-endpoint.com/milestone');\n    this.log('  Trigger: Milestone events');\n    this.log('');\n    this.log('Webhook 2: Push Events');\n    this.log('  URL: https://your-webhook-endpoint.com/push');\n    this.log('  Trigger: Push events (development branch)');\n    this.log('');\n    this.log('To configure:');\n    this.log('  Go to: Settings ‚Üí Webhooks');\n    this.log('');\n  }\n\n  private async runTests(): Promise<void> {\n    this.log('üß™ Running tests...', 'info');\n    try {\n      this.exec('npm test', { silent: false });\n      this.log('‚úÖ All tests passing', 'success');\n    } catch {\n      this.log('‚ùå Tests failed', 'error');\n      throw new Error('Tests failed');\n    }\n  }\n}\n\n/**\n * Main Setup Command\n */\nexport const setupCommand = new Command('setup')\n  .description('Setup OSSA project tools and automation')\n  .option('-f, --force', 'Force overwrite existing configuration')\n  .option('-v, --verbose', 'Verbose output');\n\n/**\n * Branch Protection Subcommand\n */\nconst branchProtectionSubcommand = new Command('branch-protection')\n  .alias('bp')\n  .description('Setup git hooks to prevent checking out main/development locally')\n  .option('-f, --force', 'Force overwrite existing hooks')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options: { force?: boolean; verbose?: boolean }) => {\n    try {\n      const validated = SetupOptionsSchema.parse(options);\n      const service = new BranchProtectionService();\n      await service.setup(validated);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.error(chalk.red('Validation error:'), error.issues);\n        process.exit(1);\n      }\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Release Automation Subcommand\n */\nconst releaseAutomationSubcommand = new Command('release-automation')\n  .alias('ra')\n  .description('Setup release automation (dependencies, CI/CD variables, webhooks)')\n  .option('-f, --force', 'Force setup even if checks fail')\n  .option('-v, --verbose', 'Verbose output')\n  .action(async (options: { force?: boolean; verbose?: boolean }) => {\n    try {\n      const validated = SetupOptionsSchema.parse(options);\n      const service = new ReleaseAutomationService();\n      await service.setup(validated);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.error(chalk.red('Validation error:'), error.issues);\n        process.exit(1);\n      }\n      console.error(chalk.red('Error:'), error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Register subcommands\nsetupCommand.addCommand(branchProtectionSubcommand);\nsetupCommand.addCommand(releaseAutomationSubcommand);\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/sync.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/commands/validate.command.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/cli/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/di-container.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/repositories/manifest.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/repositories/schema.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/generation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/github-sync/github-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/github-sync/gitlab-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/github-sync/schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/github-sync/sync.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/gitlab-agent.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/migration.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/base-crud.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/merge-request.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/milestone.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/release.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/schemas/release.schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/tag.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/release-automation/webhook.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'project' is assigned a value but never used.","line":50,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'project' is assigned a value but never used.","line":117,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'project' is assigned a value but never used.","line":145,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Webhook Service\n * Handles GitLab webhooks with Zod validation\n */\n\nimport {\n  MilestoneWebhookPayloadSchema,\n  PushWebhookPayloadSchema,\n  WebhookResponseSchema,\n  type MilestoneWebhookPayload,\n  type PushWebhookPayload,\n  type WebhookResponse,\n} from './schemas/release.schema.js';\nimport { ReleaseService } from './release.service.js';\nimport { MilestoneService } from './milestone.service.js';\nimport { TagService } from './tag.service.js';\nimport { MergeRequestService } from './merge-request.service.js';\n\n/**\n * Webhook Service\n * DRY: Centralized webhook handling\n */\nexport class WebhookService {\n  private releaseService: ReleaseService;\n  private milestoneService: MilestoneService;\n  private tagService: TagService;\n  private mergeRequestService: MergeRequestService;\n\n  constructor(\n    gitlabToken: string,\n    projectId: string | number = process.env.CI_PROJECT_ID || ''\n  ) {\n    this.releaseService = new ReleaseService(gitlabToken, projectId);\n    this.milestoneService = new MilestoneService(gitlabToken, projectId);\n    this.tagService = new TagService(gitlabToken, projectId);\n    this.mergeRequestService = new MergeRequestService(gitlabToken, projectId);\n  }\n\n  /**\n   * Handle milestone webhook\n   */\n  async handleMilestoneWebhook(\n    payload: unknown\n  ): Promise<WebhookResponse> {\n    try {\n      // Validate payload with Zod\n      const validated = MilestoneWebhookPayloadSchema.parse(payload);\n      const actions: WebhookResponse['actions'] = [];\n\n      const { project, object_attributes: milestone } = validated;\n\n      // Determine if this is a create or close event\n      const isNewMilestone =\n        milestone.state === 'active' &&\n        new Date(milestone.created_at).getTime() ===\n          new Date(milestone.updated_at).getTime();\n\n      if (isNewMilestone) {\n        // Milestone created - create dev tag and branch\n        const action = await this.handleMilestoneCreate(validated);\n        if (action) actions.push(action);\n      } else if (milestone.state === 'closed') {\n        // Milestone closed - create RC\n        const action = await this.handleMilestoneClose(validated);\n        if (action) actions.push(action);\n      }\n\n      return WebhookResponseSchema.parse({\n        success: true,\n        message: `Milestone ${milestone.title} processed`,\n        actions,\n      });\n    } catch (error) {\n      return WebhookResponseSchema.parse({\n        success: false,\n        message: `Webhook processing failed: ${error}`,\n        actions: [],\n      });\n    }\n  }\n\n  /**\n   * Handle push webhook\n   */\n  async handlePushWebhook(payload: unknown): Promise<WebhookResponse> {\n    try {\n      // Validate payload with Zod\n      const validated = PushWebhookPayloadSchema.parse(payload);\n      const actions: WebhookResponse['actions'] = [];\n\n      // Only process development branch pushes\n      if (validated.ref === 'refs/heads/development') {\n        const action = await this.handleDevelopmentPush(validated);\n        if (action) actions.push(action);\n      }\n\n      return WebhookResponseSchema.parse({\n        success: true,\n        message: 'Push webhook processed',\n        actions,\n      });\n    } catch (error) {\n      return WebhookResponseSchema.parse({\n        success: false,\n        message: `Webhook processing failed: ${error}`,\n        actions: [],\n      });\n    }\n  }\n\n  /**\n   * Handle milestone creation\n   */\n  private async handleMilestoneCreate(\n    payload: MilestoneWebhookPayload\n  ): Promise<{ type: string; status: string; details?: Record<string, unknown> } | null> {\n    const { project, object_attributes: milestone } = payload;\n    const version = milestone.title.replace(/^v/, '');\n\n    // Create initial dev tag\n    const devTag = `v${version}-dev.0`;\n    await this.tagService.create({\n      name: devTag,\n      ref: 'development',\n      message: `Initial dev tag for ${milestone.title}`,\n    });\n\n    return {\n      type: 'milestone_created',\n      status: 'success',\n      details: {\n        milestoneId: milestone.id,\n        tag: devTag,\n        version,\n      },\n    };\n  }\n\n  /**\n   * Handle milestone closure\n   */\n  private async handleMilestoneClose(\n    payload: MilestoneWebhookPayload\n  ): Promise<{ type: string; status: string; details?: Record<string, unknown> } | null> {\n    const { project, object_attributes: milestone } = payload;\n    const version = milestone.title.replace(/^v/, '');\n\n    // Get milestone statistics\n    const milestoneData = await this.milestoneService.read(milestone.id);\n    if (!milestoneData) {\n      throw new Error(`Milestone ${milestone.id} not found`);\n    }\n\n    // Check all issues are closed\n    if (milestoneData.statistics.openIssues > 0) {\n      throw new Error(\n        `Cannot create RC: ${milestoneData.statistics.openIssues} issues still open`\n      );\n    }\n\n    // Create RC tag\n    const rcTag = `v${version}-rc.1`;\n    await this.tagService.create({\n      name: rcTag,\n      ref: 'development',\n      message: `Release candidate for ${milestone.title}`,\n    });\n\n    // Create MR: development ‚Üí main\n    const mr = await this.mergeRequestService.create({\n      sourceBranch: 'development',\n      targetBranch: 'main',\n      title: `Release ${milestone.title}`,\n      description: `Release candidate ${rcTag} for milestone ${milestone.title}`,\n      labels: ['release', 'automation'],\n      milestoneId: milestone.id,\n    });\n\n    return {\n      type: 'milestone_closed',\n      status: 'success',\n      details: {\n        milestoneId: milestone.id,\n        rcTag,\n        mergeRequestId: mr.id,\n      },\n    };\n  }\n\n  /**\n   * Handle development branch push\n   */\n  private async handleDevelopmentPush(\n    payload: PushWebhookPayload\n  ): Promise<{ type: string; status: string; details?: Record<string, unknown> } | null> {\n    // Auto-increment dev tag\n    // This would be implemented based on current version detection\n    // For now, return success\n\n    return {\n      type: 'dev_tag_incremented',\n      status: 'success',\n      details: {\n        branch: payload.ref,\n        commits: payload.commits.length,\n      },\n    };\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/runtime/claude/capability-mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/runtime/claude/claude-adapter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":268,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":268,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Claude Runtime Adapter\n * Runs OSSA agents using Anthropic's Claude API\n */\n\nimport Anthropic from '@anthropic-ai/sdk';\nimport { ManifestParser } from './manifest-parser.js';\nimport { CapabilityMapper } from './capability-mapper.js';\nimport type {\n  OssaManifestWithAnthropic,\n  ClaudeMessage,\n  ClaudeRunOptions,\n  ClaudeAdapterConfig,\n  AgentInfo,\n  ToolHandler,\n  ClaudeTool,\n} from './types.js';\n\n/**\n * Claude adapter for executing OSSA agents\n */\nexport class ClaudeAdapter {\n  private client: Anthropic;\n  private parser: ManifestParser;\n  private mapper: CapabilityMapper;\n  private messages: ClaudeMessage[] = [];\n  private conversationHistory: Anthropic.MessageParam[] = [];\n\n  constructor(config: ClaudeAdapterConfig) {\n    // Initialize Anthropic client\n    this.client = new Anthropic({\n      apiKey: config.apiKey || process.env.ANTHROPIC_API_KEY,\n    });\n\n    // Initialize parser and mapper\n    this.parser = new ManifestParser(config.manifest);\n    this.mapper = new CapabilityMapper();\n\n    // Validate manifest\n    const validation = this.parser.validate();\n    if (!validation.valid) {\n      throw new Error(\n        `Invalid OSSA manifest: ${validation.errors.join(', ')}`\n      );\n    }\n\n    // Check if Anthropic integration is enabled\n    if (!this.parser.isAnthropicEnabled()) {\n      console.warn(\n        'Warning: Anthropic extension is disabled in manifest'\n      );\n    }\n\n    // Initialize tools\n    this.initializeTools();\n  }\n\n  /**\n   * Initialize tools from manifest\n   */\n  private initializeTools(): void {\n    // Map Claude extension tools first (highest priority)\n    const anthropicExt = this.parser.getAnthropicExtension();\n    if (anthropicExt?.tools) {\n      this.mapper.mapClaudeTools(anthropicExt.tools);\n    }\n\n    // Map OSSA spec tools\n    const specTools = this.parser.getSpecTools();\n    this.mapper.mapOssaTools(specTools);\n\n    // Map MCP capabilities if any\n    for (const tool of specTools) {\n      if (tool.type === 'mcp' && tool.capabilities) {\n        this.mapper.mapMcpCapabilities(tool.capabilities);\n      } else if (tool.type === 'http') {\n        this.mapper.mapHttpTool(tool);\n      }\n    }\n  }\n\n  /**\n   * Register a tool handler\n   */\n  registerToolHandler(name: string, handler: ToolHandler): boolean {\n    return this.mapper.registerToolHandler(name, handler);\n  }\n\n  /**\n   * Execute a tool call\n   */\n  private async executeTool(\n    name: string,\n    input: Record<string, unknown>\n  ): Promise<string> {\n    const tool = this.mapper.getTool(name);\n    if (!tool) {\n      return JSON.stringify({\n        error: `Tool '${name}' not found`,\n      });\n    }\n\n    if (tool.handler) {\n      try {\n        return await tool.handler(input);\n      } catch (error) {\n        return JSON.stringify({\n          error: `Error executing ${name}: ${error instanceof Error ? error.message : String(error)}`,\n        });\n      }\n    }\n\n    // Default: return placeholder response\n    return JSON.stringify({\n      message: `Tool '${name}' executed`,\n      input,\n      note: 'No handler registered for this tool',\n    });\n  }\n\n  /**\n   * Initialize the conversation\n   */\n  initialize(): void {\n    this.messages = [];\n    this.conversationHistory = [];\n  }\n\n  /**\n   * Send a message and get a response\n   */\n  async chat(\n    userMessage: string,\n    options?: ClaudeRunOptions\n  ): Promise<string> {\n    // Add user message to history\n    this.conversationHistory.push({\n      role: 'user',\n      content: userMessage,\n    });\n\n    const tools = this.mapper.getClaudeTools();\n    let turnCount = 0;\n    const maxTurns = options?.maxTurns || 10;\n\n    while (turnCount < maxTurns) {\n      turnCount++;\n\n      if (options?.verbose) {\n        console.log(`\\n[Turn ${turnCount}/${maxTurns}]`);\n      }\n\n      // Call Claude API\n      const response = await this.client.messages.create({\n        model: this.parser.getModel(),\n        max_tokens: this.parser.getMaxTokens(),\n        temperature: this.parser.getTemperature(),\n        system: this.parser.getSystemPrompt(),\n        messages: this.conversationHistory,\n        tools: tools.length > 0 ? tools : undefined,\n        stop_sequences: this.parser.getStopSequences(),\n      });\n\n      if (options?.verbose) {\n        console.log(\n          `  Model: ${response.model}, Stop: ${response.stop_reason}`\n        );\n        console.log(\n          `  Tokens: ${response.usage.input_tokens} in, ${response.usage.output_tokens} out`\n        );\n      }\n\n      // Add assistant response to history\n      this.conversationHistory.push({\n        role: 'assistant',\n        content: response.content,\n      });\n\n      // Check if we need to execute tools\n      const toolUses = response.content.filter(\n        (block) => block.type === 'tool_use'\n      );\n\n      if (toolUses.length > 0) {\n        if (options?.verbose) {\n          console.log(`  [Executing ${toolUses.length} tool(s)...]`);\n        }\n\n        // Execute all tool calls\n        const toolResults: Array<{\n          type: 'tool_result';\n          tool_use_id: string;\n          content: string;\n        }> = [];\n\n        for (const toolUse of toolUses) {\n          if (toolUse.type !== 'tool_use') continue;\n\n          const { id, name, input } = toolUse;\n\n          if (options?.verbose) {\n            console.log(\n              `    ‚Üí ${name}(${JSON.stringify(input).substring(0, 100)}...)`\n            );\n          }\n\n          const result = await this.executeTool(\n            name,\n            input as Record<string, unknown>\n          );\n\n          if (options?.verbose) {\n            console.log(\n              `    ‚Üê ${result.substring(0, 100)}${result.length > 100 ? '...' : ''}`\n            );\n          }\n\n          toolResults.push({\n            type: 'tool_result',\n            tool_use_id: id,\n            content: result,\n          });\n        }\n\n        // Add tool results to conversation\n        this.conversationHistory.push({\n          role: 'user',\n          content: toolResults,\n        });\n\n        // Continue the loop to get final response\n        continue;\n      }\n\n      // Check if we have a text response\n      const textBlocks = response.content.filter(\n        (block) => block.type === 'text'\n      );\n\n      if (textBlocks.length > 0) {\n        return textBlocks\n          .map((block) => (block.type === 'text' ? block.text : ''))\n          .join('\\n');\n      }\n\n      // No text and no tool calls - unexpected\n      if (response.stop_reason === 'end_turn') {\n        return '';\n      }\n\n      // Max tokens or stop sequence reached\n      if (\n        response.stop_reason === 'max_tokens' ||\n        response.stop_reason === 'stop_sequence'\n      ) {\n        return '[Response truncated due to length limit]';\n      }\n    }\n\n    return '[Max turns reached without completion]';\n  }\n\n  /**\n   * Stream a response (for future implementation)\n   */\n  async chatStream(\n    userMessage: string,\n    options?: ClaudeRunOptions\n  ): Promise<AsyncIterable<string>> {\n    // Add user message to history\n    this.conversationHistory.push({\n      role: 'user',\n      content: userMessage,\n    });\n\n    const tools = this.mapper.getClaudeTools();\n\n    const stream = await this.client.messages.stream({\n      model: this.parser.getModel(),\n      max_tokens: this.parser.getMaxTokens(),\n      temperature: this.parser.getTemperature(),\n      system: this.parser.getSystemPrompt(),\n      messages: this.conversationHistory,\n      tools: tools.length > 0 ? tools : undefined,\n    });\n\n    // Return async generator\n    return (async function* () {\n      for await (const chunk of stream) {\n        if (\n          chunk.type === 'content_block_delta' &&\n          chunk.delta.type === 'text_delta'\n        ) {\n          yield chunk.delta.text;\n        }\n      }\n    })();\n  }\n\n  /**\n   * Get agent information\n   */\n  getAgentInfo(): AgentInfo {\n    const metadata = this.parser.getMetadata();\n    const tools = Array.from(this.mapper.getTools().keys());\n\n    return {\n      name: metadata.name,\n      model: this.parser.getModel(),\n      tools,\n      provider: 'anthropic',\n    };\n  }\n\n  /**\n   * Get conversation history\n   */\n  getConversationHistory(): Anthropic.MessageParam[] {\n    return this.conversationHistory;\n  }\n\n  /**\n   * Clear conversation history\n   */\n  clearHistory(): void {\n    this.conversationHistory = [];\n    this.messages = [];\n  }\n\n  /**\n   * Get available tools\n   */\n  getTools(): ClaudeTool[] {\n    return this.mapper.getClaudeTools();\n  }\n\n  /**\n   * Get the Anthropic client (for advanced usage)\n   */\n  getClient(): Anthropic {\n    return this.client;\n  }\n\n  /**\n   * Get the manifest parser\n   */\n  getParser(): ManifestParser {\n    return this.parser;\n  }\n\n  /**\n   * Get the capability mapper\n   */\n  getMapper(): CapabilityMapper {\n    return this.mapper;\n  }\n\n  /**\n   * Create a Claude adapter from a manifest file\n   */\n  static async fromFile(\n    manifestPath: string,\n    apiKey?: string\n  ): Promise<ClaudeAdapter> {\n    const fs = await import('fs/promises');\n    const manifestContent = await fs.readFile(manifestPath, 'utf-8');\n    const manifest = JSON.parse(\n      manifestContent\n    ) as OssaManifestWithAnthropic;\n\n    return new ClaudeAdapter({\n      manifest,\n      apiKey,\n    });\n  }\n\n  /**\n   * Create a Claude adapter from a manifest object\n   */\n  static fromManifest(\n    manifest: OssaManifestWithAnthropic,\n    apiKey?: string\n  ): ClaudeAdapter {\n    return new ClaudeAdapter({\n      manifest,\n      apiKey,\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/runtime/claude/manifest-parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/runtime/claude/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/runtime/openai.adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/anthropic.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/autogen.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/crewai.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/cursor.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/langchain.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/langflow.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/langgraph.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/llamaindex.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/openai.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/services/validators/vercel-ai.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/types/openapi-extensions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/flux423/Sites/LLM/openstandardagents/src/utils/version.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]