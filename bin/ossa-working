#!/usr/bin/env node

/**
 * OSSA Working CLI v0.1.8 - Functional Implementation
 * Replaces fantasy implementations with actual working functionality
 * 
 * @version 0.1.8
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync, readdirSync } from 'fs';
import { join, dirname, resolve, basename } from 'path';
import { fileURLToPath } from 'url';
import { spawn, execSync } from 'child_process';
import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

class OSSAWorkingCLI {
  constructor() {
    this.version = '0.1.8';
    this.rootPath = resolve(__dirname, '..');
    this.examplesPath = join(this.rootPath, 'examples');
    this.libPath = join(this.rootPath, 'lib');
    
    // Available services (real implementations only)
    this.services = {
      'validation-server': {
        port: 3003,
        script: join(this.rootPath, 'services', 'validation-server.js'),
        description: 'OSSA validation API server'
      }
    };
    
    this.commands = {
      'version': this.showVersion.bind(this),
      'help': this.showHelp.bind(this),
      'validate': this.validateAgent.bind(this),
      'create': this.createAgent.bind(this),
      'list': this.listAgents.bind(this),
      'serve': this.startValidationServer.bind(this),
      'demo': this.runDemo.bind(this),
      'test': this.runTests.bind(this),
      'status': this.checkStatus.bind(this),
      'examples': this.showExamples.bind(this)
    };
  }

  /**
   * Main CLI entry point
   */
  async run() {
    const args = process.argv.slice(2);
    const command = args[0] || 'help';
    const options = args.slice(1);

    console.log(`ü§ñ OSSA Working CLI v${this.version}`);
    console.log(`   Open Standards for Scalable Agents - Functional Implementation\n`);

    try {
      if (this.commands[command]) {
        await this.commands[command](options);
      } else {
        console.error(`‚ùå Unknown command: ${command}`);
        console.log('   Run "ossa-working help" for available commands\n');
        process.exit(1);
      }
    } catch (error) {
      console.error(`‚ùå Command failed: ${error.message}`);
      process.exit(1);
    }
  }

  /**
   * Show version information
   */
  async showVersion(options) {
    console.log(`Version: ${this.version}`);
    console.log(`Root Path: ${this.rootPath}`);
    console.log(`Node.js: ${process.version}`);
    
    // Check for available examples
    const exampleAgents = this.findAgentFiles();
    console.log(`Available Agents: ${exampleAgents.length}`);
    
    // Check for working services
    const workingServices = Object.keys(this.services).filter(name => 
      existsSync(this.services[name].script)
    );
    console.log(`Working Services: ${workingServices.length}/${Object.keys(this.services).length}`);
  }

  /**
   * Show help information
   */
  async showHelp(options) {
    console.log('Available Commands:');
    console.log('');
    console.log('  version              Show version and system information');
    console.log('  validate <file>      Validate OSSA agent specification');
    console.log('  create <name>        Create new OSSA agent from template');
    console.log('  list                 List all available agents');
    console.log('  serve                Start validation server on port 3003');
    console.log('  demo                 Run working demonstration');
    console.log('  test                 Run validation tests');
    console.log('  status               Check status of services and agents');
    console.log('  examples             Show available examples');
    console.log('  help                 Show this help message');
    console.log('');
    console.log('Examples:');
    console.log('  ossa-working validate ./examples/.agents/test-agent/agent.yml');
    console.log('  ossa-working create my-new-agent');
    console.log('  ossa-working serve');
    console.log('  ossa-working demo');
    console.log('');
    console.log('Features:');
    console.log('  ‚úÖ Real agent validation (not mock)');
    console.log('  ‚úÖ Working validation server');
    console.log('  ‚úÖ Agent creation from templates');
    console.log('  ‚úÖ End-to-end demonstrations');
    console.log('  ‚úÖ No fantasy claims - only working functionality');
  }

  /**
   * Validate OSSA agent specification
   */
  async validateAgent(options) {
    const filePath = options[0];
    if (!filePath) {
      throw new Error('Please specify a file to validate');
    }

    const fullPath = resolve(filePath);
    if (!existsSync(fullPath)) {
      throw new Error(`File not found: ${filePath}`);
    }

    console.log(`üîç Validating: ${filePath}`);
    
    try {
      const content = readFileSync(fullPath, 'utf8');
      let data;
      
      if (fullPath.endsWith('.json')) {
        data = JSON.parse(content);
      } else {
        data = parseYaml(content);
      }

      // Basic validation
      const validation = this.performBasicValidation(data);
      
      if (validation.valid) {
        console.log(`‚úÖ Valid OSSA agent specification`);
        console.log(`   API Version: ${data.apiVersion || 'Not specified'}`);
        console.log(`   Agent Name: ${data.spec?.agent?.name || 'Not specified'}`);
        console.log(`   Capabilities: ${data.spec?.capabilities?.length || 0}`);
        
        if (data.spec?.frameworks) {
          const enabledFrameworks = Object.keys(data.spec.frameworks)
            .filter(f => data.spec.frameworks[f]?.enabled);
          console.log(`   Frameworks: ${enabledFrameworks.join(', ') || 'None'}`);
        }
        
        if (validation.warnings.length > 0) {
          console.log(`\n‚ö†Ô∏è  Warnings:`);
          validation.warnings.forEach(warning => 
            console.log(`   - ${warning}`)
          );
        }
      } else {
        console.log(`‚ùå Invalid OSSA agent specification`);
        console.log(`\nErrors:`);
        validation.errors.forEach(error => 
          console.log(`   - ${error}`)
        );
      }
      
      return validation.valid;
    } catch (error) {
      console.log(`‚ùå Validation failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Create new OSSA agent from template
   */
  async createAgent(options) {
    const agentName = options[0];
    if (!agentName) {
      throw new Error('Please specify an agent name');
    }

    // Validate agent name
    if (!/^[a-z][a-z0-9_-]*[a-z0-9]$/.test(agentName)) {
      throw new Error('Agent name must be lowercase, start with a letter, and contain only letters, numbers, hyphens, and underscores');
    }

    const agentDir = join(process.cwd(), `.agents/${agentName}`);
    
    if (existsSync(agentDir)) {
      throw new Error(`Agent directory already exists: ${agentDir}`);
    }

    console.log(`üìù Creating agent: ${agentName}`);
    console.log(`   Directory: ${agentDir}`);

    // Create directory structure
    mkdirSync(agentDir, { recursive: true });
    mkdirSync(join(agentDir, 'data'), { recursive: true });
    mkdirSync(join(agentDir, 'schemas'), { recursive: true });

    // Create agent specification
    const agentSpec = this.generateAgentTemplate(agentName);
    writeFileSync(join(agentDir, 'agent.yml'), stringifyYaml(agentSpec));

    // Create basic OpenAPI spec
    const openApiSpec = this.generateOpenAPITemplate(agentName);
    writeFileSync(join(agentDir, 'openapi.yaml'), stringifyYaml(openApiSpec));

    // Create README
    const readme = this.generateReadmeTemplate(agentName);
    writeFileSync(join(agentDir, 'README.md'), readme);

    console.log(`‚úÖ Agent created successfully!`);
    console.log(`\nGenerated files:`);
    console.log(`   - agent.yml         Agent specification`);
    console.log(`   - openapi.yaml      API specification`);
    console.log(`   - README.md         Documentation`);
    console.log(`   - data/             Training data directory`);
    console.log(`   - schemas/          JSON schemas directory`);
    console.log(`\nNext steps:`);
    console.log(`   1. Edit agent.yml to customize your agent`);
    console.log(`   2. Add capabilities and expertise descriptions`);
    console.log(`   3. Update openapi.yaml with your API endpoints`);
    console.log(`   4. Validate with: ossa-working validate ${agentDir}/agent.yml`);
  }

  /**
   * List all available agents
   */
  async listAgents(options) {
    console.log(`üîç Scanning for OSSA agents...\n`);
    
    const agentFiles = this.findAgentFiles();
    
    if (agentFiles.length === 0) {
      console.log('No OSSA agents found.');
      console.log('Create one with: ossa-working create <agent-name>');
      return;
    }

    console.log(`Found ${agentFiles.length} agents:\n`);
    
    for (const agentFile of agentFiles) {
      try {
        const content = readFileSync(agentFile, 'utf8');
        const data = parseYaml(content);
        
        const relativePath = agentFile.replace(process.cwd(), '.');
        const agentName = data.spec?.agent?.name || basename(dirname(agentFile));
        const capabilities = data.spec?.capabilities?.length || 0;
        const frameworks = data.spec?.frameworks ? 
          Object.keys(data.spec.frameworks).filter(f => data.spec.frameworks[f]?.enabled) : [];
        
        console.log(`üìã ${agentName}`);
        console.log(`   Path: ${relativePath}`);
        console.log(`   Capabilities: ${capabilities}`);
        console.log(`   Frameworks: ${frameworks.join(', ') || 'None'}`);
        console.log(`   API Version: ${data.apiVersion || 'Not specified'}`);
        console.log();
      } catch (error) {
        console.log(`‚ùå Error reading ${agentFile}: ${error.message}`);
      }
    }
  }

  /**
   * Start validation server
   */
  async startValidationServer(options) {
    const service = this.services['validation-server'];
    
    if (!existsSync(service.script)) {
      console.log(`‚ùå Validation server script not found: ${service.script}`);
      console.log('   This is a working implementation - no fantasy services');
      return;
    }

    console.log(`üöÄ Starting validation server on port ${service.port}...`);
    console.log(`   Script: ${service.script}`);
    
    try {
      // Check if port is already in use
      const isPortInUse = await this.checkPortInUse(service.port);
      if (isPortInUse) {
        console.log(`‚úÖ Validation server already running on port ${service.port}`);
        await this.testValidationServer(service.port);
        return;
      }

      // Start the server
      const serverProcess = spawn('node', [service.script], {
        stdio: 'inherit',
        env: { ...process.env, PORT: service.port }
      });

      // Wait a moment for server to start
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Test server
      console.log(`\nüß™ Testing server...`);
      await this.testValidationServer(service.port);
      
      console.log(`\n‚úÖ Validation server started successfully!`);
      console.log(`   Health check: http://localhost:${service.port}/health`);
      console.log(`   API docs: http://localhost:${service.port}/api-docs`);
      console.log(`\n   Press Ctrl+C to stop the server`);
      
    } catch (error) {
      console.log(`‚ùå Failed to start validation server: ${error.message}`);
    }
  }

  /**
   * Run working demonstration
   */
  async runDemo(options) {
    console.log(`üé≠ Running OSSA Working Demonstration\n`);
    console.log(`This demo shows ONLY working functionality - no fantasy claims!\n`);

    // 1. Show available agents
    console.log(`1Ô∏è‚É£  Available Agents:`);
    const agentFiles = this.findAgentFiles();
    if (agentFiles.length > 0) {
      console.log(`   Found ${agentFiles.length} agents`);
      agentFiles.slice(0, 3).forEach(file => {
        const relativePath = file.replace(this.rootPath, '.');
        console.log(`   - ${relativePath}`);
      });
    } else {
      console.log(`   No agents found - creating demo agent...`);
      await this.createAgent(['demo-agent']);
      console.log(`   ‚úÖ Demo agent created`);
    }

    // 2. Validate an agent
    console.log(`\n2Ô∏è‚É£  Agent Validation:`);
    const testAgent = agentFiles[0] || join(process.cwd(), '.agents/demo-agent/agent.yml');
    if (existsSync(testAgent)) {
      const isValid = await this.validateAgent([testAgent]);
      console.log(`   Validation result: ${isValid ? 'PASS' : 'FAIL'}`);
    } else {
      console.log(`   No agent available for validation`);
    }

    // 3. Check validation server
    console.log(`\n3Ô∏è‚É£  Validation Server:`);
    const port = 3003;
    const serverRunning = await this.checkPortInUse(port);
    if (serverRunning) {
      console.log(`   ‚úÖ Server running on port ${port}`);
      await this.testValidationServer(port);
    } else {
      console.log(`   ‚ö†Ô∏è  Server not running - start with: ossa-working serve`);
    }

    // 4. Show real capabilities
    console.log(`\n4Ô∏è‚É£  Real Capabilities Summary:`);
    console.log(`   ‚úÖ Agent validation - functional`);
    console.log(`   ‚úÖ Agent creation - functional`);
    console.log(`   ‚úÖ Agent listing - functional`);
    console.log(`   ‚úÖ Validation server - ${serverRunning ? 'running' : 'available'}`);
    console.log(`   ‚ùå No fantasy port claims (4021-4040)`);
    console.log(`   ‚ùå No non-existent services`);
    console.log(`   ‚úÖ Only working implementations included`);

    console.log(`\nüéâ Demo completed - all features are functional!`);
  }

  /**
   * Run validation tests
   */
  async runTests(options) {
    console.log(`üß™ Running OSSA Validation Tests\n`);
    
    const testResults = [];
    
    // Test 1: Agent validation
    console.log(`1Ô∏è‚É£  Testing agent validation...`);
    const agentFiles = this.findAgentFiles();
    if (agentFiles.length > 0) {
      let passCount = 0;
      for (const agentFile of agentFiles.slice(0, 3)) {
        try {
          const isValid = await this.validateAgent([agentFile]);
          if (isValid) passCount++;
        } catch (error) {
          console.log(`   Error: ${error.message}`);
        }
      }
      testResults.push({
        test: 'Agent Validation',
        passed: passCount,
        total: Math.min(agentFiles.length, 3),
        success: passCount > 0
      });
    }

    // Test 2: Agent creation
    console.log(`\n2Ô∏è‚É£  Testing agent creation...`);
    try {
      const testAgentName = 'test-agent-' + Date.now();
      await this.createAgent([testAgentName]);
      
      // Validate created agent
      const createdAgentPath = join(process.cwd(), `.agents/${testAgentName}/agent.yml`);
      const isValid = await this.validateAgent([createdAgentPath]);
      
      testResults.push({
        test: 'Agent Creation',
        passed: isValid ? 1 : 0,
        total: 1,
        success: isValid
      });
    } catch (error) {
      console.log(`   Error: ${error.message}`);
      testResults.push({
        test: 'Agent Creation',
        passed: 0,
        total: 1,
        success: false
      });
    }

    // Test 3: Validation server
    console.log(`\n3Ô∏è‚É£  Testing validation server...`);
    const serverRunning = await this.checkPortInUse(3003);
    testResults.push({
      test: 'Validation Server',
      passed: serverRunning ? 1 : 0,
      total: 1,
      success: serverRunning
    });

    // Summary
    console.log(`\nüìä Test Results:`);
    console.log(`${'='  .repeat(50)}`);
    let totalPassed = 0;
    let totalTests = 0;
    
    for (const result of testResults) {
      const status = result.success ? '‚úÖ PASS' : '‚ùå FAIL';
      console.log(`   ${result.test}: ${status} (${result.passed}/${result.total})`);
      totalPassed += result.passed;
      totalTests += result.total;
    }
    
    console.log(`${'='  .repeat(50)}`);
    console.log(`   Overall: ${totalPassed}/${totalTests} tests passed`);
    console.log(`   Success Rate: ${Math.round((totalPassed / totalTests) * 100)}%`);
    
    return totalPassed === totalTests;
  }

  /**
   * Check status of services and agents
   */
  async checkStatus(options) {
    console.log(`üìä OSSA System Status\n`);

    // Check agents
    const agentFiles = this.findAgentFiles();
    console.log(`ü§ñ Agents:`);
    console.log(`   Available: ${agentFiles.length}`);
    
    if (agentFiles.length > 0) {
      let validAgents = 0;
      for (const agentFile of agentFiles) {
        try {
          const content = readFileSync(agentFile, 'utf8');
          const data = parseYaml(content);
          const validation = this.performBasicValidation(data);
          if (validation.valid) validAgents++;
        } catch (error) {
          // Skip invalid agents
        }
      }
      console.log(`   Valid: ${validAgents}/${agentFiles.length}`);
    }

    // Check services
    console.log(`\nüîß Services:`);
    for (const [name, service] of Object.entries(this.services)) {
      const scriptExists = existsSync(service.script);
      const isRunning = await this.checkPortInUse(service.port);
      
      console.log(`   ${name}:`);
      console.log(`     Script: ${scriptExists ? '‚úÖ' : '‚ùå'} ${service.script}`);
      console.log(`     Running: ${isRunning ? '‚úÖ' : '‚ùå'} Port ${service.port}`);
      console.log(`     Description: ${service.description}`);
    }

    // System info
    console.log(`\nüíª System:`);
    console.log(`   Node.js: ${process.version}`);
    console.log(`   OSSA CLI: v${this.version}`);
    console.log(`   Root Path: ${this.rootPath}`);
    console.log(`   Working Directory: ${process.cwd()}`);
  }

  /**
   * Show available examples
   */
  async showExamples(options) {
    console.log(`üìö OSSA Examples and Templates\n`);
    
    // Check for example agents
    const examplePath = join(this.rootPath, 'examples', '.agents');
    if (existsSync(examplePath)) {
      console.log(`üéØ Example Agents (${examplePath}):`);
      
      const exampleAgents = this.findAgentFiles(examplePath);
      for (const agentFile of exampleAgents) {
        try {
          const content = readFileSync(agentFile, 'utf8');
          const data = parseYaml(content);
          
          const relativePath = agentFile.replace(this.rootPath, '.');
          const agentName = data.spec?.agent?.name || basename(dirname(agentFile));
          
          console.log(`   üìã ${agentName}`);
          console.log(`      Path: ${relativePath}`);
          console.log(`      Expertise: ${data.spec?.agent?.expertise || 'Not specified'}`);
          console.log(`      Capabilities: ${data.spec?.capabilities?.length || 0}`);
          console.log();
        } catch (error) {
          console.log(`   ‚ùå Error reading ${agentFile}: ${error.message}`);
        }
      }
    } else {
      console.log(`‚ö†Ô∏è  No example agents found in ${examplePath}`);
    }

    // Show creation command
    console.log(`\nüöÄ Create New Agent:`);
    console.log(`   ossa-working create <agent-name>`);
    console.log(`\nüìñ Validate Agent:`);
    console.log(`   ossa-working validate <path-to-agent.yml>`);
    console.log(`\nüîç List All Agents:`);
    console.log(`   ossa-working list`);
  }

  // Utility methods

  /**
   * Find all agent files in directory
   */
  findAgentFiles(searchPath = null) {
    const files = [];
    const basePath = searchPath || process.cwd();
    
    try {
      // Look for .agents directories
      const agentDirs = [];
      this.findDirectories(basePath, '.agents', agentDirs);
      
      // Look for agent.yml files in .agents directories
      for (const agentDir of agentDirs) {
        this.findFiles(agentDir, 'agent.yml', files);
        this.findFiles(agentDir, 'agent.yaml', files);
      }
      
      // Also check examples directory
      const exampleAgentsPath = join(this.rootPath, 'examples', '.agents');
      if (existsSync(exampleAgentsPath) && !searchPath) {
        this.findFiles(exampleAgentsPath, 'agent.yml', files);
        this.findFiles(exampleAgentsPath, 'agent.yaml', files);
      }
      
    } catch (error) {
      // Ignore search errors
    }
    
    return files;
  }

  /**
   * Recursively find directories with specific name
   */
  findDirectories(basePath, dirName, results) {
    try {
      const items = readdirSync(basePath, { withFileTypes: true });
      
      for (const item of items) {
        if (item.isDirectory()) {
          const fullPath = join(basePath, item.name);
          
          if (item.name === dirName) {
            results.push(fullPath);
          } else if (!item.name.startsWith('.') && !item.name === 'node_modules') {
            this.findDirectories(fullPath, dirName, results);
          }
        }
      }
    } catch (error) {
      // Ignore access errors
    }
  }

  /**
   * Recursively find files with specific name
   */
  findFiles(basePath, fileName, results) {
    try {
      const items = readdirSync(basePath, { withFileTypes: true });
      
      for (const item of items) {
        const fullPath = join(basePath, item.name);
        
        if (item.isFile() && item.name === fileName) {
          results.push(fullPath);
        } else if (item.isDirectory() && !item.name.startsWith('.')) {
          this.findFiles(fullPath, fileName, results);
        }
      }
    } catch (error) {
      // Ignore access errors
    }
  }

  /**
   * Perform basic OSSA validation
   */
  performBasicValidation(data) {
    const errors = [];
    const warnings = [];

    // Required fields
    if (!data.apiVersion) {
      errors.push('Missing required field: apiVersion');
    } else if (!data.apiVersion.startsWith('open-standards-scalable-agents/')) {
      errors.push('Invalid apiVersion format - must start with "open-standards-scalable-agents/"');
    }

    if (!data.kind) {
      errors.push('Missing required field: kind');
    } else if (!['Agent', 'Workspace', 'OrchestrationRules'].includes(data.kind)) {
      warnings.push(`Unknown kind: ${data.kind}`);
    }

    if (!data.metadata) {
      errors.push('Missing required field: metadata');
    } else {
      if (!data.metadata.name) {
        errors.push('Missing required field: metadata.name');
      }
      if (!data.metadata.version) {
        errors.push('Missing required field: metadata.version');
      }
    }

    if (!data.spec) {
      errors.push('Missing required field: spec');
    } else {
      if (!data.spec.agent) {
        errors.push('Missing required field: spec.agent');
      } else {
        if (!data.spec.agent.name) {
          errors.push('Missing required field: spec.agent.name');
        }
        if (!data.spec.agent.expertise) {
          errors.push('Missing required field: spec.agent.expertise');
        }
      }

      if (!data.spec.capabilities || !Array.isArray(data.spec.capabilities)) {
        errors.push('Missing or invalid field: spec.capabilities (must be array)');
      } else if (data.spec.capabilities.length === 0) {
        warnings.push('No capabilities defined');
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Check if port is in use
   */
  async checkPortInUse(port) {
    try {
      const { default: net } = await import('net');
      
      return new Promise((resolve) => {
        const server = net.createServer();
        
        server.listen(port, () => {
          server.close(() => resolve(false));
        });
        
        server.on('error', () => resolve(true));
      });
    } catch (error) {
      return false;
    }
  }

  /**
   * Test validation server
   */
  async testValidationServer(port) {
    try {
      const response = await fetch(`http://localhost:${port}/health`);
      if (response.ok) {
        const data = await response.json();
        console.log(`   ‚úÖ Server healthy: ${data.status || 'OK'}`);
        return true;
      } else {
        console.log(`   ‚ö†Ô∏è  Server responded with status: ${response.status}`);
        return false;
      }
    } catch (error) {
      console.log(`   ‚ùå Server not responding: ${error.message}`);
      return false;
    }
  }

  /**
   * Generate agent template
   */
  generateAgentTemplate(agentName) {
    return {
      apiVersion: 'open-standards-scalable-agents/v0.1.8',
      kind: 'Agent',
      metadata: {
        name: agentName,
        version: '1.0.0',
        namespace: 'default',
        labels: {
          type: 'agent',
          created_by: 'ossa-working-cli'
        },
        description: `OSSA agent: ${agentName}`
      },
      spec: {
        agent: {
          name: agentName.split('-').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
          ).join(' '),
          expertise: `Specialized agent for ${agentName} domain with comprehensive capabilities`,
          version: '1.0.0',
          type: 'individual'
        },
        capabilities: [
          {
            name: 'primary_capability',
            description: 'Primary capability for domain-specific tasks and analysis',
            domain: 'general',
            examples: [
              {
                input: 'Example input for primary capability',
                output: 'Example output showing capability results'
              }
            ]
          },
          {
            name: 'secondary_capability',
            description: 'Secondary capability for supporting tasks and operations',
            domain: 'general'
          }
        ],
        frameworks: {
          mcp: {
            enabled: true,
            integration: 'native'
          },
          langchain: {
            enabled: true,
            integration: 'adapter'
          }
        },
        api: {
          openapi: './openapi.yaml',
          version: '1.0.0'
        },
        discovery: {
          uadp: {
            enabled: true,
            priority: 5,
            tags: [agentName, 'general']
          }
        }
      }
    };
  }

  /**
   * Generate OpenAPI template
   */
  generateOpenAPITemplate(agentName) {
    const displayName = agentName.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    return {
      openapi: '3.1.0',
      info: {
        title: `${displayName} Agent API`,
        version: '1.0.0',
        description: `OSSA-compliant API for ${displayName} agent`
      },
      servers: [
        {
          url: 'http://localhost:3000',
          description: 'Development server'
        }
      ],
      paths: {
        '/health': {
          get: {
            summary: 'Health check',
            responses: {
              '200': {
                description: 'Service is healthy',
                content: {
                  'application/json': {
                    schema: {
                      type: 'object',
                      properties: {
                        status: { type: 'string', example: 'healthy' },
                        timestamp: { type: 'string', format: 'date-time' }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        '/api/v1/capabilities/primary_capability': {
          post: {
            summary: 'Execute primary capability',
            requestBody: {
              content: {
                'application/json': {
                  schema: {
                    type: 'object',
                    properties: {
                      input: { type: 'string', description: 'Input for processing' }
                    },
                    required: ['input']
                  }
                }
              }
            },
            responses: {
              '200': {
                description: 'Capability executed successfully',
                content: {
                  'application/json': {
                    schema: {
                      type: 'object',
                      properties: {
                        result: { type: 'string', description: 'Processing result' },
                        confidence: { type: 'number', minimum: 0, maximum: 1 }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      components: {
        schemas: {
          Error: {
            type: 'object',
            properties: {
              error: { type: 'string' },
              message: { type: 'string' },
              code: { type: 'integer' }
            }
          }
        }
      }
    };
  }

  /**
   * Generate README template
   */
  generateReadmeTemplate(agentName) {
    const displayName = agentName.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');

    return `# ${displayName} Agent

OSSA-compliant agent for ${agentName} domain functionality.

## Overview

This agent provides specialized capabilities for ${agentName} domain tasks with comprehensive OSSA v0.1.8 compliance.

## Capabilities

- **Primary Capability**: Domain-specific task processing and analysis
- **Secondary Capability**: Supporting operations and utilities

## API Specification

See \`openapi.yaml\` for complete API documentation.

## Framework Integration

- **MCP**: Native integration for Claude Desktop compatibility
- **LangChain**: Adapter integration for tool and chain compatibility

## Usage

### Validation

\`\`\`bash
ossa-working validate ./agent.yml
\`\`\`

### Local Development

1. Start validation server: \`ossa-working serve\`
2. Test agent: \`ossa-working test\`
3. View status: \`ossa-working status\`

## Generated by OSSA Working CLI v0.1.8

This agent was created using the OSSA Working CLI - a functional implementation with no fantasy claims.

For more information, visit: https://github.com/your-org/ossa
`;
  }
}

// Run CLI if called directly
if (import.meta.url === `file://${__filename}`) {
  const cli = new OSSAWorkingCLI();
  cli.run().catch(error => {
    console.error('CLI Error:', error.message);
    process.exit(1);
  });
}

export default OSSAWorkingCLI;