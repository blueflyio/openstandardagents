"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = parse;
const _shared_js_1 = require("./_shared.js");
const _shared_js_2 = require("./_shared.js");
/**
 * Attempt to parse a string as a semantic version, returning a SemVer object.
 *
 * @example Usage
 * ```ts
 * import { parse } from "@std/semver/parse";
 * import { assertEquals } from "@std/assert";
 *
 * const version = parse("1.2.3");
 * assertEquals(version, {
 *   major: 1,
 *   minor: 2,
 *   patch: 3,
 *   prerelease: [],
 *   build: [],
 * });
 * ```
 *
 * @throws {TypeError} If the input string is invalid.
 * @param value The version string to parse
 * @returns A valid SemVer
 */
function parse(value) {
    if (typeof value !== "string") {
        throw new TypeError(`Cannot parse version as version must be a string: received ${typeof value}`);
    }
    if (value.length > _shared_js_2.MAX_LENGTH) {
        throw new TypeError(`Cannot parse version as version length is too long: length is ${value.length}, max length is ${_shared_js_2.MAX_LENGTH}`);
    }
    value = value.trim();
    const groups = value.match(_shared_js_2.FULL_REGEXP)?.groups;
    if (!groups)
        throw new TypeError(`Cannot parse version: ${value}`);
    const major = (0, _shared_js_1.parseNumber)(groups.major, `Cannot parse version ${value}: invalid major version`);
    const minor = (0, _shared_js_1.parseNumber)(groups.minor, `Cannot parse version ${value}: invalid minor version`);
    const patch = (0, _shared_js_1.parseNumber)(groups.patch, `Cannot parse version ${value}: invalid patch version`);
    const prerelease = groups.prerelease
        ? (0, _shared_js_1.parsePrerelease)(groups.prerelease)
        : [];
    const build = groups.buildmetadata ? (0, _shared_js_1.parseBuild)(groups.buildmetadata) : [];
    return { major, minor, patch, prerelease, build };
}
