import type { GitLabClient } from './gitlab-client.js';
import type { LLMClient } from './llm-client.js';
import type { Logger } from 'pino';
import type { WebhookEvent, WorkflowContext } from './types.js';

export interface WorkflowExecutorConfig {
  gitlabClient: GitLabClient;
  llmClient: LLMClient;
  logger: Logger;
}

export class WorkflowExecutor {
  private gitlabClient: GitLabClient;
  private llmClient: LLMClient;
  private logger: Logger;

  constructor(config: WorkflowExecutorConfig) {
    this.gitlabClient = config.gitlabClient;
    this.llmClient = config.llmClient;
    this.logger = config.logger;
  }

  /**
   * Execute workflow
   */
  async execute(event: WebhookEvent): Promise<any> {
    const context: WorkflowContext = {
      event,
      variables: this.extractVariables(event),
      outputs: {},
    };

    this.logger.info({ context }, 'Starting workflow execution');

    try {
      // Step 1: Fetch Failed Jobs
      this.logger.info('Executing step: Fetch Failed Jobs');
      context.outputs.fetch-jobs = await this.gitlabClient.getPipelineJobs(
        context.variables.PROJECT_ID, context.variables.PIPELINE_ID
      );


      // Step 2: Get Failure Logs
      this.logger.info('Executing step: Get Failure Logs');
      context.outputs.get-logs = await Promise.all([

      ]);


      // Step 3: Analyze Root Cause
      this.logger.info('Executing step: Analyze Root Cause');
      const prompt = `Pipeline #${PIPELINE_ID} failed on ${REF}

Failed Jobs:
${jobs.filter(j => j.status === 'failed').map(j => `- ${j.name} (stage: ${j.stage})`).join('\n')}

Logs:
${logs.map((log, i) => `
=== ${jobs[i].name} ===
${log}
`).join('\n\n')}

Analyze and provide fix in JSON:
{
  "root_cause": "string (detailed explanation)",
  "error_type": "typescript|test|lint|dependency|build|config",
  "affected_files": ["list of files that need changes"],
  "fix_strategy": "string (how to fix)",
  "code_changes": [
    {
      "file_path": "string",
      "action": "update",
      "current_content": "string (if known)",
      "new_content": "string (fixed version)"
    }
  ],
  "commit_message": "string (conventional commit format)",
  "mr_title": "string (descriptive title)",
  "mr_description": "string (markdown formatted)",
  "confidence": number (0-100, how confident in this fix)
}
`;
      context.outputs.analyze-failure = await this.llmClient.invokeJSON(prompt);


      // Step 4: Check Fix Confidence
      this.logger.info('Executing step: Check Fix Confidence');
      if (analysis.confidence < 70) {
      // TODO: Implement evaluate
      }


      // Step 5: Create Fix Branch
      this.logger.info('Executing step: Create Fix Branch');
      context.outputs.create-fix-branch = await this.gitlabClient.createBranch(
        context.variables.PROJECT_ID, "auto-fix/pipeline-${PIPELINE_ID}", context.variables.REF
      );


      // Step 6: Apply Code Fixes
      this.logger.info('Executing step: Apply Code Fixes');
      context.outputs.apply-fixes = await this.gitlabClient.createCommit(
        context.variables.PROJECT_ID, context.variables.branch.name, "${analysis.commit_message}\n\nAuto-generated fix for pipeline #${PIPELINE_ID}\n\nRoot cause: ${analysis.root_cause}\n\nCo-Authored-By: Pipeline Auto-Fix Agent <pipeline-remediation@blueflyagents.com>\n", context.variables.analysis.code_changes
      );


      // Step 7: Create Fix MR
      this.logger.info('Executing step: Create Fix MR');
      context.outputs.create-fix-mr = await this.gitlabClient.createMR(
        context.variables.PROJECT_ID, context.variables.branch.name, context.variables.REF, context.variables.analysis.mr_title, "## ðŸ¤– Auto-Fix for Pipeline #${PIPELINE_ID}\n\n**Status**: Failed âŒ â†’ Fixed âœ…\n\n### Root Cause\n${analysis.root_cause}\n\n### Error Type\n`${analysis.error_type}`\n\n### Fix Strategy\n${analysis.fix_strategy}\n\n### Files Changed\n${analysis.affected_files.map(f => `- \\`${f}\\``).join('\\n')}\n\n### Commit\n${commit.short_id}: ${analysis.commit_message}\n\n### Testing\n- [ ] Pipeline passes on this MR\n- [ ] Code review approved\n- [ ] Ready to merge\n\n---\nðŸ¤– Generated by: pipeline-auto-fix agent\nðŸ“Š Confidence: ${analysis.confidence}%\nðŸ”— Failed pipeline: [#${PIPELINE_ID}](${CI_PROJECT_URL}/-/pipelines/${PIPELINE_ID})\n"
      );


      // Step 8: Post Detailed Comment
      this.logger.info('Executing step: Post Detailed Comment');
      context.outputs.post-explanation = await this.gitlabClient.postComment(
        context.variables.PROJECT_ID, context.variables.mr.iid, "## ðŸ” Detailed Analysis\n\n### Failed Jobs\n${jobs.filter(j => j.status === 'failed').map(j => `\n**${j.name}** (${j.stage})\n- Duration: ${j.duration}s\n- Exit code: ${j.exit_code}\n`).join('\\n')}\n\n### Root Cause Deep Dive\n${analysis.root_cause}\n\n### Code Changes Explanation\n${analysis.code_changes.map(c => `\n#### \\`${c.file_path}\\`\n\\`\\`\\`diff\n- Old (line causing error)\n+ New (fixed line)\n\\`\\`\\`\n`).join('\\n')}\n\n### Verification\nThis MR will trigger a new pipeline. If it passes, the fix is confirmed.\n\n**Confidence**: ${analysis.confidence}%\n${analysis.confidence < 90 ? '\\nâš ï¸  Manual review recommended due to confidence level.' : ''}\n"
      );


      this.logger.info({ outputs: context.outputs }, 'Workflow completed');
      return context.outputs;
    } catch (error) {
      this.logger.error({ err: error }, 'Workflow execution failed');
      throw error;
    }
  }

  /**
   * Extract variables from webhook event
   */
  private extractVariables(event: WebhookEvent): Record<string, any> {
    return {
      PROJECT_ID: event.project?.id || event.project_id,
      MR_IID: event.merge_request?.iid || event.object_attributes?.iid,
      PIPELINE_ID: event.object_attributes?.id,
      COMMIT_SHA: event.object_attributes?.sha || event.commit?.id,
      REF: event.object_attributes?.ref || event.ref,
      SOURCE_BRANCH: event.merge_request?.source_branch,
      TARGET_BRANCH: event.merge_request?.target_branch,
      DUO_COMMENT_ID: event.object_attributes?.id,
      DUO_COMMENT_BODY: event.object_attributes?.note,
      // Add more as needed
    };
  }
}
