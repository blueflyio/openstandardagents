{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://openstandardagents.org/schemas/v0.3.4/extensions/ag2/swarm-topology.json",
  "title": "AG2 Swarm Topology Extension",
  "description": "AG2 (AutoGen) swarm topology patterns for multi-agent orchestration. Defines how agents collaborate in various organizational structures.",
  "type": "object",
  "properties": {
    "topology_type": {
      "type": "string",
      "enum": [
        "sequential",
        "fan_out",
        "fan_in",
        "hierarchical",
        "mesh",
        "hub_and_spoke",
        "pipeline",
        "dynamic"
      ],
      "description": "Swarm topology pattern that determines agent collaboration structure"
    },
    "sequential": {
      "$ref": "#/definitions/SequentialTopology"
    },
    "fan_out": {
      "$ref": "#/definitions/FanOutTopology"
    },
    "fan_in": {
      "$ref": "#/definitions/FanInTopology"
    },
    "hierarchical": {
      "$ref": "#/definitions/HierarchicalTopology"
    },
    "mesh": {
      "$ref": "#/definitions/MeshTopology"
    },
    "hub_and_spoke": {
      "$ref": "#/definitions/HubAndSpokeTopology"
    },
    "pipeline": {
      "$ref": "#/definitions/PipelineTopology"
    },
    "dynamic": {
      "$ref": "#/definitions/DynamicTopology"
    },
    "orchestration_mode": {
      "type": "string",
      "enum": [
        "auto",
        "manual",
        "round_robin",
        "speaker_selection",
        "custom"
      ],
      "default": "auto",
      "description": "How the swarm determines next speaker or task assignment"
    },
    "max_rounds": {
      "type": "integer",
      "minimum": 1,
      "maximum": 100,
      "default": 10,
      "description": "Maximum conversation rounds in group chat"
    },
    "termination_condition": {
      "$ref": "#/definitions/TerminationCondition"
    },
    "speaker_selection_strategy": {
      "$ref": "#/definitions/SpeakerSelectionStrategy"
    }
  },
  "definitions": {
    "SequentialTopology": {
      "type": "object",
      "description": "Linear sequence of agents processing tasks one after another",
      "required": ["agents"],
      "properties": {
        "agents": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "Ordered list of agent URIs in sequence"
        },
        "allow_skip": {
          "type": "boolean",
          "default": false,
          "description": "Whether agents can skip to later stages"
        },
        "error_handling": {
          "type": "string",
          "enum": ["stop", "skip", "retry"],
          "default": "stop",
          "description": "How to handle failures in sequence"
        }
      }
    },
    "FanOutTopology": {
      "type": "object",
      "description": "Single source agent distributes tasks to multiple worker agents in parallel",
      "required": ["source", "workers"],
      "properties": {
        "source": {
          "type": "string",
          "format": "uri",
          "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
          "description": "Source agent URI that distributes work"
        },
        "workers": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "Worker agent URIs receiving parallel tasks"
        },
        "aggregation_mode": {
          "type": "string",
          "enum": ["all", "first", "majority", "custom"],
          "default": "all",
          "description": "How to aggregate results from workers"
        },
        "timeout_ms": {
          "type": "integer",
          "minimum": 1000,
          "description": "Maximum time to wait for all workers"
        }
      }
    },
    "FanInTopology": {
      "type": "object",
      "description": "Multiple agents send results to single aggregator agent",
      "required": ["sources", "aggregator"],
      "properties": {
        "sources": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "Source agent URIs providing input"
        },
        "aggregator": {
          "type": "string",
          "format": "uri",
          "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
          "description": "Aggregator agent URI that combines results"
        },
        "wait_for_all": {
          "type": "boolean",
          "default": true,
          "description": "Whether to wait for all sources before aggregating"
        },
        "aggregation_strategy": {
          "type": "string",
          "enum": ["merge", "vote", "prioritize", "custom"],
          "default": "merge",
          "description": "How to combine results from multiple sources"
        }
      }
    },
    "HierarchicalTopology": {
      "type": "object",
      "description": "Tree structure with supervisor-worker relationships across multiple levels",
      "required": ["root", "levels"],
      "properties": {
        "root": {
          "type": "string",
          "format": "uri",
          "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
          "description": "Root supervisor agent URI"
        },
        "levels": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/HierarchyLevel"
          },
          "description": "Hierarchical levels from top to bottom"
        },
        "escalation_policy": {
          "type": "string",
          "enum": ["always", "on_failure", "on_request", "never"],
          "default": "on_failure",
          "description": "When to escalate to parent supervisor"
        }
      }
    },
    "HierarchyLevel": {
      "type": "object",
      "required": ["agents"],
      "properties": {
        "agents": {
          "type": "array",
          "items": {
            "type": "object",
            "required": ["uri"],
            "properties": {
              "uri": {
                "type": "string",
                "format": "uri",
                "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
              },
              "children": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uri",
                  "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
                },
                "description": "Child agent URIs supervised by this agent"
              }
            }
          }
        },
        "level_name": {
          "type": "string",
          "description": "Human-readable level identifier"
        }
      }
    },
    "MeshTopology": {
      "type": "object",
      "description": "Fully connected network where all agents can communicate with each other",
      "required": ["agents"],
      "properties": {
        "agents": {
          "type": "array",
          "minItems": 3,
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "All participating agent URIs"
        },
        "broadcast_mode": {
          "type": "boolean",
          "default": false,
          "description": "Whether messages are broadcast to all agents"
        },
        "consensus_required": {
          "type": "boolean",
          "default": false,
          "description": "Whether consensus is needed for decisions"
        },
        "consensus_threshold": {
          "type": "number",
          "minimum": 0.5,
          "maximum": 1.0,
          "default": 0.67,
          "description": "Fraction of agents required for consensus"
        }
      }
    },
    "HubAndSpokeTopology": {
      "type": "object",
      "description": "Central orchestrator (hub) coordinates multiple specialized agents (spokes)",
      "required": ["hub", "spokes"],
      "properties": {
        "hub": {
          "type": "string",
          "format": "uri",
          "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
          "description": "Hub orchestrator agent URI"
        },
        "spokes": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "Spoke agent URIs (specialized workers)"
        },
        "direct_spoke_communication": {
          "type": "boolean",
          "default": false,
          "description": "Whether spokes can communicate directly without hub"
        },
        "load_balancing": {
          "type": "string",
          "enum": ["round_robin", "least_loaded", "capability_match", "random"],
          "default": "capability_match",
          "description": "How hub assigns tasks to spokes"
        }
      }
    },
    "PipelineTopology": {
      "type": "object",
      "description": "Data flows through stages with multiple agents per stage",
      "required": ["stages"],
      "properties": {
        "stages": {
          "type": "array",
          "minItems": 2,
          "items": {
            "$ref": "#/definitions/PipelineStage"
          },
          "description": "Sequential pipeline stages"
        },
        "parallel_execution": {
          "type": "boolean",
          "default": false,
          "description": "Whether stages can execute in parallel when possible"
        },
        "checkpoint_enabled": {
          "type": "boolean",
          "default": false,
          "description": "Whether to save state between stages"
        }
      }
    },
    "PipelineStage": {
      "type": "object",
      "required": ["name", "agents"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Stage identifier"
        },
        "agents": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "Agents participating in this stage"
        },
        "mode": {
          "type": "string",
          "enum": ["sequential", "parallel", "competitive"],
          "default": "sequential",
          "description": "How agents in stage collaborate"
        },
        "timeout_ms": {
          "type": "integer",
          "minimum": 1000,
          "description": "Stage timeout"
        }
      }
    },
    "DynamicTopology": {
      "type": "object",
      "description": "Topology that changes based on runtime conditions and agent availability",
      "required": ["agent_pool"],
      "properties": {
        "agent_pool": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "uri",
            "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$"
          },
          "description": "Available agents in pool"
        },
        "selection_criteria": {
          "type": "object",
          "properties": {
            "capability_match": {
              "type": "boolean",
              "default": true,
              "description": "Select based on agent capabilities"
            },
            "availability": {
              "type": "boolean",
              "default": true,
              "description": "Select based on agent availability"
            },
            "performance_history": {
              "type": "boolean",
              "default": false,
              "description": "Select based on past performance"
            }
          }
        },
        "topology_adaptation": {
          "type": "string",
          "enum": ["static", "adaptive", "self_organizing"],
          "default": "adaptive",
          "description": "How topology evolves during execution"
        }
      }
    },
    "TerminationCondition": {
      "type": "object",
      "description": "Conditions for ending swarm collaboration",
      "properties": {
        "max_turns": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum conversation turns"
        },
        "keyword": {
          "type": "string",
          "description": "Termination keyword in message"
        },
        "timeout_ms": {
          "type": "integer",
          "minimum": 1000,
          "description": "Maximum execution time"
        },
        "success_criteria": {
          "type": "object",
          "description": "Custom success conditions",
          "additionalProperties": true
        },
        "error_threshold": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum errors before termination"
        }
      }
    },
    "SpeakerSelectionStrategy": {
      "type": "object",
      "description": "Strategy for selecting next speaker in group chat",
      "properties": {
        "method": {
          "type": "string",
          "enum": [
            "round_robin",
            "auto",
            "manual",
            "random",
            "llm_based",
            "capability_match"
          ],
          "default": "auto",
          "description": "Speaker selection method"
        },
        "transition_rules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TransitionRule"
          },
          "description": "Rules for agent transitions"
        },
        "llm_config": {
          "type": "object",
          "description": "LLM configuration for auto speaker selection",
          "additionalProperties": true
        }
      }
    },
    "TransitionRule": {
      "type": "object",
      "required": ["from", "to", "condition"],
      "properties": {
        "from": {
          "type": "string",
          "format": "uri",
          "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
          "description": "Source agent URI"
        },
        "to": {
          "type": "string",
          "format": "uri",
          "pattern": "^agent://[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
          "description": "Target agent URI"
        },
        "condition": {
          "type": "string",
          "description": "Transition condition (e.g., 'task_completed', 'error', 'keyword:approve')"
        },
        "priority": {
          "type": "integer",
          "minimum": 1,
          "default": 1,
          "description": "Rule priority (higher = evaluated first)"
        }
      }
    }
  }
}
