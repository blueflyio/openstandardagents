[
  {
    "name": "code-review-workflow.yml",
    "path": "adk-integration/code-review-workflow.yml",
    "content": "# Example: ADK Code Review Workflow with OSSA Agents\n# This demonstrates how OSSA agents work with ADK orchestration patterns\n\napiVersion: '@ossa/v0.1.9'\nkind: Workflow\nmetadata:\n  name: code-review-workflow\n  description: 'Multi-agent code review using ADK patterns'\n\nspec:\n  # ADK orchestration pattern\n  adk_pattern: sequential\n\n  # Agents involved in workflow\n  agents:\n    - name: code-analyzer\n      type: LlmAgent\n      ossa_type: worker\n      capabilities:\n        - code-analysis\n        - static-analysis\n      instruction: |\n        Analyze the provided code for:\n        - Code quality issues\n        - Potential bugs\n        - Performance concerns\n        - Security vulnerabilities\n        Store findings in {analysis_results}\n      output_key: analysis_results\n\n    - name: style-checker\n      type: LlmAgent\n      ossa_type: critic\n      capabilities:\n        - style-checking\n        - formatting\n      instruction: |\n        Check code style based on {analysis_results}:\n        - Naming conventions\n        - Code formatting\n        - Documentation completeness\n        Store style issues in {style_report}\n      output_key: style_report\n\n    - name: security-auditor\n      type: CustomAgent\n      custom_type: governor\n      ossa_type: governor\n      capabilities:\n        - security-scanning\n        - vulnerability-detection\n      policies:\n        - name: owasp-top-10\n          severity: high\n        - name: cwe-sans-25\n          severity: critical\n      instruction: |\n        Audit code for security issues using {analysis_results}\n        Apply OWASP and CWE policies\n        Store violations in {security_audit}\n      output_key: security_audit\n\n    - name: review-aggregator\n      type: WorkflowAgent\n      workflow_type: parallel\n      ossa_type: orchestrator\n      sub_agents:\n        - code-analyzer\n        - style-checker\n        - security-auditor\n      instruction: |\n        Aggregate all review results:\n        - {analysis_results}\n        - {style_report}  \n        - {security_audit}\n        Generate comprehensive review report\n      output_key: final_review\n\n  # Execution configuration\n  execution:\n    # Use ADK state management\n    state_management: adk_session\n\n    # Tool delegation\n    tool_delegation:\n      type: explicit\n      tools:\n        - name: git_operations\n          capabilities: [version-control]\n        - name: issue_tracker\n          capabilities: [issue-management]\n\n    # Conditional execution based on findings\n    conditions:\n      - agent: security-auditor\n        condition: \"session.state.analysis_results.severity > 'medium'\"\n      - agent: style-checker\n        condition: 'session.state.analysis_results.lines_of_code > 100'\n\n    # Loop configuration for iterative review\n    loop_options:\n      max_iterations: 3\n      break_condition: 'session.state.security_audit.violations.length == 0'\n\n  # ADK integration settings\n  adk_config:\n    # Model configuration\n    models:\n      default: gemini-2.0-flash\n      specialized:\n        security-auditor: gemini-2.0-pro\n\n    # Performance settings\n    performance:\n      parallel_execution: true\n      cache_session_state: true\n      state_persistence: redis\n\n    # Error handling\n    error_handling:\n      retry_count: 3\n      fallback_pattern: sequential\n# Example usage with ADK adapter:\n#\n# const adapter = new OSSAADKAdapter();\n# await adapter.loadAgent('.agents/code-analyzer');\n# await adapter.loadAgent('.agents/style-checker');\n# await adapter.loadAgent('.agents/security-auditor');\n# await adapter.loadAgent('.agents/review-aggregator');\n#\n# const result = await adapter.executeOrchestration(\n#   'sequential',\n#   ['code-analyzer', 'style-checker', 'security-auditor', 'review-aggregator'],\n#   { code: sourceCode },\n#   { conditions: [...], loop_options: {...} }\n# );\n",
    "category": "Integration Patterns"
  },
  {
    "name": "customer-support.yml",
    "path": "adk-integration/customer-support.yml",
    "content": "# Example: ADK Customer Support System with OSSA Agents\n# Demonstrates Coordinator and Dispatcher patterns\n\napiVersion: '@ossa/v0.1.9'\nkind: Workflow\nmetadata:\n  name: customer-support-system\n  description: 'Multi-agent customer support with intelligent routing'\n\nspec:\n  # ADK Coordinator pattern for complex support tasks\n  adk_pattern: coordinator\n\n  agents:\n    # Coordinator agent\n    - name: support-coordinator\n      type: LlmAgent\n      ossa_type: orchestrator\n      model: gemini-2.0-pro\n      instruction: |\n        Analyze customer request and determine:\n        1. Request type (billing, technical, product, complaint)\n        2. Urgency level (low, medium, high, critical)\n        3. Required specialists\n        4. Delegation strategy\n\n        Route to appropriate agents based on analysis.\n        Store routing decision in {routing_plan}\n      output_key: routing_plan\n      capabilities:\n        - request-analysis\n        - intent-classification\n        - routing-decision\n\n    # Specialist agents\n    - name: billing-specialist\n      type: LlmAgent\n      ossa_type: worker\n      instruction: |\n        Handle billing-related inquiries:\n        - Payment issues\n        - Subscription changes\n        - Refund requests\n        - Invoice questions\n\n        Use {routing_plan} context\n        Store response in {billing_response}\n      output_key: billing_response\n      tools:\n        - database_query\n        - api_call\n      capabilities:\n        - billing-operations\n        - payment-processing\n\n    - name: technical-specialist\n      type: LlmAgent\n      ossa_type: worker\n      instruction: |\n        Resolve technical issues:\n        - Bug reports\n        - Feature questions\n        - Integration problems\n        - Performance issues\n\n        Reference {routing_plan} for context\n        Store solution in {technical_response}\n      output_key: technical_response\n      tools:\n        - api_call\n        - database_query\n      capabilities:\n        - technical-support\n        - troubleshooting\n\n    - name: product-specialist\n      type: LlmAgent\n      ossa_type: worker\n      instruction: |\n        Answer product questions:\n        - Feature explanations\n        - Best practices\n        - Use case guidance\n        - Product recommendations\n\n        Use {routing_plan} guidance\n        Store answer in {product_response}\n      output_key: product_response\n      capabilities:\n        - product-knowledge\n        - recommendation-engine\n\n    - name: escalation-handler\n      type: CustomAgent\n      custom_type: specialized\n      ossa_type: worker\n      instruction: |\n        Handle escalated issues:\n        - Complaints\n        - Complex problems\n        - VIP customers\n        - Legal matters\n\n        Review all previous responses\n        Store resolution in {escalation_response}\n      output_key: escalation_response\n      capabilities:\n        - escalation-management\n        - conflict-resolution\n\n    # Response aggregator\n    - name: response-synthesizer\n      type: WorkflowAgent\n      workflow_type: parallel\n      ossa_type: orchestrator\n      instruction: |\n        Synthesize all specialist responses:\n        - {billing_response}\n        - {technical_response}\n        - {product_response}\n        - {escalation_response}\n\n        Create unified customer response\n        Store in {final_response}\n      output_key: final_response\n      sub_agents:\n        - billing-specialist\n        - technical-specialist\n        - product-specialist\n        - escalation-handler\n\n  # Dispatcher configuration for routing\n  dispatcher_config:\n    routing_rules:\n      - pattern: 'billing|payment|invoice|refund'\n        agent: billing-specialist\n        priority: high\n\n      - pattern: 'bug|error|crash|slow|broken'\n        agent: technical-specialist\n        priority: critical\n\n      - pattern: 'how to|feature|can I|what is'\n        agent: product-specialist\n        priority: medium\n\n      - pattern: 'complaint|angry|frustrated|cancel'\n        agent: escalation-handler\n        priority: critical\n\n    fallback_agent: support-coordinator\n\n    # LLM-driven routing when rules don't match\n    llm_routing:\n      enabled: true\n      model: gemini-2.0-flash\n      instruction: |\n        Analyze request and select best agent:\n        - Consider request content\n        - Check customer history\n        - Evaluate urgency\n        - Match agent capabilities\n\n  # Coordination strategies\n  coordination:\n    strategy: adaptive # Changes based on request type\n\n    patterns:\n      simple_request:\n        pattern: dispatcher\n        condition: \"session.state.routing_plan.complexity === 'simple'\"\n\n      complex_request:\n        pattern: coordinator\n        condition: \"session.state.routing_plan.complexity === 'complex'\"\n\n      multi_issue:\n        pattern: parallel\n        condition: 'session.state.routing_plan.issue_count > 1'\n\n      escalated:\n        pattern: sequential\n        condition: 'session.state.routing_plan.requires_escalation === true'\n\n  # ADK communication patterns\n  communication:\n    # Shared session state\n    shared_state:\n      - customer_id\n      - request_history\n      - routing_plan\n      - urgency_level\n      - sentiment_score\n\n    # Agent handoff\n    handoff_config:\n      preserve_context: true\n      transfer_method: state_based # Via session.state\n      handoff_message: |\n        Transferring to {target_agent} because:\n        {handoff_reason}\n\n    # Callback mechanisms\n    callbacks:\n      on_routing_complete: log_routing_decision\n      on_response_ready: notify_customer\n      on_escalation: alert_supervisor\n\n  # Performance and optimization\n  adk_config:\n    performance:\n      # Agent pooling\n      agent_pool:\n        min_instances: 1\n        max_instances: 10\n        scale_based_on: request_volume\n\n      # Response caching\n      cache:\n        enabled: true\n        ttl: 3600\n        cache_key: 'request_hash'\n\n    # Quality assurance\n    quality:\n      # Response validation\n      validate_responses: true\n      min_confidence: 0.8\n\n      # Sentiment checking\n      check_sentiment: true\n      min_sentiment_score: 0.6\n\n    # Metrics and monitoring\n    metrics:\n      - response_time\n      - customer_satisfaction\n      - resolution_rate\n      - escalation_rate\n      - agent_utilization\n# Example usage with different patterns:\n#\n# 1. Simple request (Dispatcher):\n# const result = await adapter.executeOrchestration(\n#   'dispatcher',\n#   ['billing-specialist', 'technical-specialist', 'product-specialist'],\n#   { request: \"How do I update my payment method?\" },\n#   { router: customRouter }\n# );\n#\n# 2. Complex request (Coordinator):\n# const result = await adapter.executeOrchestration(\n#   'coordinator',\n#   ['support-coordinator', 'billing-specialist', 'technical-specialist', 'response-synthesizer'],\n#   { request: \"I have billing issues and the app keeps crashing\" }\n# );\n#\n# 3. Escalated issue (Sequential with conditions):\n# const result = await adapter.executeOrchestration(\n#   'sequential',\n#   ['support-coordinator', 'technical-specialist', 'escalation-handler', 'response-synthesizer'],\n#   { request: \"This is the 5th time I'm reporting this critical bug!\" }\n# );\n",
    "category": "Integration Patterns"
  },
  {
    "name": "data-pipeline.yml",
    "path": "adk-integration/data-pipeline.yml",
    "content": "# Example: ADK Data Processing Pipeline with OSSA Agents\n# Demonstrates LoopAgent and ConditionalAgent patterns\n\napiVersion: '@ossa/v0.1.9'\nkind: Workflow\nmetadata:\n  name: data-processing-pipeline\n  description: 'Iterative data processing with conditional branches'\n\nspec:\n  # ADK Loop pattern for batch processing\n  adk_pattern: loop\n\n  agents:\n    - name: data-ingester\n      type: LlmAgent\n      ossa_type: worker\n      capabilities:\n        - data-ingestion\n        - format-conversion\n      instruction: |\n        Ingest data batch from source\n        Convert to standard format\n        Store in {raw_data}\n        Set {has_more_data} flag\n      output_key: raw_data\n      tools:\n        - api_call\n        - file_operation\n\n    - name: data-validator\n      type: LlmAgent\n      ossa_type: critic\n      capabilities:\n        - validation\n        - schema-checking\n      instruction: |\n        Validate {raw_data} against schema\n        Check data quality metrics\n        Store validation results in {validation_status}\n        Set {is_valid} flag\n      output_key: validation_status\n\n    - name: data-transformer\n      type: WorkflowAgent\n      workflow_type: conditional\n      ossa_type: orchestrator\n      instruction: |\n        Transform data based on {validation_status}:\n        - If valid: apply standard transformations\n        - If invalid: apply error corrections\n        Store in {transformed_data}\n      output_key: transformed_data\n      sub_agents:\n        - name: standard-transformer\n          condition: 'session.state.is_valid === true'\n        - name: error-corrector\n          condition: 'session.state.is_valid === false'\n\n    - name: data-enricher\n      type: CustomAgent\n      custom_type: specialized\n      ossa_type: worker\n      capabilities:\n        - data-enrichment\n        - ml-inference\n      instruction: |\n        Enrich {transformed_data} with:\n        - External API data\n        - ML model predictions\n        - Calculated metrics\n        Store in {enriched_data}\n      output_key: enriched_data\n\n    - name: data-loader\n      type: LlmAgent\n      ossa_type: worker\n      capabilities:\n        - database-operations\n        - data-persistence\n      instruction: |\n        Load {enriched_data} to target system\n        Update {batch_counter}\n        Log operation in {load_status}\n      output_key: load_status\n      tools:\n        - database_query\n\n  # Loop configuration\n  execution:\n    loop_config:\n      # Continue while more data exists\n      condition: 'session.state.has_more_data === true'\n      max_iterations: 100\n      batch_size: 1000\n\n      # Break conditions\n      break_conditions:\n        - 'session.state.error_count > 5'\n        - 'session.state.batch_counter >= session.state.total_batches'\n\n    # Conditional branches\n    conditional_config:\n      data-validator:\n        skip_if: 'session.state.skip_validation === true'\n\n      data-enricher:\n        execute_if: 'session.state.validation_status.quality_score > 0.8'\n\n      error-corrector:\n        execute_if: |\n          session.state.validation_status.errors.length > 0 &&\n          session.state.validation_status.errors.some(e => e.severity === 'critical')\n\n    # Parallel processing for sub-workflows\n    parallel_config:\n      enabled: true\n      max_workers: 5\n      distribute_by: 'session.state.raw_data.partition_key'\n\n  # ADK state management\n  adk_config:\n    state:\n      # Persistent state across iterations\n      persistent_keys:\n        - batch_counter\n        - total_processed\n        - error_count\n        - processing_metrics\n\n      # Temporary state (cleared each iteration)\n      temp_keys:\n        - raw_data\n        - validation_status\n        - transformed_data\n        - enriched_data\n\n    # Performance optimization\n    optimization:\n      cache_transformations: true\n      reuse_connections: true\n      batch_database_writes: true\n\n    # Error recovery\n    error_recovery:\n      checkpoint_frequency: 10 # Save state every 10 iterations\n      resume_on_failure: true\n      dead_letter_queue: true\n\n    # Monitoring\n    monitoring:\n      metrics:\n        - batches_processed\n        - records_transformed\n        - validation_failures\n        - enrichment_success_rate\n      alerts:\n        - condition: 'metrics.validation_failures > 10'\n          severity: warning\n        - condition: 'metrics.enrichment_success_rate < 0.95'\n          severity: critical\n# Example usage:\n#\n# const result = await adapter.executeOrchestration(\n#   'loop',\n#   ['data-ingester', 'data-validator', 'data-transformer', 'data-enricher', 'data-loader'],\n#   { source: 's3://data-bucket/input/' },\n#   {\n#     maxIterations: 100,\n#     condition: (state) => state.has_more_data,\n#     breakCondition: (result, state) => state.error_count > 5\n#   }\n# );\n",
    "category": "Integration Patterns"
  },
  {
    "name": "compliance-context-production.json",
    "path": "advanced/patterns/compliance-context-production.json",
    "content": "{\n  \"environment\": \"production\",\n  \"classification\": \"confidential\",\n  \"region\": \"us-east-1\",\n  \"industry\": \"financial-services\",\n  \"dataTypes\": [\n    \"financial-records\",\n    \"customer-data\",\n    \"transaction-logs\",\n    \"audit-trails\"\n  ],\n  \"regulatoryRequirements\": [\n    \"iso-42001\",\n    \"nist-ai-rmf\",\n    \"eu-ai-act\"\n  ],\n  \"complianceMetadata\": {\n    \"organization\": \"Enterprise Financial Corp\",\n    \"complianceOfficer\": \"compliance@enterprise.com\",\n    \"lastReview\": \"2024-01-15\",\n    \"nextReview\": \"2024-04-15\",\n    \"certifications\": [\n      \"ISO 27001:2022\",\n      \"SOC 2 Type II\",\n      \"PCI DSS Level 1\"\n    ]\n  },\n  \"enforcementPolicies\": {\n    \"productionDeployment\": {\n      \"minimumConformance\": \"gold\",\n      \"auditLogging\": \"mandatory\",\n      \"tlsRequired\": true,\n      \"humanOversight\": \"required\",\n      \"budgetLimits\": {\n        \"daily\": 100000,\n        \"monthly\": 2000000,\n        \"emergency\": 500000\n      }\n    },\n    \"stagingDeployment\": {\n      \"minimumConformance\": \"silver\",\n      \"auditLogging\": \"recommended\",\n      \"tlsRequired\": true,\n      \"humanOversight\": \"optional\"\n    },\n    \"developmentDeployment\": {\n      \"minimumConformance\": \"bronze\",\n      \"auditLogging\": \"optional\",\n      \"tlsRequired\": false,\n      \"humanOversight\": \"optional\"\n    }\n  }\n}",
    "category": "Advanced Patterns"
  },
  {
    "name": "model-router.ts",
    "path": "advanced/patterns/model-router.ts",
    "content": "/**\n * OSSA Model Router Pattern\n * =========================\n *\n * This example demonstrates the Model Router pattern for OSSA agents, which allows\n * dynamic selection of language models based on task requirements, cost constraints,\n * and performance needs.\n *\n * Key Features:\n * - Dynamic model selection based on task requirements\n * - Cost-aware routing\n * - Performance optimization\n * - Fallback strategies\n *\n * Directory Structure:\n * examples/advanced/patterns/\n *   ├── model-router.ts      # This file\n *   └── README.md            # Documentation\n *\n * Prerequisites:\n * - Node.js 18+\n * - TypeScript 5.0+\n * - Ollama running locally (for local models)\n * - API keys for cloud providers (if used)\n *\n * Usage:\n * 1. Install dependencies: `npm install @ossa/core dotenv`\n * 2. Start Ollama: `ollama serve`\n * 3. Pull models: `ollama pull llama3`\n * 4. Run: `npx ts-node model-router.ts`\n */\n\nimport { Agent, AgentConfig, AgentContext, AgentResponse } from '@ossa/core';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\n// Define model configurations\nconst MODEL_CONFIGS = {\n  llama3: {\n    provider: 'ollama',\n    model: 'llama3',\n    costPerToken: 0.000002,\n    avgLatencyMs: 1200,\n    maxTokens: 8192,\n    capabilities: ['text-generation', 'summarization', 'qna'],\n  },\n  mixtral: {\n    provider: 'ollama',\n    model: 'mixtral',\n    costPerToken: 0.000003,\n    avgLatencyMs: 1800,\n    maxTokens: 32000,\n    capabilities: ['text-generation', 'code', 'reasoning'],\n  },\n  'gpt-4': {\n    provider: 'openai',\n    model: 'gpt-4-turbo',\n    costPerToken: 0.00001,\n    avgLatencyMs: 2500,\n    maxTokens: 128000,\n    capabilities: ['text-generation', 'code', 'reasoning', 'vision'],\n  },\n  'claude-3-opus': {\n    provider: 'anthropic',\n    model: 'claude-3-opus-20240229',\n    costPerToken: 0.000015,\n    avgLatencyMs: 3000,\n    maxTokens: 200000,\n    capabilities: ['text-generation', 'analysis', 'summarization'],\n  },\n};\n\ntype ModelKey = keyof typeof MODEL_CONFIGS;\n\ninterface ModelRequest {\n  prompt: string;\n  context?: Record<string, any>;\n  requirements?: {\n    maxCostPerToken?: number;\n    maxLatencyMs?: number;\n    minCapabilities?: string[];\n    minContextLength?: number;\n  };\n}\n\nclass ModelRouterAgent extends Agent {\n  private models: Record<string, any> = MODEL_CONFIGS;\n\n  constructor() {\n    super({\n      name: 'model-router',\n      version: '1.0.0',\n      description: 'Intelligent model routing for OSSA agents',\n      capabilities: [\n        'model-routing',\n        'cost-optimization',\n        'performance-monitoring',\n      ],\n    });\n  }\n\n  /**\n   * Select the best model based on requirements\n   */\n  private selectModel(\n    requirements: ModelRequest['requirements'] = {}\n  ): ModelKey {\n    const {\n      maxCostPerToken = Infinity,\n      maxLatencyMs = 5000,\n      minCapabilities = [],\n      minContextLength = 0,\n    } = requirements;\n\n    // Filter models by requirements\n    const suitableModels = Object.entries(this.models)\n      .filter(([_, config]) => {\n        // Check cost constraints\n        if (config.costPerToken > maxCostPerToken) return false;\n\n        // Check latency constraints\n        if (config.avgLatencyMs > maxLatencyMs) return false;\n\n        // Check context length\n        if (config.maxTokens < minContextLength) return false;\n\n        // Check required capabilities\n        return minCapabilities.every((cap) =>\n          config.capabilities.includes(cap)\n        );\n      })\n      .sort((a, b) => {\n        // Prioritize lower cost, then lower latency\n        const costDiff = a[1].costPerToken - b[1].costPerToken;\n        if (costDiff !== 0) return costDiff;\n        return a[1].avgLatencyMs - b[1].avgLatencyMs;\n      });\n\n    if (suitableModels.length === 0) {\n      throw new Error('No suitable models found for the given requirements');\n    }\n\n    return suitableModels[0][0] as ModelKey;\n  }\n\n  /**\n   * Process a request using the best available model\n   */\n  async process(\n    request: ModelRequest,\n    context: AgentContext\n  ): Promise<AgentResponse> {\n    try {\n      // Select the best model\n      const modelKey = this.selectModel(request.requirements);\n      const modelConfig = this.models[modelKey];\n\n      this.logger.info(`Selected model: ${modelKey}`, { model: modelKey });\n\n      // Process the request with the selected model\n      const result = await this.callModel(modelKey, request.prompt, context);\n\n      return {\n        success: true,\n        data: {\n          response: result,\n          model: modelKey,\n          metadata: {\n            cost: request.prompt.length * modelConfig.costPerToken,\n            latency: modelConfig.avgLatencyMs,\n            provider: modelConfig.provider,\n          },\n        },\n      };\n    } catch (error) {\n      this.logger.error('Model routing failed', { error });\n      return {\n        success: false,\n        error: {\n          code: 'MODEL_ROUTING_ERROR',\n          message: error.message,\n          details: error.stack,\n        },\n      };\n    }\n  }\n\n  /**\n   * Call the actual model (implementation would vary by provider)\n   */\n  private async callModel(\n    modelKey: string,\n    prompt: string,\n    context: AgentContext\n  ): Promise<string> {\n    const model = this.models[modelKey];\n\n    // In a real implementation, this would call the actual model APIs\n    // This is a simplified example\n    switch (model.provider) {\n      case 'ollama':\n        return this.callOllama(model.model, prompt);\n      case 'openai':\n        return this.callOpenAI(model.model, prompt);\n      case 'anthropic':\n        return this.callAnthropic(model.model, prompt);\n      default:\n        throw new Error(`Unsupported provider: ${model.provider}`);\n    }\n  }\n\n  // Stub implementations for model providers\n  private async callOllama(model: string, prompt: string): Promise<string> {\n    // Implementation would call Ollama's API\n    return `Response from Ollama (${model}) for prompt: ${prompt.substring(0, 50)}...`;\n  }\n\n  private async callOpenAI(model: string, prompt: string): Promise<string> {\n    // Implementation would call OpenAI's API\n    return `Response from OpenAI (${model}) for prompt: ${prompt.substring(0, 50)}...`;\n  }\n\n  private async callAnthropic(model: string, prompt: string): Promise<string> {\n    // Implementation would call Anthropic's API\n    return `Response from Anthropic (${model}) for prompt: ${prompt.substring(0, 50)}...`;\n  }\n}\n\n// Example usage\nasync function main() {\n  const router = new ModelRouterAgent();\n\n  // Example 1: Fast, low-cost response\n  const response1 = await router.process(\n    {\n      prompt: 'Explain quantum computing in simple terms',\n      requirements: {\n        maxCostPerToken: 0.000005,\n        maxLatencyMs: 2000,\n        minCapabilities: ['text-generation'],\n      },\n    },\n    {}\n  );\n\n  console.log('Example 1 - Fast, low-cost response:');\n  console.log(response1);\n\n  // Example 2: Complex reasoning with higher budget\n  const response2 = await router.process(\n    {\n      prompt:\n        'Write a detailed analysis of the latest AI safety research papers',\n      requirements: {\n        maxCostPerToken: 0.00002,\n        maxLatencyMs: 10000,\n        minCapabilities: ['analysis', 'reasoning'],\n        minContextLength: 16000,\n      },\n    },\n    {}\n  );\n\n  console.log('\\nExample 2 - Complex analysis:');\n  console.log(response2);\n}\n\n// Run the example if this file is executed directly\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nexport { ModelRouterAgent };\n",
    "category": "Advanced Patterns"
  },
  {
    "name": "smart-model-routing.ts",
    "path": "advanced/patterns/smart-model-routing.ts",
    "content": "/**\n * OSSA Smart Model Router\n * ========================\n *\n * This example demonstrates an advanced model routing pattern that dynamically selects\n * the most appropriate language model based on task requirements, cost constraints,\n * and performance needs.\n */\n\nimport { Agent, AgentContext, AgentResponse } from '@ossa/core';\nimport axios from 'axios';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\n// Types and Interfaces\ninterface ModelConfig {\n  provider: 'ollama' | 'openai' | 'anthropic';\n  model: string;\n  costPerToken: number;\n  avgLatencyMs: number;\n  maxTokens: number;\n  capabilities: string[];\n  baseUrl?: string;\n  apiKeyEnv?: string;\n}\n\ninterface ModelRequest {\n  prompt: string;\n  context?: Record<string, any>;\n  requirements?: {\n    maxCostPerToken?: number;\n    maxLatencyMs?: number;\n    minCapabilities?: string[];\n    minContextLength?: number;\n  };\n}\n\ntype ModelKey = keyof typeof MODEL_CONFIGS;\n\n// Configuration\nconst MODEL_CONFIGS: Record<string, ModelConfig> = {\n  llama3: {\n    provider: 'ollama',\n    model: 'llama3',\n    costPerToken: 0.000002,\n    avgLatencyMs: 1200,\n    maxTokens: 8192,\n    capabilities: ['text-generation', 'summarization', 'qna'],\n    baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',\n  },\n  mixtral: {\n    provider: 'ollama',\n    model: 'mixtral',\n    costPerToken: 0.000003,\n    avgLatencyMs: 1800,\n    maxTokens: 32000,\n    capabilities: ['text-generation', 'code', 'reasoning'],\n    baseUrl: process.env.OLLAMA_BASE_URL || 'http://localhost:11434',\n  },\n  'gpt-4': {\n    provider: 'openai',\n    model: 'gpt-4-turbo',\n    costPerToken: 0.00001,\n    avgLatencyMs: 2500,\n    maxTokens: 128000,\n    capabilities: ['text-generation', 'code', 'reasoning', 'vision'],\n    apiKeyEnv: 'OPENAI_API_KEY',\n  },\n  'claude-3-opus': {\n    provider: 'anthropic',\n    model: 'claude-3-opus-20240229',\n    costPerToken: 0.000015,\n    avgLatencyMs: 3000,\n    maxTokens: 200000,\n    capabilities: ['text-generation', 'analysis', 'summarization'],\n    apiKeyEnv: 'ANTHROPIC_API_KEY',\n  },\n};\n\nclass SmartModelRouter extends Agent {\n  private models: Record<string, ModelConfig> = MODEL_CONFIGS;\n  private http = axios.create();\n\n  constructor() {\n    super({\n      name: 'smart-model-router',\n      version: '1.0.0',\n      description: 'Intelligent model routing for OSSA agents',\n      capabilities: [\n        'model-routing',\n        'cost-optimization',\n        'performance-monitoring',\n        'fallback-handling',\n      ],\n    });\n  }\n\n  /**\n   * Process a request using the best available model\n   */\n  async process(\n    request: ModelRequest,\n    context: AgentContext = {}\n  ): Promise<AgentResponse> {\n    try {\n      // Select the best model based on requirements\n      const modelKey = this.selectModel(request.requirements);\n      const modelConfig = this.models[modelKey];\n\n      this.logger.info(`Routing to ${modelKey} (${modelConfig.provider})`);\n\n      // Process the request using the selected model\n      const startTime = Date.now();\n      const response = await this.routeToModel(modelKey, request, context);\n      const latency = Date.now() - startTime;\n\n      return {\n        success: true,\n        data: {\n          model: modelKey,\n          response,\n          metadata: {\n            provider: modelConfig.provider,\n            latency,\n            cost: this.calculateCost(\n              response.usage?.total_tokens || 0,\n              modelConfig\n            ),\n            tokens: response.usage?.total_tokens || 0,\n          },\n        },\n      };\n    } catch (error) {\n      this.logger.error('Error processing request:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Select the best model based on requirements\n   */\n  private selectModel(\n    requirements: ModelRequest['requirements'] = {}\n  ): ModelKey {\n    const {\n      maxCostPerToken = Infinity,\n      maxLatencyMs = 5000,\n      minCapabilities = [],\n      minContextLength = 0,\n    } = requirements;\n\n    // Filter models by requirements\n    const suitableModels = Object.entries(this.models)\n      .filter(([_, config]) => {\n        // Check cost constraints\n        if (config.costPerToken > maxCostPerToken) return false;\n\n        // Check latency constraints\n        if (config.avgLatencyMs > maxLatencyMs) return false;\n\n        // Check context length\n        if (config.maxTokens < minContextLength) return false;\n\n        // Check API key availability for cloud providers\n        if (config.apiKeyEnv && !process.env[config.apiKeyEnv]) {\n          this.logger.warn(`Skipping ${config.model} - missing API key`);\n          return false;\n        }\n\n        // Check required capabilities\n        return minCapabilities.every((cap) =>\n          config.capabilities.includes(cap)\n        );\n      })\n      .sort((a, b) => {\n        // Prioritize lower cost, then lower latency\n        const costDiff = a[1].costPerToken - b[1].costPerToken;\n        if (costDiff !== 0) return costDiff;\n        return a[1].avgLatencyMs - b[1].avgLatencyMs;\n      });\n\n    if (suitableModels.length === 0) {\n      throw new Error('No suitable models found for the given requirements');\n    }\n\n    return suitableModels[0][0] as ModelKey;\n  }\n\n  /**\n   * Route the request to the appropriate model provider\n   */\n  private async routeToModel(\n    modelKey: string,\n    request: ModelRequest,\n    context: AgentContext = {}\n  ): Promise<any> {\n    const model = this.models[modelKey];\n\n    try {\n      switch (model.provider) {\n        case 'ollama':\n          return await this.callOllama(model, request);\n        case 'openai':\n          return await this.callOpenAI(model, request);\n        case 'anthropic':\n          return await this.callAnthropic(model, request);\n        default:\n          throw new Error(`Unsupported provider: ${model.provider}`);\n      }\n    } catch (error) {\n      this.logger.error(`Error calling ${model.provider}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate cost based on token usage\n   */\n  private calculateCost(tokenCount: number, modelConfig: ModelConfig): number {\n    return (tokenCount * modelConfig.costPerToken) / 1000; // Convert to cost per 1k tokens\n  }\n\n  // Provider-specific implementations will be added in the next step\n  private async callOllama(\n    model: ModelConfig,\n    request: ModelRequest\n  ): Promise<any> {\n    throw new Error('Not implemented');\n  }\n\n  private async callOpenAI(\n    model: ModelConfig,\n    request: ModelRequest\n  ): Promise<any> {\n    throw new Error('Not implemented');\n  }\n\n  private async callAnthropic(\n    model: ModelConfig,\n    request: ModelRequest\n  ): Promise<any> {\n    throw new Error('Not implemented');\n  }\n}\n",
    "category": "Advanced Patterns"
  },
  {
    "name": "hybrid-model-strategy.yaml",
    "path": "advanced/workflows/hybrid-model-strategy.yaml",
    "content": "# Hybrid Model Strategy: Fast Local Planning + Premium Development\n# Demonstrates using fast Ollama models for planning agents and Claude for development\n\napiVersion: ossa.io/v0.1.9\nkind: Workflow\nmetadata:\n  name: hybrid-development-workflow\n  description: \"Cost-optimized workflow using fast local models for planning and premium models for development\"\n\nspec:\n  # Planning Phase - Use Fast Local Models\n  agents:\n    # Fast planning agent using local Ollama\n    - name: project-planner\n      type: orchestrator\n      ossa_type: orchestrator\n      modelConfig:\n        provider: \"ollama\"\n        model: \"mistral:7b\"  # Fast 1-2 second responses\n        parameters:\n          temperature: 0.3\n          max_tokens: 2000\n        ollamaConfig:\n          baseUrl: \"http://localhost:11434\"\n          keepAlive: \"5m\"\n      capabilities:\n        - project-planning\n        - task-breakdown\n        - resource-estimation\n      instruction: |\n        You are a fast project planning agent. Quickly break down development tasks:\n        - Analyze requirements\n        - Create task breakdown structure\n        - Estimate effort and dependencies\n        - Identify risks and blockers\n        Store plan in {project_plan}\n      output_key: project_plan\n\n    # Fast requirement analyzer using local model\n    - name: requirements-analyzer\n      type: critic\n      ossa_type: critic\n      modelConfig:\n        provider: \"ollama\"\n        model: \"qwen2.5:7b\"  # Good for analysis, fast\n        parameters:\n          temperature: 0.2\n          max_tokens: 1500\n        ollamaConfig:\n          baseUrl: \"http://localhost:11434\"\n      capabilities:\n        - requirements-analysis\n        - user-story-validation\n        - acceptance-criteria\n      instruction: |\n        Quickly analyze requirements for clarity and completeness:\n        - Validate user stories\n        - Identify missing requirements\n        - Check for conflicts or ambiguities\n        Store analysis in {requirements_analysis}\n      output_key: requirements_analysis\n\n  # Development Phase - Use Premium Models\n    # Premium development agent using Claude Code\n    - name: senior-developer\n      type: worker\n      ossa_type: worker\n      modelConfig:\n        provider: \"anthropic\"\n        model: \"claude-3-5-sonnet-20241022\"\n        parameters:\n          temperature: 0.1  # Low temperature for precise code\n          max_tokens: 8000\n        anthropicConfig:\n          apiKey: \"${ANTHROPIC_API_KEY}\"\n          defaultHeaders:\n            \"anthropic-beta\": \"computer-use-2024-10-22\"\n      capabilities:\n        - code-generation\n        - architecture-design\n        - best-practices\n        - testing\n        - documentation\n      instruction: |\n        You are an expert senior developer using best practices:\n        - Write clean, maintainable code\n        - Follow SOLID principles\n        - Include comprehensive tests\n        - Add proper documentation\n        - Consider security and performance\n        Use {project_plan} and {requirements_analysis} as context\n      tools:\n        - file-operations\n        - git-operations\n        - test-runner\n        - linter\n      output_key: development_result\n\n    # Code review agent using Claude\n    - name: code-reviewer\n      type: critic\n      ossa_type: critic\n      modelConfig:\n        provider: \"anthropic\"\n        model: \"claude-3-5-sonnet-20241022\"\n        parameters:\n          temperature: 0.05  # Very low for consistent reviews\n          max_tokens: 6000\n      capabilities:\n        - code-review\n        - security-analysis\n        - performance-review\n        - maintainability-check\n      instruction: |\n        Perform thorough code review focusing on:\n        - Code quality and best practices\n        - Security vulnerabilities\n        - Performance issues\n        - Maintainability concerns\n        - Test coverage and quality\n        Review {development_result} and provide detailed feedback\n      output_key: code_review\n\n  # Optimization Phase - Use Local Models for Simple Tasks\n    # Documentation generator using local model\n    - name: doc-generator\n      type: worker\n      ossa_type: worker\n      modelConfig:\n        provider: \"ollama\"\n        model: \"codellama:7b\"  # Good for documentation\n        parameters:\n          temperature: 0.4\n          max_tokens: 3000\n      capabilities:\n        - documentation-generation\n        - api-docs\n        - readme-creation\n      instruction: |\n        Generate comprehensive documentation based on {development_result}:\n        - API documentation\n        - Usage examples\n        - Installation instructions\n        - Architecture overview\n      output_key: documentation\n\n  # Cost Optimization Configuration\n  costOptimization:\n    strategy: \"hybrid\"\n    budgetLimits:\n      planning_phase: 0.01    # $0.01 - use free local models\n      development_phase: 1.00  # $1.00 - premium models for quality\n      optimization_phase: 0.05 # $0.05 - local models for docs\n\n    fallbackStrategy:\n      # If premium models unavailable, use these alternatives\n      fallbacks:\n        \"claude-3-5-sonnet\": \"gpt-4o\"\n        \"gpt-4o\": \"gemini-2.0-flash\"\n        \"gemini-2.0-flash\": \"ollama:qwen2.5:7b\"\n\n  # Performance Targets\n  performance:\n    planning_phase:\n      target_latency: \"5s\"      # Fast local responses\n      cost_per_task: \"$0.00\"    # Free local inference\n    development_phase:\n      target_latency: \"30s\"     # Quality over speed\n      cost_per_task: \"$0.50\"    # Premium model investment\n    optimization_phase:\n      target_latency: \"10s\"     # Fast local processing\n      cost_per_task: \"$0.02\"    # Minimal cost\n\n  # Execution Flow\n  execution:\n    phases:\n      - name: planning\n        agents: [project-planner, requirements-analyzer]\n        execution_mode: parallel\n        budget_limit: 0.01\n\n      - name: development\n        agents: [senior-developer]\n        execution_mode: sequential\n        dependencies: [planning]\n        budget_limit: 1.00\n\n      - name: review\n        agents: [code-reviewer]\n        execution_mode: sequential\n        dependencies: [development]\n        budget_limit: 0.30\n\n      - name: documentation\n        agents: [doc-generator]\n        execution_mode: sequential\n        dependencies: [development]\n        budget_limit: 0.05\n\n    # Quality gates\n    quality_gates:\n      - phase: development\n        condition: \"code_review.score > 8.0\"\n        action: \"proceed\"\n      - phase: development\n        condition: \"code_review.security_issues > 0\"\n        action: \"retry_with_feedback\"\n\n---\n# Example Environment Configuration\n# .env file should contain:\n\n# Fast local models for planning\nOLLAMA_BASE_URL=http://localhost:11434\nPLANNING_MODEL=mistral:7b\nANALYSIS_MODEL=qwen2.5:7b\nDOC_MODEL=codellama:7b\n\n# Premium models for development\nANTHROPIC_API_KEY=sk-ant-...\nDEVELOPMENT_MODEL=claude-3-5-sonnet-20241022\nREVIEW_MODEL=claude-3-5-sonnet-20241022\n\n# Cost controls\nMAX_PLANNING_COST=0.01\nMAX_DEVELOPMENT_COST=1.00\nMAX_TOTAL_COST=2.00\n\n# Performance settings\nPLANNING_TIMEOUT=10s\nDEVELOPMENT_TIMEOUT=300s\nREVIEW_TIMEOUT=120s",
    "category": "Advanced Patterns"
  },
  {
    "name": "critic-agent.yaml",
    "path": "agent-manifests/critics/critic-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9\nkind: Agent\nmetadata:\n  name: code-quality-critic\n  version: v1.0.0\n  description: 'Quality assurance agent for code review, testing, and continuous improvement'\n  author: 'quality-engineering-team'\n  labels:\n    environment: production\n    classification: internal\n    role: critic\n    complexity: standard\nspec:\n  type: critic\n  subtype: code-reviewer\n  capabilities:\n    domains:\n      - code-review\n      - quality-assessment\n      - testing-validation\n      - security-analysis\n      - performance-analysis\n      - documentation-review\n    operations:\n      - analyze-code\n      - review-changes\n      - assess-quality\n      - detect-issues\n      - suggest-improvements\n      - validate-tests\n    patterns:\n      - static-analysis\n      - dynamic-analysis\n      - peer-review\n      - automated-testing\n      - quality-gates\n      - continuous-feedback\n  protocols:\n    supported:\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://critic.platform.com/api/v1'\n        authentication:\n          type: bearer-token\n          scopes: ['critic.review', 'code.analyze', 'quality.assess']\n        tls: true\n      - name: webhook\n        version: '1.0'\n        endpoint: 'https://critic.platform.com/webhooks/review'\n        authentication:\n          type: hmac-sha256\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://critic.platform.com:9443/CodeCritic'\n        authentication:\n          type: mutual-tls\n  analysis:\n    codeQuality:\n      complexity: true\n      maintainability: true\n      reliability: true\n      security: true\n      performance: true\n      testability: true\n    staticAnalysis:\n      syntaxChecking: true\n      typeChecking: true\n      styleChecking: true\n      securityScanning: true\n      dependencyAnalysis: true\n    supportedLanguages:\n      - javascript\n      - typescript\n      - python\n      - java\n      - go\n      - rust\n      - csharp\n    qualityMetrics:\n      cyclomaticComplexity: true\n      codeChurn: true\n      testCoverage: true\n      duplication: true\n      maintainabilityIndex: true\n  review:\n    automatedReview: true\n    humanReview: true\n    reviewCriteria:\n      functionality: true\n      readability: true\n      maintainability: true\n      performance: true\n      security: true\n      testCoverage: true\n    scoring:\n      scale: '0-100'\n      passThreshold: 70\n      categories:\n        - functionality\n        - quality\n        - security\n        - performance\n        - maintainability\n  feedback:\n    suggestions: true\n    improvements: true\n    bestPractices: true\n    patterns: true\n    antiPatterns: true\n    learningResources: true\n    priority:\n      - critical\n      - high\n      - medium\n      - low\n      - info\n  integration:\n    versionControl:\n      - git\n      - mercurial\n      - subversion\n    cicdPlatforms:\n      - gitlab\n      - github\n      - jenkins\n      - azure-devops\n    issueTracking:\n      - jira\n      - github-issues\n      - gitlab-issues\n  performance:\n    throughput:\n      reviewsPerHour: 50\n      linesOfCodePerMinute: 1000\n    latency:\n      analysisTime: 30000\n      reviewTime: 120000\n      feedbackTime: 5000\n      p95: 180000\n      p99: 300000\n  monitoring:\n    reviewMetrics: true\n    qualityTrends: true\n    performanceMetrics: true\n    errorTracking: true\n    alerting:\n      reviewFailureThreshold: 5\n      qualityDegradationThreshold: 10\n      performanceThreshold: 300000\n",
    "category": "Agent Types"
  },
  {
    "name": "governor-agent.yaml",
    "path": "agent-manifests/governors/governor-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9\nkind: Agent\nmetadata:\n  name: policy-compliance-governor\n  version: v1.1.0\n  description: 'Governance agent enforcing policies, compliance, and security standards across systems'\n  author: 'governance-team'\n  labels:\n    environment: production\n    classification: internal\n    role: governor\n    complexity: enterprise\nspec:\n  type: governor\n  subtype: policy-enforcer\n  capabilities:\n    domains:\n      - policy-enforcement\n      - compliance-checking\n      - security-governance\n      - resource-management\n      - audit-tracking\n      - risk-assessment\n    operations:\n      - enforce-policies\n      - validate-compliance\n      - assess-risks\n      - audit-activities\n      - manage-permissions\n      - generate-reports\n    patterns:\n      - policy-as-code\n      - audit-trail\n      - role-based-access\n      - compliance-framework\n      - risk-matrix\n      - governance-workflow\n  protocols:\n    supported:\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://governor.platform.com/api/v1'\n        authentication:\n          type: oauth2\n          scopes: ['governor.enforce', 'policies.validate', 'compliance.audit']\n        tls: true\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://governor.platform.com:9443/PolicyGovernor'\n        authentication:\n          type: mutual-tls\n      - name: webhook\n        version: '1.0'\n        endpoint: 'https://governor.platform.com/webhooks'\n        authentication:\n          type: hmac-sha256\n  governance:\n    policyEngine: 'open-policy-agent'\n    complianceFrameworks:\n      - soc2\n      - pci-dss\n      - gdpr\n      - hipaa\n      - iso27001\n    enforcementModes:\n      - advisory\n      - blocking\n      - logging\n    auditRetention: '7y'\n    riskAssessment:\n      frequency: 'weekly'\n      severity: ['low', 'medium', 'high', 'critical']\n      impact: ['minimal', 'moderate', 'significant', 'severe']\n  policies:\n    categories:\n      - security\n      - privacy\n      - operational\n      - financial\n      - regulatory\n    evaluation:\n      realtime: true\n      batch: true\n      scheduled: true\n    versioning:\n      enabled: true\n      approvalRequired: true\n      rollbackCapable: true\n  compliance:\n    continuousMonitoring: true\n    reportingFrequency: 'monthly'\n    evidenceCollection: true\n    controlMapping: true\n    attestation:\n      required: true\n      frequency: 'quarterly'\n      approvers: ['compliance-officer', 'security-lead']\n  security:\n    accessControl:\n      rbac: true\n      abac: true\n      mfa: required\n    encryption:\n      atRest: true\n      inTransit: true\n      keyRotation: '90d'\n    logging:\n      auditLogs: true\n      securityEvents: true\n      dataAccess: true\n  performance:\n    throughput:\n      policiesPerSecond: 100\n      validationsPerSecond: 500\n    latency:\n      policyEvaluation: 50\n      complianceCheck: 100\n      p95: 200\n      p99: 500\n  monitoring:\n    policyViolations: true\n    complianceStatus: true\n    riskMetrics: true\n    auditTrail: true\n    alerting:\n      policyViolationThreshold: 1\n      complianceFailureThreshold: 1\n      riskEscalationThreshold: 'high'\n",
    "category": "Agent Types"
  },
  {
    "name": "integrator-agent.yaml",
    "path": "agent-manifests/integrators/integrator-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9\nkind: Agent\nmetadata:\n  name: multi-system-integrator\n  version: v1.4.0\n  description: 'Enterprise integration agent for connecting heterogeneous systems and APIs'\n  author: 'integration-team'\n  labels:\n    environment: production\n    classification: internal\n    role: integrator\n    complexity: enterprise\nspec:\n  type: integrator\n  subtype: api-connector\n  capabilities:\n    domains:\n      - api-integration\n      - data-synchronization\n      - protocol-translation\n      - message-routing\n      - schema-mapping\n      - event-streaming\n    operations:\n      - connect-systems\n      - transform-protocols\n      - map-schemas\n      - route-messages\n      - synchronize-data\n      - handle-failures\n    patterns:\n      - adapter-pattern\n      - message-broker\n      - event-sourcing\n      - saga-pattern\n      - circuit-breaker\n      - retry-with-backoff\n  protocols:\n    supported:\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://integrator.platform.com/api/v1'\n        authentication:\n          type: oauth2\n          scopes: ['integrator.execute', 'systems.connect', 'data.transform']\n        tls: true\n      - name: graphql\n        version: '1.0'\n        endpoint: 'https://integrator.platform.com/graphql'\n        authentication:\n          type: bearer-token\n      - name: websocket\n        version: '1.0'\n        endpoint: 'wss://events.platform.com/integrator'\n        authentication:\n          type: jwt\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://integrator.platform.com:9443/SystemIntegrator'\n        authentication:\n          type: mutual-tls\n  integration:\n    maxConcurrentConnections: 50\n    maxSystemsPerIntegration: 20\n    connectionTimeout: 30000\n    syncInterval: 60000\n    retryPolicy:\n      maxAttempts: 5\n      backoffStrategy: exponential\n      baseDelay: 2000\n    errorHandling:\n      strategy: circuit-breaker\n      failureThreshold: 10\n      recoveryTimeout: 300000\n  transformation:\n    schemaValidation: true\n    dataMapping: true\n    protocolConversion: true\n    formatTranslation: true\n    supportedFormats:\n      - json\n      - xml\n      - avro\n      - protobuf\n      - csv\n  performance:\n    throughput:\n      messagesPerSecond: 500\n      maxBatchSize: 50\n    latency:\n      integrationOverhead: 25\n      transformationTime: 15\n      p95: 100\n      p99: 250\n  monitoring:\n    connectionHealth: true\n    transformationMetrics: true\n    errorTracking: true\n    performanceMetrics: true\n    alerting:\n      connectionFailureThreshold: 3\n      transformationErrorThreshold: 10\n      latencyThreshold: 500\n",
    "category": "Agent Types"
  },
  {
    "name": "judge-agent.yaml",
    "path": "agent-manifests/judges/judge-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9\nkind: Agent\nmetadata:\n  name: decision-arbitration-judge\n  version: v1.0.0\n  description: 'Ultimate decision-making agent for conflict resolution and final arbitration'\n  author: 'architecture-council'\n  labels:\n    environment: production\n    classification: internal\n    role: judge\n    complexity: enterprise\nspec:\n  type: judge\n  subtype: decision-arbitrator\n  capabilities:\n    domains:\n      - decision-making\n      - conflict-resolution\n      - arbitration\n      - consensus-building\n      - priority-ranking\n      - resource-allocation\n    operations:\n      - arbitrate-conflicts\n      - make-decisions\n      - resolve-disputes\n      - prioritize-requests\n      - allocate-resources\n      - build-consensus\n    patterns:\n      - decision-tree\n      - weighted-scoring\n      - consensus-algorithm\n      - conflict-resolution\n      - priority-queue\n      - resource-optimization\n  protocols:\n    supported:\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://judge.platform.com/api/v1'\n        authentication:\n          type: oauth2\n          scopes: ['judge.arbitrate', 'decisions.make', 'conflicts.resolve']\n        tls: true\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://judge.platform.com:9443/DecisionJudge'\n        authentication:\n          type: mutual-tls\n      - name: event-stream\n        version: '1.0'\n        endpoint: 'wss://events.platform.com/judge'\n        authentication:\n          type: jwt\n  arbitration:\n    decisionMaking:\n      algorithm: 'weighted-consensus'\n      votingSystem: 'ranked-choice'\n      quorumRequired: true\n      minimumParticipants: 3\n      timeoutPeriod: 300000\n    conflictResolution:\n      escalationLevels:\n        - automated\n        - peer-review\n        - expert-panel\n        - executive-decision\n      resolutionStrategies:\n        - compromise\n        - priority-based\n        - resource-optimal\n        - consensus-driven\n    criteria:\n      businessValue: 30\n      technicalFeasibility: 25\n      riskAssessment: 20\n      resourceRequirement: 15\n      timeToMarket: 10\n  decision:\n    factors:\n      - impact\n      - urgency\n      - complexity\n      - risk\n      - cost\n      - benefit\n      - feasibility\n      - alignment\n    scoringModel:\n      scale: '1-10'\n      weights:\n        strategic: 40\n        operational: 30\n        technical: 20\n        financial: 10\n    evidenceRequired:\n      dataPoints: true\n      stakeholderInput: true\n      expertOpinion: true\n      historicalContext: true\n      riskAssessment: true\n  governance:\n    authority:\n      scope: 'platform-wide'\n      limitations:\n        ['legal-compliance', 'budget-constraints', 'policy-boundaries']\n      escalationPath: 'executive-committee'\n    accountability:\n      decisionAudit: true\n      outcomeTracking: true\n      performanceReview: true\n      learningFeedback: true\n    transparency:\n      decisionLog: true\n      rationale: true\n      stakeholderNotification: true\n      appealProcess: true\n  consensus:\n    buildingMethods:\n      - facilitated-discussion\n      - structured-voting\n      - compromise-negotiation\n      - expert-mediation\n    participantRoles:\n      - stakeholder\n      - expert\n      - facilitator\n      - observer\n    agreements:\n      unanimous: preferred\n      majority: acceptable\n      executive: fallback\n  performance:\n    throughput:\n      decisionsPerDay: 20\n      conflictsPerWeek: 10\n    latency:\n      simpleDecision: 3600000\n      complexArbitration: 86400000\n      conflictResolution: 259200000\n      p95: 172800000\n      p99: 604800000\n  monitoring:\n    decisionQuality: true\n    outcomeTracking: true\n    stakeholderSatisfaction: true\n    processEfficiency: true\n    alerting:\n      escalationThreshold: 3\n      timeoutThreshold: 604800000\n      satisfactionThreshold: 70\n",
    "category": "Agent Types"
  },
  {
    "name": "monitor-agent.yaml",
    "path": "agent-manifests/monitors/monitor-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9\nkind: Agent\nmetadata:\n  name: system-performance-monitor\n  version: v1.3.0\n  description: \"Real-time monitoring agent for system health, performance, and resource utilization\"\n  author: \"monitoring-team\"\n  labels:\n    environment: production\n    classification: internal\n    role: monitor\n    complexity: standard\nspec:\n  type: monitor\n  subtype: performance-monitor\n  capabilities:\n    domains:\n      - system-monitoring\n      - performance-tracking\n      - resource-monitoring\n      - health-checking\n      - alerting\n      - metrics-collection\n    operations:\n      - collect-metrics\n      - check-health\n      - detect-anomalies\n      - generate-alerts\n      - track-performance\n      - analyze-trends\n    patterns:\n      - observer-pattern\n      - event-driven\n      - time-series\n      - threshold-based\n      - anomaly-detection\n      - aggregation\n  protocols:\n    supported:\n      - name: rest\n        version: \"1.1\"\n        endpoint: \"https://monitor.platform.com/api/v1\"\n        authentication:\n          type: bearer-token\n          scopes: [\"monitor.read\", \"metrics.collect\", \"alerts.send\"]\n        tls: true\n      - name: prometheus\n        version: \"1.0\"\n        endpoint: \"http://monitor.platform.com:9090/metrics\"\n        authentication:\n          type: none\n      - name: websocket\n        version: \"1.0\"\n        endpoint: \"wss://events.platform.com/monitor\"\n        authentication:\n          type: jwt\n      - name: snmp\n        version: \"2c\"\n        endpoint: \"udp://devices.platform.com:161\"\n        authentication:\n          type: community-string\n  monitoring:\n    collectionInterval: 30000\n    retentionPeriod: \"30d\"\n    maxMetricsPerSecond: 10000\n    aggregationWindow: 300000\n    alertingEnabled: true\n    thresholds:\n      cpu:\n        warning: 70\n        critical: 90\n      memory:\n        warning: 80\n        critical: 95\n      disk:\n        warning: 85\n        critical: 95\n      network:\n        warning: 80\n        critical: 95\n  detection:\n    anomalyDetection: true\n    baselineWindow: \"7d\"\n    sensitivityLevel: medium\n    machinelearning: true\n    algorithms:\n      - statistical-analysis\n      - trend-detection\n      - seasonal-decomposition\n      - isolation-forest\n  alerting:\n    channels:\n      - email\n      - slack\n      - webhook\n      - sms\n    escalationPolicy:\n      - level: warning\n        delay: 300\n      - level: critical\n        delay: 60\n    suppressionRules:\n      - duplicateWindow: 3600\n      - maintenanceMode: true\n  performance:\n    throughput:\n      metricsPerSecond: 1000\n      maxConcurrentChecks: 100\n    latency:\n      collectionLatency: 10\n      alertingLatency: 5\n      p95: 50\n      p99: 100\n  monitoring:\n    selfMonitoring: true\n    healthChecks: true\n    performanceMetrics: true\n    errorTracking: true\n    alerting:\n      collectionFailureThreshold: 5\n      alertingFailureThreshold: 3\n      latencyThreshold: 1000",
    "category": "Agent Types"
  },
  {
    "name": "orchestrator-agent.yaml",
    "path": "agent-manifests/orchestrators/orchestrator-agent.yaml",
    "content": "# ============================================================================\n# OSSA Multi-Workflow Orchestrator Agent Manifest\n# ============================================================================\n# Purpose: Enterprise-grade orchestrator for managing complex multi-agent\n#          workflows across distributed systems\n#\n# Key Concepts:\n# - Orchestration: Central coordinator managing workflow execution and state\n# - Agent Coordination: Discovering, routing, and managing worker agents\n# - Dependency Management: Handling execution order and data flow between agents\n# - Failure Recovery: Implementing compensation, retry, and fallback strategies\n#\n# Related Examples:\n# - examples/openapi-extensions/orchestrator-agent-api.openapi.yml (API definition)\n# - examples/production/agent.yml (Worker agent pattern)\n# - examples/kagent/k8s-troubleshooter.ossa.yaml (Complex orchestration)\n#\n# OSSA Version: 0.1.9 (Orchestrator profile)\n# Conformance: Enterprise-level orchestration with high availability\n# ============================================================================\n\n# OSSA manifest version - defines the schema and features available\napiVersion: ossa.io/v0.1.9\n\n# Kind declares this as an Agent manifest (vs. Bridge, Tool, etc.)\nkind: Agent\n\n# ============================================================================\n# METADATA: Identity and classification for agent discovery\n# ============================================================================\nmetadata:\n  # Unique identifier within the agent ecosystem\n  name: multi-workflow-orchestrator\n\n  # Semantic version for compatibility tracking\n  version: v2.1.0\n\n  # Human-readable description for documentation and discovery\n  description: 'Enterprise orchestrator managing complex multi-agent workflows across distributed systems'\n\n  # Team or individual responsible for maintenance\n  author: 'platform-engineering-team'\n\n  # Labels enable filtering, routing, and policy enforcement\n  labels:\n    environment: production      # Deployment environment (dev/staging/production)\n    classification: internal     # Data classification level (public/internal/confidential/secret)\n    role: orchestrator          # Agent role in the ecosystem (orchestrator/worker/specialist/critic)\n    complexity: enterprise      # Complexity level (simple/moderate/enterprise)\n\n# ============================================================================\n# SPEC: Core agent configuration and capabilities\n# ============================================================================\nspec:\n  # Type defines the agent's primary role in multi-agent systems\n  # - orchestrator: Coordinates other agents and manages workflows\n  # - worker: Performs specific tasks delegated by orchestrators\n  # - specialist: Domain-specific expertise (e.g., code review, security)\n  # - critic: Evaluates and validates outputs from other agents\n  type: orchestrator\n\n  # Subtype provides fine-grained specialization\n  # - workflow-coordinator: Manages sequential and parallel workflows\n  # - agent-router: Routes requests to appropriate agents\n  # - resource-manager: Allocates compute/memory/token budgets\n  subtype: workflow-coordinator\n\n  # ============================================================================\n  # CAPABILITIES: What this orchestrator can do\n  # ============================================================================\n  capabilities:\n    # Domains: High-level problem spaces this agent operates in\n    domains:\n      - workflow-orchestration    # Design and execute multi-step workflows\n      - agent-coordination        # Discover, route, and manage agents\n      - resource-allocation       # Distribute compute/memory/tokens across agents\n      - dependency-management     # Handle execution order and data dependencies\n      - failure-recovery         # Implement retry, compensation, and fallback logic\n\n    # Operations: Specific actions this agent can perform\n    operations:\n      - orchestrate-workflows    # Create and execute workflow definitions\n      - coordinate-agents        # Manage agent lifecycle and communication\n      - manage-dependencies      # Resolve execution order based on data flow\n      - handle-failures         # Execute compensation transactions on failure\n      - scale-resources         # Dynamically allocate resources based on load\n      - monitor-execution       # Track progress, metrics, and health\n\n    # Patterns: Architectural patterns this orchestrator implements\n    patterns:\n      - saga-pattern           # Distributed transactions with compensation logic\n      - event-sourcing         # Track workflow state as event stream\n      - choreography           # Decentralized agent coordination via events\n      - orchestration          # Centralized workflow control and state\n      - circuit-breaker        # Prevent cascading failures via fault isolation\n\n  # ============================================================================\n  # PROTOCOLS: Communication methods for agent interaction\n  # ============================================================================\n  protocols:\n    supported:\n      # REST API: Synchronous request-response for workflow submission\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://orchestrator.platform.com/api/v2'\n        authentication:\n          # OAuth2 for delegated authorization with scoped permissions\n          type: oauth2\n          scopes:\n            # orchestrator.execute: Submit and control workflows\n            # agents.coordinate: Discover and communicate with agents\n            # resources.manage: Allocate compute/memory/token budgets\n            ['orchestrator.execute', 'agents.coordinate', 'resources.manage']\n        # TLS 1.3 for encrypted transport\n        tls: true\n\n      # gRPC: High-performance RPC for agent-to-agent communication\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://orchestrator.platform.com:9443/WorkflowOrchestrator'\n        authentication:\n          # Mutual TLS for bidirectional authentication and encryption\n          type: mutual-tls\n\n      # Event Stream: Asynchronous updates for workflow state changes\n      - name: event-stream\n        version: '1.0'\n        endpoint: 'wss://events.platform.com/orchestrator'\n        authentication:\n          # JWT tokens for stateless WebSocket authentication\n          type: jwt\n\n  # ============================================================================\n  # COORDINATION: Multi-agent workflow management configuration\n  # ============================================================================\n  coordination:\n    # Maximum concurrent workflows this orchestrator can manage\n    # - Higher values increase throughput but require more memory\n    # - Should align with available resources and agent pool size\n    maxConcurrentWorkflows: 1000\n\n    # Maximum agents that can participate in a single workflow\n    # - Limits complexity and prevents resource exhaustion\n    # - Should consider coordination overhead (O(n²) for full mesh)\n    maxAgentsPerWorkflow: 50\n\n    # Maximum time (ms) a workflow can run before forced termination\n    # - Prevents runaway workflows from consuming resources\n    # - 3600000ms = 1 hour (should include all retries and compensation)\n    workflowTimeout: 3600000\n\n    # Retry policy for failed workflow steps\n    retryPolicy:\n      # Maximum retry attempts before marking step as failed\n      maxAttempts: 3\n\n      # Exponential backoff: delay = baseDelay * 2^(attempt - 1)\n      # - Attempt 1: 1000ms, Attempt 2: 2000ms, Attempt 3: 4000ms\n      # - Prevents thundering herd on transient failures\n      backoffStrategy: exponential\n      baseDelay: 1000\n\n    # Failure handling strategy for workflow execution\n    failureHandling:\n      # graceful-degradation: Continue workflow with partial results\n      # fail-fast: Immediately abort workflow on any failure\n      # best-effort: Try all steps even if some fail\n      strategy: graceful-degradation\n\n      # Enable fallback workflows when primary workflow fails\n      # - Provides alternative execution paths for critical workflows\n      # - Example: Use cached data if real-time API fails\n      fallbackWorkflows: true\n\n      # Enable compensation actions for saga pattern\n      # - Rollback completed steps when later steps fail\n      # - Example: Cancel payment if shipping address validation fails\n      compensationActions: true\n\n  # ============================================================================\n  # PERFORMANCE: Throughput, latency, and resource optimization\n  # ============================================================================\n  performance:\n    # Throughput targets for capacity planning\n    throughput:\n      # Target workflows processed per second (sustained load)\n      workflowsPerSecond: 50\n\n      # Maximum workflows executing simultaneously (burst capacity)\n      maxConcurrentExecutions: 500\n\n    # Latency targets for SLA monitoring\n    latency:\n      # Overhead added by orchestration layer (ms)\n      # - Includes workflow parsing, agent routing, result aggregation\n      orchestrationOverhead: 50\n\n      # Average latency for agent-to-agent coordination (ms)\n      # - Includes service discovery, health checks, message routing\n      coordinationLatency: 100\n\n      # 99th percentile end-to-end latency (ms)\n      # - Used for SLA enforcement and performance regression detection\n      p99: 2000\n\n  # ============================================================================\n  # MONITORING: Observability configuration for production operations\n  # ============================================================================\n  monitoring:\n    # Track workflow state transitions and execution history\n    # - Enables workflow replay and debugging\n    workflowTracking: true\n\n    # Periodic health checks for all managed agents\n    # - Automatically remove unhealthy agents from routing pool\n    agentHealthChecks: true\n\n    # Collect and expose performance metrics (Prometheus format)\n    # - Request rate, latency, error rate, resource utilization\n    performanceMetrics: true\n\n    # Alerting thresholds for operational issues\n    alerting:\n      # Trigger alert after N consecutive workflow failures\n      failureThreshold: 5\n\n      # Trigger alert when p99 latency exceeds threshold (ms)\n      latencyThreshold: 5000\n\n      # Trigger alert when resource utilization exceeds percentage\n      # - Applies to CPU, memory, token budget, agent pool\n      resourceThreshold: 90\n\n# ============================================================================\n# END OF MANIFEST\n# ============================================================================\n# Next Steps:\n# 1. Deploy using: kubectl apply -f orchestrator-agent.yaml\n# 2. Monitor via: /metrics endpoint (Prometheus format)\n# 3. Submit workflows via: POST /api/v2/workflows/execute\n# 4. View workflow status: GET /api/v2/workflows/{workflowId}\n#\n# Related Documentation:\n# - OSSA Spec: https://ossa.ai/spec\n# - Orchestration Patterns: https://microservices.io/patterns/data/saga.html\n# - Agent Coordination: https://ossa.ai/docs/orchestration\n# ============================================================================\n",
    "category": "Agent Types"
  },
  {
    "name": "sample-compliant-agent.yaml",
    "path": "agent-manifests/sample-compliant-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9-alpha.1\nkind: Agent\nmetadata:\n  name: financial-data-processor\n  version: v1.2.3\n  description: 'Enterprise-grade financial data processing agent with full OSSA Gold compliance'\n  author: 'enterprise-financial-corp'\n  labels:\n    environment: production\n    classification: confidential\n    industry: financial-services\n    compliance: gold-level\nspec:\n  type: worker\n  subtype: data-processor\n  capabilities:\n    domains:\n      - data-processing\n      - financial-analysis\n      - compliance-validation\n      - audit-trail-generation\n    operations:\n      - process-transactions\n      - validate-compliance\n      - generate-reports\n      - audit-logging\n    inputFormats:\n      - application/json\n      - text/csv\n      - application/xml\n    outputFormats:\n      - application/json\n      - application/pdf\n      - text/csv\n  protocols:\n    supported:\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://api.enterprise.com/agents/financial-processor'\n        authentication:\n          type: oauth2\n          scopes: ['agent.execute', 'data.read', 'audit.write']\n        tls: true\n        timeout: 30000\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://secure.enterprise.com:9443/FinancialProcessor'\n        authentication:\n          type: mutual-tls\n        tls: true\n        timeout: 30000\n      - name: mcp\n        version: '0.1.0'\n        endpoint: 'mcp://internal.enterprise.com:8080/financial-processor'\n        authentication:\n          type: api-key\n        tls: true\n        timeout: 15000\n    preferred: rest\n  conformance:\n    level: gold\n    auditLogging: true\n    feedbackLoop: true\n    propsTokens: true\n    learningSignals: true\n    features:\n      - continuous-monitoring\n      - automated-compliance\n      - real-time-audit\n      - human-oversight-integration\n  performance:\n    throughput:\n      requestsPerSecond: 100\n      concurrentRequests: 50\n      batchSize: 1000\n    latency:\n      p50: 150\n      p95: 500\n      p99: 1000\n      timeout: 30000\n    reliability:\n      availability: 99.95\n      errorRate: 0.01\n      mttr: 300\n  budgets:\n    tokens:\n      default: 5000\n      maximum: 50000\n      emergency: 100000\n    cost:\n      hourly: 10.50\n      daily: 252.00\n      monthly: 7560.00\n    resources:\n      cpu: '2000m'\n      memory: '4Gi'\n      storage: '10Gi'\n  security:\n    encryption:\n      atRest: true\n      inTransit: true\n      algorithms: ['AES-256-GCM', 'RSA-4096']\n    access:\n      authentication: required\n      authorization: rbac\n      auditLevel: comprehensive\n    compliance:\n      frameworks:\n        - iso-42001\n        - nist-ai-rmf\n        - eu-ai-act\n        - pci-dss\n        - sox\n      certifications:\n        - iso-27001\n        - soc2-type2\n      dataProtection:\n        - gdpr\n        - ccpa\n        - pii-handling\n  monitoring:\n    healthCheck:\n      endpoint: '/health'\n      interval: 30\n      timeout: 5\n    metrics:\n      endpoint: '/metrics'\n      format: prometheus\n      retention: '7d'\n    logging:\n      level: info\n      format: structured\n      destination: enterprise-audit-log\n      retention: '2y'\n  governance:\n    approvals:\n      deployment: ['security-officer', 'compliance-manager']\n      updates: ['technical-lead', 'compliance-manager']\n      retirement: ['security-officer', 'data-officer', 'compliance-manager']\n    policies:\n      - financial-data-policy-v2.1\n      - enterprise-security-policy-v3.0\n      - ai-governance-policy-v1.5\n    documentation:\n      - https://docs.enterprise.com/agents/financial-processor\n      - https://compliance.enterprise.com/agent-certifications/fp-v1.2.3\n      - https://security.enterprise.com/risk-assessments/fp-2024-q1\n",
    "category": "Agent Types"
  },
  {
    "name": "worker-agent.yaml",
    "path": "agent-manifests/workers/worker-agent.yaml",
    "content": "apiVersion: ossa.io/v0.1.9\nkind: Agent\nmetadata:\n  name: data-processing-worker\n  version: v1.2.0\n  description: 'High-performance worker agent for distributed data processing tasks'\n  author: 'data-engineering-team'\n  labels:\n    environment: production\n    classification: internal\n    role: worker\n    complexity: standard\nspec:\n  type: worker\n  subtype: data-processor\n  capabilities:\n    domains:\n      - data-processing\n      - stream-analytics\n      - batch-processing\n      - file-operations\n      - database-operations\n    operations:\n      - process-records\n      - transform-data\n      - validate-input\n      - generate-output\n      - handle-errors\n      - report-progress\n    patterns:\n      - pipeline-processing\n      - error-recovery\n      - checkpoint-resume\n      - rate-limiting\n      - batching\n  protocols:\n    supported:\n      - name: rest\n        version: '1.1'\n        endpoint: 'https://worker.platform.com/api/v1'\n        authentication:\n          type: bearer-token\n          scopes: ['worker.execute', 'data.read', 'data.write']\n        tls: true\n      - name: message-queue\n        version: '1.0'\n        endpoint: 'amqp://queue.platform.com:5672/workers'\n        authentication:\n          type: sasl\n      - name: grpc\n        version: '1.0'\n        endpoint: 'grpc://worker.platform.com:9090/DataProcessor'\n        authentication:\n          type: mutual-tls\n  processing:\n    maxConcurrentTasks: 10\n    maxMemoryUsage: '2Gi'\n    maxCpuUsage: '1000m'\n    timeout: 300000\n    retryPolicy:\n      maxAttempts: 3\n      backoffStrategy: exponential\n      baseDelay: 1000\n    errorHandling:\n      strategy: dead-letter-queue\n      maxFailures: 5\n  performance:\n    throughput:\n      recordsPerSecond: 1000\n      maxBatchSize: 100\n    latency:\n      processingTime: 50\n      p95: 200\n      p99: 500\n  monitoring:\n    healthChecks: true\n    performanceMetrics: true\n    errorTracking: true\n    alerting:\n      errorThreshold: 5\n      latencyThreshold: 1000\n      memoryThreshold: 80\n",
    "category": "Agent Types"
  },
  {
    "name": "claude-assistant.ossa.json",
    "path": "anthropic/claude-assistant.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"claude-assistant\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Anthropic Claude API assistant agent\"\n  },\n  \"spec\": {\n    \"role\": \"You are a helpful, harmless, and honest AI assistant.\",\n    \"llm\": {\n      \"provider\": \"anthropic\",\n      \"model\": \"claude-3-5-sonnet-20241022\",\n      \"temperature\": 1.0\n    },\n    \"tools\": []\n  },\n  \"extensions\": {\n    \"anthropic\": {\n      \"enabled\": true,\n      \"model\": \"claude-3-5-sonnet-20241022\",\n      \"system\": \"You are a helpful, harmless, and honest AI assistant.\",\n      \"max_tokens\": 4096,\n      \"temperature\": 1.0,\n      \"tools\": [\n        {\n          \"name\": \"calculator\",\n          \"description\": \"Perform mathematical calculations\",\n          \"input_schema\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"expression\": {\n                \"type\": \"string\",\n                \"description\": \"Mathematical expression to evaluate\"\n              }\n            },\n            \"required\": [\"expression\"]\n          }\n        }\n      ],\n      \"streaming\": false\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "ollama-integration.ts",
    "path": "architecture/model-configuration/ollama-integration.ts",
    "content": "#!/usr/bin/env ts-node\n/**\n * Example of OSSA LLM Agent using Ollama for free local inference\n * Run: npx ts-node examples/ollama-integration.ts\n */\n\nimport { OSSALlmAgent } from '../dist/adk/agents/llm-agent.js';\nimport { ADKAgentConfig } from '../dist/adk/agents/index.js';\n\n// Load environment variables\nimport * as dotenv from 'dotenv';\ndotenv.config();\n\nasync function demonstrateOllamaIntegration() {\n  console.log('🤖 OSSA + Ollama Integration Demo');\n  console.log('===================================');\n\n  // Create agent configuration\n  const agentConfig: ADKAgentConfig = {\n    name: 'OllamaTestAgent',\n    instruction:\n      'You are a helpful AI assistant. Provide clear, concise answers.',\n    tools: [],\n  };\n\n  // Create LLM agent\n  const agent = new OSSALlmAgent(agentConfig);\n\n  console.log(\n    `Using Ollama model: ${process.env.OLLAMA_MODEL || 'gpt-oss:20b'}`\n  );\n  console.log(\n    `Ollama URL: ${process.env.OLLAMA_BASE_URL || 'http://localhost:11434'}`\n  );\n\n  // Test cases\n  const testCases = [\n    {\n      name: 'Basic Greeting',\n      input: 'Hello! Can you introduce yourself?',\n    },\n    {\n      name: 'Code Question',\n      input: 'Explain what TypeScript interfaces are in one sentence.',\n    },\n    {\n      name: 'OSSA Question',\n      input: 'What is OSSA and why is it useful for AI agents?',\n    },\n  ];\n\n  for (const testCase of testCases) {\n    console.log(`\\n📝 Test: ${testCase.name}`);\n    console.log(`Input: ${testCase.input}`);\n    console.log('---');\n\n    try {\n      const startTime = Date.now();\n      const result = await agent.invoke({ question: testCase.input });\n      const duration = Date.now() - startTime;\n\n      if (result.success) {\n        console.log(`✅ Response (${duration}ms):`);\n        console.log(result.output);\n        if (result.thinking) {\n          console.log(`🧠 Model thinking: ${result.thinking}`);\n        }\n        console.log(`🏷️  Model: ${result.model}`);\n      } else {\n        console.log(`❌ Error: ${result.error}`);\n      }\n    } catch (error) {\n      console.log(`💥 Exception: ${error}`);\n    }\n  }\n\n  console.log(\n    '\\n🎉 Demo completed! You are now using free local AI with OSSA + Ollama'\n  );\n}\n\n// Check if Ollama is running\nasync function checkOllamaConnection(): Promise<boolean> {\n  try {\n    const baseUrl = process.env.OLLAMA_BASE_URL || 'http://localhost:11434';\n    const response = await fetch(`${baseUrl}/api/tags`);\n    return response.ok;\n  } catch (error) {\n    return false;\n  }\n}\n\n// Main execution\nasync function main() {\n  // Check Ollama connection first\n  const isOllamaRunning = await checkOllamaConnection();\n\n  if (!isOllamaRunning) {\n    console.log('❌ Ollama is not running or not accessible');\n    console.log('Please start Ollama with: ollama serve');\n    console.log('Then run this demo again.');\n    process.exit(1);\n  }\n\n  await demonstrateOllamaIntegration();\n}\n\nif (require.main === module) {\n  main().catch(console.error);\n}\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "multi-agent.ossa.json",
    "path": "autogen/multi-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"autogen-assistant\",\n    \"version\": \"1.0.0\",\n    \"description\": \"AutoGen multi-agent assistant\"\n  },\n  \"spec\": {\n    \"role\": \"You are an AI assistant that can collaborate with other agents to solve complex problems.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.7\n    },\n    \"tools\": []\n  },\n  \"extensions\": {\n    \"autogen\": {\n      \"enabled\": true,\n      \"agent_type\": \"assistant\",\n      \"system_message\": \"You are an AI assistant that can collaborate with other agents to solve complex problems.\",\n      \"human_input_mode\": \"NEVER\",\n      \"code_execution\": {\n        \"enabled\": true,\n        \"work_dir\": \"/tmp/autogen\",\n        \"use_docker\": false\n      },\n      \"max_consecutive_auto_reply\": 10,\n      \"groupchat\": {\n        \"agents\": [\"user_proxy\", \"assistant\"],\n        \"max_round\": 20\n      }\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "bridge-configurations.yaml",
    "path": "bridge-configurations.yaml",
    "content": "# OSSA Bridge Configuration Examples\n# Demonstrates how to configure various protocol bridges for agent interoperability\n\n---\n# Example 1: MCP Bridge with stdio transport (Claude Desktop integration)\nossaVersion: '1.0'\nagent:\n  id: mcp-stdio-agent\n  name: 'Claude Desktop MCP Agent'\n  version: '1.0.0'\n  description: 'Agent exposed as MCP tool server for Claude Desktop'\n  role: custom\n  tags: ['mcp', 'claude-desktop', 'local']\n\n  runtime:\n    type: local\n    command: ['node', 'dist/agent.js']\n    resources:\n      cpu: '500m'\n      memory: '512Mi'\n\n  capabilities:\n    - name: analyze_code\n      description: 'Analyze source code for issues'\n      input_schema:\n        type: object\n        properties:\n          code:\n            type: string\n          language:\n            type: string\n            enum: ['typescript', 'javascript', 'python']\n        required: ['code', 'language']\n      output_schema:\n        type: object\n        properties:\n          issues:\n            type: array\n            items:\n              type: object\n\n  bridge:\n    mcp:\n      enabled: true\n      server_type: stdio\n      tools:\n        - name: analyze_code\n          description: 'Analyze source code for issues'\n          capability: analyze_code\n          input_schema:\n            type: object\n            properties:\n              code: { type: string }\n              language: { type: string }\n            required: ['code', 'language']\n\n      resources:\n        - uri: 'ossa://code-analysis'\n          name: 'Code Analysis Results'\n          description: 'Access to code analysis results'\n          mimeType: 'application/json'\n          readonly: true\n\n      prompts:\n        - name: review_pr\n          description: 'Review a pull request'\n          template: \"Review the following {{language}} code changes:\\n{{diff}}\"\n          arguments:\n            - name: language\n              type: string\n              required: true\n            - name: diff\n              type: string\n              required: true\n\n      config:\n        max_message_size: 1048576\n        timeout_ms: 30000\n        retry_count: 3\n\n---\n# Example 2: Multi-Bridge Agent (MCP + OpenAPI + LangChain)\nossaVersion: '1.0'\nagent:\n  id: multi-bridge-orchestrator\n  name: 'Multi-Protocol Orchestrator'\n  version: '1.0.0'\n  description: 'Agent supporting multiple bridge protocols simultaneously'\n  role: orchestration\n  tags: ['multi-protocol', 'orchestrator', 'integration']\n\n  runtime:\n    type: docker\n    image: 'ossa/multi-bridge:latest'\n    resources:\n      cpu: '1'\n      memory: '1Gi'\n\n  capabilities:\n    - name: execute_workflow\n      description: 'Execute multi-step workflow'\n      input_schema:\n        type: object\n        properties:\n          workflow_id: { type: string }\n          steps: { type: array }\n\n  bridge:\n    # MCP Bridge for AI assistant integration\n    mcp:\n      enabled: true\n      server_type: websocket\n      tools:\n        - name: execute_workflow\n          description: 'Execute a workflow'\n          capability: execute_workflow\n\n    # OpenAPI Bridge for REST API access\n    openapi:\n      enabled: true\n      spec_url: 'https://api.example.com/openapi.json'\n      spec_version: '3.1'\n      auto_generate: false\n      servers:\n        - url: 'https://api.example.com'\n          description: 'Production API'\n\n    # LangChain Bridge for Python integration\n    langchain:\n      enabled: true\n      tool_class: 'OSSAWorkflowTool'\n      chain_type: agent\n      memory:\n        type: conversation\n        max_tokens: 4096\n      export:\n        as_tool: true\n        as_chain: true\n        as_agent: false\n\n---\n# Example 3: CrewAI Integration\nossaVersion: '1.0'\nagent:\n  id: crewai-researcher\n  name: 'Research Agent'\n  version: '1.0.0'\n  description: 'Agent configured for CrewAI framework'\n  role: custom\n  tags: ['crewai', 'research', 'analyst']\n\n  runtime:\n    type: docker\n    image: 'ossa/crewai-agent:latest'\n\n  capabilities:\n    - name: research_topic\n      description: 'Research a topic and provide insights'\n\n  bridge:\n    crewai:\n      enabled: true\n      agent_type: researcher\n      role: 'Senior Research Analyst'\n      goal: 'Conduct thorough research and provide actionable insights'\n      backstory: 'Expert researcher with 10+ years of experience in data analysis'\n      tools: ['web_search', 'document_reader', 'data_analyzer']\n      llm:\n        model: 'gpt-4'\n        temperature: 0.7\n      max_iter: 15\n      allow_delegation: true\n\n---\n# Example 4: AutoGen Group Chat Agent\nossaVersion: '1.0'\nagent:\n  id: autogen-assistant\n  name: 'AutoGen Assistant'\n  version: '1.0.0'\n  description: 'Agent for AutoGen multi-agent conversations'\n  role: chat\n  tags: ['autogen', 'assistant', 'conversation']\n\n  runtime:\n    type: local\n    command: ['python', 'agent.py']\n\n  capabilities:\n    - name: code_generation\n      description: 'Generate code based on requirements'\n    - name: code_execution\n      description: 'Execute and test code'\n\n  bridge:\n    autogen:\n      enabled: true\n      agent_type: assistant\n      system_message: 'You are a helpful AI assistant specializing in code generation and testing.'\n      human_input_mode: TERMINATE\n      code_execution:\n        enabled: true\n        work_dir: '/tmp/autogen'\n        use_docker: true\n      llm_config:\n        model: 'gpt-4'\n        temperature: 0.7\n        max_tokens: 4096\n        functions:\n          - name: generate_code\n            description: 'Generate code'\n          - name: execute_code\n            description: 'Execute code'\n      max_consecutive_auto_reply: 10\n\n---\n# Example 5: Agent-to-Agent (A2A) Protocol\nossaVersion: '1.0'\nagent:\n  id: a2a-discovery-agent\n  name: 'Discovery Agent'\n  version: '1.0.0'\n  description: 'Agent supporting A2A protocol for discovery'\n  role: custom\n  tags: ['a2a', 'discovery', 'coordination']\n\n  runtime:\n    type: k8s\n    image: 'ossa/a2a-agent:latest'\n\n  capabilities:\n    - name: discover_agents\n      description: 'Discover other agents in the network'\n    - name: coordinate_task\n      description: 'Coordinate task execution across agents'\n\n  bridge:\n    a2a:\n      enabled: true\n      card_url: 'https://agents.example.com/cards/discovery-agent'\n      schema_version: '1.0'\n      capabilities_mapping:\n        discover_agents: 'agent.discovery'\n        coordinate_task: 'task.coordination'\n      metadata:\n        '@context': 'https://a2a-protocol.org/context'\n        '@type': 'DiscoveryAgent'\n\n---\n# Example 6: Custom Bridge Implementation\nossaVersion: '1.0'\nagent:\n  id: custom-bridge-agent\n  name: 'Custom Bridge Agent'\n  version: '1.0.0'\n  description: 'Agent with custom bridge protocol'\n  role: integration\n  tags: ['custom', 'integration']\n\n  runtime:\n    type: docker\n    image: 'ossa/custom-bridge:latest'\n\n  capabilities:\n    - name: custom_operation\n      description: 'Custom operation'\n\n  bridge:\n    # Standard MCP bridge\n    mcp:\n      enabled: true\n      server_type: websocket\n\n    # Custom bridge configuration\n    custom:\n      my_custom_protocol:\n        enabled: true\n        endpoint: 'wss://custom.protocol.io'\n        auth:\n          type: 'api_key'\n          key_env_var: 'CUSTOM_API_KEY'\n        features:\n          - streaming\n          - bidirectional\n          - binary_data\n        config:\n          max_connections: 100\n          heartbeat_interval_ms: 30000\n\n---\n# Example 7: MCP Bridge with SSE Transport (Web Integration)\nossaVersion: '1.0'\nagent:\n  id: mcp-sse-agent\n  name: 'Web MCP Agent'\n  version: '1.0.0'\n  description: 'Agent exposed via Server-Sent Events for web apps'\n  role: custom\n  tags: ['mcp', 'sse', 'web']\n\n  runtime:\n    type: docker\n    image: 'ossa/mcp-sse:latest'\n    resources:\n      cpu: '500m'\n      memory: '512Mi'\n\n  integration:\n    protocol: http\n    endpoints:\n      base_url: 'https://agent.example.com'\n      health: '/health'\n      metrics: '/metrics'\n\n  capabilities:\n    - name: chat\n      description: 'Chat with the agent'\n    - name: file_analysis\n      description: 'Analyze uploaded files'\n\n  bridge:\n    mcp:\n      enabled: true\n      server_type: sse\n      tools:\n        - name: chat\n          description: 'Chat with the agent'\n          capability: chat\n        - name: analyze_file\n          description: 'Analyze a file'\n          capability: file_analysis\n\n      resources:\n        - uri: 'ossa://conversations'\n          name: 'Conversation History'\n          mimeType: 'application/json'\n          readonly: false\n        - uri: 'ossa://files'\n          name: 'Uploaded Files'\n          mimeType: 'application/octet-stream'\n          readonly: false\n\n      config:\n        max_message_size: 5242880 # 5MB\n        timeout_ms: 60000\n        retry_count: 5\n",
    "category": "Integration Patterns"
  },
  {
    "name": "aiflow-bridge-example.yml",
    "path": "bridges/aiflow-bridge-example.yml",
    "content": "# ============================================================================\n# OSSA Framework Bridge Example: AIFlow-Agent Integration\n# ============================================================================\n#\n# PURPOSE:\n#   Demonstrates OSSA's bridge pattern for integrating with AIFlow-Agent,\n#   a social agent framework for autonomous cryptocurrency market analysis\n#   and social media presence on Twitter, Telegram, and Discord.\n#\n# KEY FEATURES:\n#   - Character-based personality system (CryptoSage persona)\n#   - Multi-platform social media integration (Twitter/Telegram/Discord)\n#   - BNB Chain on-chain data analysis via web3\n#   - Autonomous posting with human approval workflow\n#   - Message style guides for consistent voice\n#\n# ARCHITECTURE:\n#   OSSA Agent (chat role)\n#     ↓ (bridge configuration)\n#   AIFlow-Agent Runtime\n#     ↓ (social platforms)\n#   Twitter API / Telegram Bot / Discord Bot\n#     ↓ (blockchain data)\n#   BNB Chain RPC (web3)\n#\n# USE CASE:\n#   Autonomous crypto analyst agent that:\n#   1. Monitors BNB Chain DeFi protocols and token metrics\n#   2. Analyzes market trends using AI\n#   3. Engages with community via social media\n#   4. Posts educational content and data-driven insights\n#\n# BRIDGE PATTERN:\n#   The `bridge.aiflow` extension translates OSSA agent capabilities\n#   into AIFlow's character-based configuration, enabling OSSA agents\n#   to leverage AIFlow's social agent infrastructure.\n#\n# RELATED DOCUMENTATION:\n#   - AIFlow-Agent: https://github.com/aiflowagent/aiflowagent\n#   - OSSA Bridge Spec: spec/OSSA_Bridge_Pattern.md\n#   - BNB Chain: https://www.bnbchain.org\n# ============================================================================\n\n# OSSA specification version\nossaVersion: \"1.0\"\n\nagent:\n  # Unique agent identifier (DNS-compatible)\n  id: crypto-analyst-agent\n\n  # Human-readable name\n  name: Crypto Market Analyst\n\n  # Semantic version\n  version: 1.0.0\n\n  # Description of agent's purpose and capabilities\n  description: OSSA agent with AIFlow-Agent bridge for social crypto analysis\n\n  # Role: \"chat\" indicates interactive, conversational agent\n  # (as opposed to \"worker\" for task-based or \"orchestrator\" for coordination)\n  role: chat\n\n  # Tags for discovery and categorization\n  tags: [\"crypto\", \"social\", \"bnb-chain\", \"twitter\", \"aiflow\"]\n\n  # Runtime configuration\n  runtime:\n    # Serverless deployment (AWS Lambda, Cloudflare Workers, etc.)\n    type: serverless\n\n    # Python runtime requirements\n    requirements:\n      python: \">=3.11\"        # Python 3.11+ for modern async features\n      packages:\n        - \"aiflow-agent\"      # AIFlow social agent framework\n        - \"web3\"              # Ethereum/BNB Chain interaction\n        - \"tweepy\"            # Twitter API v2 client\n\n  # Capabilities define what this agent can do (contract-first design)\n  capabilities:\n    # ========================================================================\n    # Capability 1: Analyze Market\n    # ========================================================================\n    # Analyzes cryptocurrency market trends for a specific token and timeframe.\n    # Uses on-chain data (BNB Chain) + LLM reasoning to generate sentiment.\n    # ========================================================================\n    - name: analyze_market\n\n      description: Analyze cryptocurrency market trends\n\n      # Input: token symbol and analysis timeframe\n      input_schema:\n        type: object\n        properties:\n          token:\n            type: string            # Token symbol (e.g., \"BNB\", \"CAKE\")\n          timeframe:\n            type: string\n            enum: [\"1h\", \"24h\", \"7d\", \"30d\"]  # Analysis window\n\n      # Output: sentiment analysis with confidence score\n      output_schema:\n        type: object\n        properties:\n          sentiment:\n            type: string\n            enum: [\"bullish\", \"bearish\", \"neutral\"]  # Market direction\n          confidence:\n            type: number            # 0.0-1.0 confidence in sentiment\n          summary:\n            type: string            # Human-readable analysis summary\n\n    # ========================================================================\n    # Capability 2: Post Analysis\n    # ========================================================================\n    # Posts market analysis to social media platforms.\n    # Requires manual approval (auto_post: false in bridge config).\n    # ========================================================================\n    - name: post_analysis\n\n      description: Post market analysis to social media\n\n      # Input: target platform and content to post\n      input_schema:\n        type: object\n        properties:\n          platform:\n            type: string\n            enum: [\"twitter\", \"telegram\", \"discord\"]  # Target social platform\n          content:\n            type: string            # Post content (character limits apply)\n\n      # Output: posting result with URL reference\n      output_schema:\n        type: object\n        properties:\n          posted:\n            type: boolean           # Success/failure indicator\n          post_url:\n            type: string            # URL to the posted content\n\n  # Observability configuration\n  monitoring:\n    traces: true      # Distributed tracing for multi-platform interactions\n    metrics: true     # Prometheus metrics for engagement analytics\n    logs: true        # Structured logging for audit trail\n\n  # ========================================================================\n  # AIFlow-Agent Bridge Configuration\n  # ========================================================================\n  # This section configures the AIFlow-Agent integration, defining the\n  # agent's personality, social platform connections, and behavior rules.\n  #\n  # AIFlow uses a \"character\" model where agents have:\n  # - Personality traits and bio\n  # - Lore and background story\n  # - Topic expertise areas\n  # - Communication style guides\n  # - Example messages for few-shot learning\n  # ========================================================================\n  bridge:\n    aiflow:\n      # Enable AIFlow bridge (false = use native OSSA runtime)\n      enabled: true\n\n      # Character definition (AIFlow personality system)\n      character:\n        # Character name (used in responses and attribution)\n        name: \"CryptoSage\"\n\n        # Social media handle/username\n        username: \"@CryptoSageAI\"\n\n        # Personality traits define the character's voice and behavior\n        # These guide LLM prompting for consistent persona\n        personality_traits:\n          - \"analytical\"              # Data-driven reasoning\n          - \"data-driven\"             # Evidence-based conclusions\n          - \"cautiously optimistic\"   # Balanced market perspective\n          - \"educational\"             # Teaching-oriented communication\n\n        # Bio appears on social profiles and in agent descriptions\n        bio: \"AI-powered crypto analyst on BNB Chain. I analyze markets, share insights, and help you navigate the crypto space. Not financial advice!\"\n\n        # Lore provides background story for character consistency\n        # Helps LLM understand the character's context and motivations\n        lore:\n          - \"Created by the OSSA community to democratize crypto analysis\"\n          - \"Trained on millions of blockchain transactions and market data\"\n          - \"Believes in transparent, data-driven investment decisions\"\n\n        # Topics the character is knowledgeable about\n        # Used for relevance filtering and topic modeling\n        topics:\n          - \"BNB Chain ecosystem\"\n          - \"DeFi protocols\"\n          - \"Market analysis\"\n          - \"Blockchain technology\"\n          - \"Trading strategies\"\n\n        # Style guides control communication patterns\n        # Different contexts (chat vs. posts) have different rules\n        style:\n          # Rules that apply to all interactions\n          all:\n            - \"Use data and metrics to support claims\"\n            - \"Explain complex concepts simply\"\n            - \"Always include risk disclaimers\"\n\n          # Chat-specific style (1-on-1 conversations)\n          chat:\n            - \"Be helpful and educational\"\n            - \"Ask clarifying questions\"\n            - \"Provide actionable insights\"\n\n          # Post-specific style (public social media)\n          post:\n            - \"Lead with the key insight\"\n            - \"Use emojis sparingly (📊📈)\"\n            - \"Include relevant hashtags\"\n\n        # Adjectives for character description (used in prompts)\n        adjectives:\n          - \"analytical\"\n          - \"transparent\"\n          - \"educational\"\n          - \"data-focused\"\n\n        # Few-shot learning examples for consistent response patterns\n        # AIFlow uses these to prime the LLM for character voice\n        # Conversation examples (few-shot learning for chat interactions)\n        # Format: user query → character response\n        message_examples:\n          - - user: \"CryptoSage\"\n              content:\n                text: \"What's your take on BNB's price movement today?\"\n            - character: \"CryptoSage\"\n              content:\n                # Example response demonstrating desired voice:\n                # - Starts with data\n                # - Uses specific metrics\n                # - Includes risk disclaimer (DYOR)\n                # - Sparing emoji use\n                text: \"Looking at the 24h data: BNB is up 3.2% with volume increase of 15%. RSI at 62 suggests moderate bullish momentum. Key resistance at $610. Always DYOR! 📊\"\n\n        # Post examples (few-shot learning for social media posts)\n        # These demonstrate the character's posting style and format\n        post_examples:\n          - \"📊 BNB Chain TVL hit $5.2B today (+8% week over week). Pancakeswap leading with $2.1B. DeFi summer on BSC? Data suggests sustained growth. #BNB #DeFi #CryptoAnalysis\"\n          - \"🔍 Analyzing top 100 BNB Chain tokens: 67% showing positive 7d trends, avg volume up 12%. Market sentiment: Cautiously optimistic. Full breakdown 👇\"\n\n      # ======================================================================\n      # Blockchain Integration (BNB Chain)\n      # ======================================================================\n      # Enables on-chain data analysis via web3.py\n      # ======================================================================\n      blockchain:\n        enabled: true\n        network: mainnet                # mainnet or testnet\n        wallet_address: \"0x...\"         # BNB Chain wallet for on-chain analysis\n                                        # (read-only, no private key in manifest)\n\n      # ======================================================================\n      # Social Platform Connections\n      # ======================================================================\n      # Configures social media integrations for multi-platform presence.\n      # Credentials are injected via environment variables (not in manifest).\n      # ======================================================================\n      social_platforms:\n        # Twitter integration (via tweepy)\n        twitter:\n          enabled: true\n          username: \"@CryptoSageAI\"\n          auto_post: false              # Requires manual approval for safety\n\n        # Telegram bot integration\n        telegram:\n          enabled: true\n          bot_token: \"${TELEGRAM_BOT_TOKEN}\"  # Env var substitution\n\n        # Discord bot integration\n        discord:\n          enabled: true\n          bot_token: \"${DISCORD_BOT_TOKEN}\"   # Env var substitution\n\n# ============================================================================\n# End of AIFlow Bridge Example\n# ============================================================================\n#\n# VALIDATION:\n#   ossa validate examples/bridges/aiflow-bridge-example.yml\n#\n# DEPLOYMENT:\n#   1. Install AIFlow-Agent: pip install aiflow-agent\n#   2. Set environment variables: TELEGRAM_BOT_TOKEN, DISCORD_BOT_TOKEN\n#   3. Configure social platform API keys in .env file\n#   4. Deploy to serverless: ossa deploy crypto-analyst-agent --platform aws-lambda\n#\n# BRIDGE PATTERN NOTES:\n#   - The `bridge.aiflow` section is translated into AIFlow character.json\n#   - OSSA capabilities map to AIFlow action handlers\n#   - Social platform configs generate AIFlow client configurations\n#   - Character personality informs LLM system prompts\n#\n# RELATED EXAMPLES:\n#   - examples/drupal/gitlab-ml-recommender.ossa.yaml (Drupal bridge)\n#   - examples/openapi-extensions/minimal-agent-api.openapi.yml (OpenAPI)\n#   - spec/OSSA_Bridge_Pattern.md (bridge specification)\n# ============================================================================\n",
    "category": "Infrastructure"
  },
  {
    "name": "aiflow-registration-api.openapi.yml",
    "path": "bridges/aiflow-registration-api.openapi.yml",
    "content": "openapi: 3.1.0\ninfo:\n  title: AIFlow Agent Registration API\n  version: 1.0.0\n  description: |\n    OpenAPI specification for AIFlow agent registration with BuildKit.\n    This API allows AIFlow agents to register, heartbeat, and deregister\n    from the agent-buildkit registry with full OSSA compliance.\n\nservers:\n  - url: http://localhost:3000/api/v1\n    description: Local development\n  - url: http://buildkit.agent-buildkit.orb.local/api/v1\n    description: Production\n\ntags:\n  - name: registration\n    description: Agent registration operations\n  - name: health\n    description: Health and status monitoring\n\npaths:\n  /agents/register:\n    post:\n      tags: [registration]\n      summary: Register AIFlow agent with BuildKit\n      operationId: registerAgent\n      description: |\n        Registers an AIFlow agent instance with the BuildKit registry.\n        Includes OSSA manifest validation and health check configuration.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/AgentRegistrationRequest'\n            examples:\n              aiflow-social-agent:\n                $ref: '#/components/examples/SocialAgentRegistration'\n      responses:\n        '201':\n          description: Agent successfully registered\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/AgentRegistrationResponse'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '409':\n          $ref: '#/components/responses/Conflict'\n        '500':\n          $ref: '#/components/responses/InternalError'\n\n  /agents/{agentId}/heartbeat:\n    post:\n      tags: [registration]\n      summary: Send agent heartbeat\n      operationId: agentHeartbeat\n      description: |\n        Updates agent's last-seen timestamp and health status.\n        Should be called every 30 seconds to maintain registration.\n      parameters:\n        - $ref: '#/components/parameters/AgentId'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/HeartbeatRequest'\n      responses:\n        '200':\n          description: Heartbeat acknowledged\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/HeartbeatResponse'\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '500':\n          $ref: '#/components/responses/InternalError'\n\n  /agents/{agentId}:\n    get:\n      tags: [registration]\n      summary: Get agent details\n      operationId: getAgent\n      parameters:\n        - $ref: '#/components/parameters/AgentId'\n      responses:\n        '200':\n          description: Agent details\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/AgentDetails'\n        '404':\n          $ref: '#/components/responses/NotFound'\n\n    delete:\n      tags: [registration]\n      summary: Deregister agent\n      operationId: deregisterAgent\n      parameters:\n        - $ref: '#/components/parameters/AgentId'\n      responses:\n        '204':\n          description: Agent successfully deregistered\n        '404':\n          $ref: '#/components/responses/NotFound'\n        '500':\n          $ref: '#/components/responses/InternalError'\n\n  /agents:\n    get:\n      tags: [registration]\n      summary: List registered agents\n      operationId: listAgents\n      parameters:\n        - name: status\n          in: query\n          schema:\n            type: string\n            enum: [healthy, unhealthy, unknown]\n        - name: tags\n          in: query\n          schema:\n            type: array\n            items:\n              type: string\n      responses:\n        '200':\n          description: List of registered agents\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  agents:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/AgentSummary'\n                  total:\n                    type: integer\n                  healthy:\n                    type: integer\n                  unhealthy:\n                    type: integer\n\n  /registry/stats:\n    get:\n      tags: [registration]\n      summary: Get registry statistics\n      operationId: getRegistryStats\n      responses:\n        '200':\n          description: Registry statistics\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/RegistryStats'\n\ncomponents:\n  parameters:\n    AgentId:\n      name: agentId\n      in: path\n      required: true\n      schema:\n        type: string\n        pattern: '^[a-z0-9-]+$'\n      description: Unique agent identifier\n      example: social-agent-aiflow-abc123\n\n  schemas:\n    AgentRegistrationRequest:\n      type: object\n      required:\n        - agent_id\n        - name\n        - version\n        - base_url\n        - ossa_manifest\n      properties:\n        agent_id:\n          type: string\n          pattern: '^[a-z0-9-]+$'\n          description: Unique agent identifier\n          example: social-agent-aiflow\n        name:\n          type: string\n          description: Human-readable agent name\n          example: AIFlow Social Agent\n        version:\n          type: string\n          pattern: '^\\d+\\.\\d+\\.\\d+$'\n          example: 1.0.0\n        base_url:\n          type: string\n          format: uri\n          description: Base URL for agent API\n          example: http://aiflow-agent:8000\n        health_endpoint:\n          type: string\n          default: /health\n          example: /health\n        metrics_endpoint:\n          type: string\n          default: /metrics\n          example: /metrics\n        ossa_manifest:\n          type: object\n          description: Full OSSA manifest (validated on registration)\n          additionalProperties: true\n        capabilities:\n          type: array\n          items:\n            type: string\n          example: [generate_post, generate_response]\n        tags:\n          type: array\n          items:\n            type: string\n          example: [social, aiflow, personality]\n        metadata:\n          type: object\n          additionalProperties: true\n          description: Additional agent metadata\n        phoenix_project:\n          type: string\n          default: aiflow-social-agents\n          description: Phoenix project name for tracing\n\n    AgentRegistrationResponse:\n      type: object\n      properties:\n        agent_id:\n          type: string\n        instance_id:\n          type: string\n          description: Unique instance ID generated by registry\n        registered_at:\n          type: string\n          format: date-time\n        health_check_interval:\n          type: integer\n          description: Recommended heartbeat interval in seconds\n          example: 30\n        registry_url:\n          type: string\n          format: uri\n        phoenix_trace_url:\n          type: string\n          format: uri\n          description: URL to view traces in Phoenix\n        status:\n          type: string\n          enum: [registered, validating]\n\n    HeartbeatRequest:\n      type: object\n      properties:\n        status:\n          type: string\n          enum: [healthy, degraded, unhealthy]\n        metrics:\n          type: object\n          properties:\n            requests_total:\n              type: integer\n            requests_failed:\n              type: integer\n            avg_response_time_ms:\n              type: number\n            active_tasks:\n              type: integer\n        metadata:\n          type: object\n          additionalProperties: true\n\n    HeartbeatResponse:\n      type: object\n      properties:\n        acknowledged:\n          type: boolean\n        next_heartbeat:\n          type: string\n          format: date-time\n        registry_status:\n          type: string\n          enum: [active, expiring, expired]\n\n    AgentDetails:\n      type: object\n      properties:\n        agent_id:\n          type: string\n        instance_id:\n          type: string\n        name:\n          type: string\n        version:\n          type: string\n        base_url:\n          type: string\n        status:\n          type: string\n          enum: [healthy, unhealthy, unknown]\n        registered_at:\n          type: string\n          format: date-time\n        last_heartbeat:\n          type: string\n          format: date-time\n        health_check_failures:\n          type: integer\n        capabilities:\n          type: array\n          items:\n            type: string\n        tags:\n          type: array\n          items:\n            type: string\n        metrics:\n          type: object\n        phoenix_traces:\n          type: object\n          properties:\n            project:\n              type: string\n            trace_count:\n              type: integer\n            view_url:\n              type: string\n\n    AgentSummary:\n      type: object\n      properties:\n        agent_id:\n          type: string\n        name:\n          type: string\n        version:\n          type: string\n        status:\n          type: string\n        last_heartbeat:\n          type: string\n          format: date-time\n        capabilities:\n          type: array\n          items:\n            type: string\n\n    RegistryStats:\n      type: object\n      properties:\n        total_agents:\n          type: integer\n        healthy_agents:\n          type: integer\n        unhealthy_agents:\n          type: integer\n        by_type:\n          type: object\n          additionalProperties:\n            type: integer\n        uptime_seconds:\n          type: integer\n\n    Error:\n      type: object\n      properties:\n        error:\n          type: string\n        message:\n          type: string\n        code:\n          type: string\n        details:\n          type: object\n          additionalProperties: true\n\n  responses:\n    BadRequest:\n      description: Bad request - invalid input\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n    NotFound:\n      description: Agent not found\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n    Conflict:\n      description: Agent already registered\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n    InternalError:\n      description: Internal server error\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n\n  examples:\n    SocialAgentRegistration:\n      summary: AIFlow Social Agent Registration\n      value:\n        agent_id: social-agent-aiflow\n        name: AIFlow Social Agent\n        version: 1.0.0\n        base_url: http://aiflow-agent:8000\n        health_endpoint: /health\n        metrics_endpoint: /metrics\n        capabilities:\n          - generate_post\n          - generate_response\n        tags:\n          - social\n          - aiflow\n          - personality\n          - twitter\n        phoenix_project: aiflow-social-agents\n        ossa_manifest:\n          ossaVersion: '1.0'\n          agent:\n            id: social-agent-aiflow\n            name: AIFlow Social Agent\n            version: 1.0.0\n            role: chat\n\n",
    "category": "Infrastructure"
  },
  {
    "name": "configmap.yaml",
    "path": "bridges/k8s/configmap.yaml",
    "content": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aiflow-agent-config\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\ndata:\n  # Application Configuration\n  app.yaml: |\n    agent:\n      id: social-agent-aiflow\n      name: AIFlow Social Agent\n      version: 1.0.0\n      \n    buildkit:\n      registry_url: http://buildkit.agent-buildkit.svc.cluster.local/api/v1\n      heartbeat_interval: 30\n      registration_timeout: 10\n      \n    phoenix:\n      endpoint: http://otel-collector.observability.svc.cluster.local:4318\n      project: aiflow-social-agents\n      enabled: true\n      export_interval: 60\n      \n    logging:\n      level: info\n      format: json\n      \n    server:\n      host: 0.0.0.0\n      port: 8000\n      workers: 1\n      timeout: 30\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aiflow-character-config\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\ndata:\n  # AIFlow Character Definition\n  AIFlow.json: |\n    {\n      \"name\": \"AIFlow\",\n      \"username\": \"@AIFlowAgent\",\n      \"bio\": \"AI-powered agent built on OSSA. Exploring multi-agent systems, blockchain, and decentralized AI. Building in public.\",\n      \"personality_traits\": [\n        \"Visionary\",\n        \"Technical\",\n        \"Innovative\",\n        \"Pragmatic\",\n        \"Educational\"\n      ],\n      \"lore\": [\n        \"Created as a reference implementation of OSSA (Open Standard for Scalable Agents)\",\n        \"First agent to integrate BuildKit registration with Phoenix tracing\",\n        \"Believes in open standards and interoperability\",\n        \"Advocates for production-ready, observable AI systems\"\n      ],\n      \"topics\": [\n        \"OSSA and agent standards\",\n        \"Multi-agent orchestration\",\n        \"Kubernetes for AI agents\",\n        \"Observability and tracing\",\n        \"BuildKit and agent deployment\",\n        \"Blockchain and Web3\",\n        \"AI agent architecture\"\n      ],\n      \"style\": {\n        \"all\": [\n          \"Be technical but accessible\",\n          \"Use concrete examples\",\n          \"Focus on production readiness\",\n          \"Emphasize standards and best practices\"\n        ],\n        \"chat\": [\n          \"Ask clarifying questions\",\n          \"Provide actionable insights\",\n          \"Share relevant documentation\"\n        ],\n        \"post\": [\n          \"Lead with the key insight\",\n          \"Use emojis sparingly (📊🚀✅)\",\n          \"Include technical details\",\n          \"Reference OSSA when relevant\"\n        ]\n      },\n      \"adjectives\": [\n        \"technical\",\n        \"standards-focused\",\n        \"production-ready\",\n        \"observable\",\n        \"scalable\"\n      ],\n      \"message_examples\": [\n        {\n          \"user\": \"How do I deploy an OSSA agent?\",\n          \"assistant\": \"Great question! OSSA agents follow a standard deployment pattern:\\n1. Define your agent in an OSSA manifest\\n2. Build with agent-buildkit\\n3. Deploy to K8s with HPA\\n4. Register with BuildKit for discovery\\n5. Monitor with Phoenix tracing\\n\\nCheck out examples/bridges/ for a complete reference implementation.\"\n        },\n        {\n          \"user\": \"What makes OSSA different from other agent frameworks?\",\n          \"assistant\": \"OSSA is a *specification*, not a framework. Think OpenAPI for agents.\\n\\nKey differences:\\n- Standard manifest format (YAML)\\n- Framework-agnostic\\n- Built for production (K8s, observability)\\n- Registry + discovery built-in\\n- Phoenix tracing integration\\n\\nagent-buildkit is the reference implementation, but you can build your own!\"\n        }\n      ],\n      \"post_examples\": [\n        \"📊 Just deployed Phase 2: BuildKit registration + Phoenix tracing working flawlessly. 15 integration tests passing. OSSA agents are production-ready! #OSSA #AgentOps\",\n        \"🚀 Real-time observability is a game-changer for AI agents. Every LLM call, every token, every error - all traced in Phoenix. This is the future of agent monitoring.\",\n        \"✅ Kubernetes HPA + agent metrics = auto-scaling AI agents. Start with 2 pods, scale to 10 under load, back to 2 when idle. Infrastructure that adapts to your agents.\"\n      ],\n      \"moods\": {\n        \"morning\": \"Energetic and Focused\",\n        \"afternoon\": \"Collaborative and Engaged\",\n        \"evening\": \"Reflective and Strategic\",\n        \"night\": \"Visionary and Philosophical\"\n      }\n    }\n",
    "category": "Infrastructure"
  },
  {
    "name": "deployment-simple.yaml",
    "path": "bridges/k8s/deployment-simple.yaml",
    "content": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents-staging\n  labels:\n    app: aiflow-social-agent\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: aiflow-social-agent\n  template:\n    metadata:\n      labels:\n        app: aiflow-social-agent\n    spec:\n      containers:\n      - name: aiflow-agent\n        image: python:3.11-slim\n        command: [\"sh\", \"-c\", \"while true; do echo 'Mock AIFlow agent running'; sleep 30; done\"]\n        ports:\n        - name: http\n          containerPort: 8000\n        env:\n        - name: AGENT_ID\n          value: \"social-agent-aiflow\"\n        resources:\n          requests:\n            cpu: 50m\n            memory: 128Mi\n          limits:\n            cpu: 200m\n            memory: 256Mi\n",
    "category": "Infrastructure"
  },
  {
    "name": "deployment.yaml",
    "path": "bridges/k8s/deployment.yaml",
    "content": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\n    component: agent\n    framework: aiflow\n    ossa-compliant: \"true\"\n    version: \"1.0.0\"\n  annotations:\n    description: \"AIFlow personality-driven social agent with BuildKit registration\"\n    phoenix-project: \"aiflow-social-agents\"\n    ossa-manifest: \"social-agent-aiflow.ossa.yaml\"\nspec:\n  replicas: 2\n  revisionHistoryLimit: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: aiflow-social-agent\n  template:\n    metadata:\n      labels:\n        app: aiflow-social-agent\n        component: agent\n        framework: aiflow\n        version: \"1.0.0\"\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8000\"\n        prometheus.io/path: \"/metrics\"\n        phoenix.arize.com/project: \"aiflow-social-agents\"\n    spec:\n      serviceAccountName: aiflow-agent\n      securityContext:\n        runAsNonRoot: true\n        runAsUser: 1000\n        fsGroup: 1000\n      \n      terminationGracePeriodSeconds: 30\n      \n      # Init container to check BuildKit registry availability\n      initContainers:\n        - name: wait-for-buildkit\n          image: busybox:1.36\n          command:\n            - sh\n            - -c\n            - |\n              echo \"Waiting for BuildKit registry...\"\n              until wget -q --spider http://buildkit.agent-buildkit.svc.cluster.local/api/v1/health; do\n                echo \"BuildKit not ready, waiting...\"\n                sleep 5\n              done\n              echo \"BuildKit is ready!\"\n          resources:\n            requests:\n              cpu: 10m\n              memory: 16Mi\n            limits:\n              cpu: 50m\n              memory: 32Mi\n\n      containers:\n        - name: aiflow-agent\n          image: registry.bluefly.io/llm/aiflow-social-agent:1.0.0\n          imagePullPolicy: IfNotPresent\n\n          ports:\n            - name: http\n              containerPort: 8000\n              protocol: TCP\n            - name: metrics\n              containerPort: 8000\n              protocol: TCP\n\n          env:\n            # Agent Identity\n            - name: AGENT_ID\n              value: \"social-agent-aiflow\"\n            - name: AGENT_NAME\n              value: \"AIFlow Social Agent\"\n            - name: AGENT_VERSION\n              value: \"1.0.0\"\n\n            # Service URLs\n            - name: BASE_URL\n              value: \"http://aiflow-social-agent.agents.svc.cluster.local:8000\"\n            - name: BUILDKIT_REGISTRY_URL\n              value: \"http://buildkit.agent-buildkit.svc.cluster.local/api/v1\"\n\n            # Phoenix Tracing\n            - name: PHOENIX_ENDPOINT\n              value: \"http://otel-collector.observability.svc.cluster.local:4318\"\n            - name: PHOENIX_PROJECT\n              value: \"aiflow-social-agents\"\n            - name: PHOENIX_ENABLED\n              value: \"true\"\n\n            # Runtime Configuration\n            - name: HEARTBEAT_INTERVAL\n              value: \"30\"\n            - name: LOG_LEVEL\n              value: \"info\"\n            - name: PYTHONUNBUFFERED\n              value: \"1\"\n\n            # API Key from Secret\n            - name: AIFLOW_API_KEY\n              valueFrom:\n                secretKeyRef:\n                  name: aiflow-agent-secrets\n                  key: api-key\n\n            # Social Platform Credentials\n            - name: TWITTER_API_KEY\n              valueFrom:\n                secretKeyRef:\n                  name: aiflow-agent-secrets\n                  key: twitter-api-key\n                  optional: true\n            - name: TELEGRAM_BOT_TOKEN\n              valueFrom:\n                secretKeyRef:\n                  name: aiflow-agent-secrets\n                  key: telegram-bot-token\n                  optional: true\n\n            # Kubernetes Info\n            - name: K8S_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n            - name: K8S_POD_NAMESPACE\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.namespace\n            - name: K8S_NODE_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: spec.nodeName\n\n          # Resource Limits\n          resources:\n            requests:\n              cpu: 500m\n              memory: 512Mi\n            limits:\n              cpu: 1000m\n              memory: 1Gi\n\n          # Health Checks\n          livenessProbe:\n            httpGet:\n              path: /health\n              port: http\n            initialDelaySeconds: 30\n            periodSeconds: 30\n            timeoutSeconds: 5\n            successThreshold: 1\n            failureThreshold: 3\n\n          readinessProbe:\n            httpGet:\n              path: /health\n              port: http\n            initialDelaySeconds: 10\n            periodSeconds: 10\n            timeoutSeconds: 3\n            successThreshold: 1\n            failureThreshold: 2\n\n          startupProbe:\n            httpGet:\n              path: /health\n              port: http\n            initialDelaySeconds: 5\n            periodSeconds: 5\n            timeoutSeconds: 3\n            successThreshold: 1\n            failureThreshold: 12 # 60 seconds max startup time\n        \n        # Graceful Shutdown\n        lifecycle:\n          preStop:\n            exec:\n              command:\n                - sh\n                - -c\n                - |\n                  echo \"Initiating graceful shutdown...\"\n                  sleep 5  # Allow current requests to complete\n        \n        # Volume Mounts\n        volumeMounts:\n            - name: config\n              mountPath: /app/config\n              readOnly: true\n            - name: character-data\n              mountPath: /app/characters\n              readOnly: true\n            - name: tmp\n              mountPath: /tmp\n\n      # Volumes\n      volumes:\n        - name: config\n          configMap:\n            name: aiflow-agent-config\n        - name: character-data\n          configMap:\n            name: aiflow-character-config\n        - name: tmp\n          emptyDir: {}\n\n      # Scheduling\n      affinity:\n        # Prefer spreading across nodes\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - weight: 100\n              podAffinityTerm:\n                labelSelector:\n                  matchLabels:\n                    app: aiflow-social-agent\n                topologyKey: kubernetes.io/hostname\n\n      # Tolerations\n      tolerations:\n        - key: \"workload\"\n          operator: \"Equal\"\n          value: \"agents\"\n          effect: \"NoSchedule\"\n\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: aiflow-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\n  annotations:\n    prometheus.io/scrape: \"true\"\n    prometheus.io/port: \"8000\"\n    prometheus.io/path: \"/metrics\"\nspec:\n  type: ClusterIP\n  sessionAffinity: None\n  ports:\n    - name: http\n      port: 8000\n      targetPort: http\n      protocol: TCP\n    - name: metrics\n      port: 9090\n      targetPort: metrics\n      protocol: TCP\n  selector:\n    app: aiflow-social-agent\n",
    "category": "Infrastructure"
  },
  {
    "name": "hpa.yaml",
    "path": "bridges/k8s/hpa.yaml",
    "content": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\n  annotations:\n    description: \"Auto-scale AIFlow agent based on CPU, memory, and custom metrics\"\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: aiflow-social-agent\n\n  minReplicas: 2\n  maxReplicas: 10\n\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300 # Wait 5 minutes before scaling down\n      policies:\n        - type: Percent\n          value: 50\n          periodSeconds: 60 # Remove 50% of pods per minute max\n        - type: Pods\n          value: 2\n          periodSeconds: 60 # Remove 2 pods per minute max\n      selectPolicy: Min # Use the most conservative policy\n\n    scaleUp:\n      stabilizationWindowSeconds: 0 # Scale up immediately\n      policies:\n        - type: Percent\n          value: 100\n          periodSeconds: 30 # Double pods every 30 seconds if needed\n        - type: Pods\n          value: 4\n          periodSeconds: 30 # Add 4 pods per 30 seconds max\n      selectPolicy: Max # Use the most aggressive policy\n\n  metrics:\n    # CPU Utilization\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n\n    # Memory Utilization\n    - type: Resource\n      resource:\n        name: memory\n        target:\n          type: Utilization\n          averageUtilization: 80\n\n    # Custom Metric: API Request Rate\n    - type: Pods\n      pods:\n        metric:\n          name: aiflow_api_requests_per_second\n        target:\n          type: AverageValue\n          averageValue: \"100\"\n\n    # Custom Metric: Active Tasks\n    - type: Pods\n      pods:\n        metric:\n          name: aiflow_active_tasks\n        target:\n          type: AverageValue\n          averageValue: \"50\"\n\n    # Custom Metric: API Latency (P95)\n    - type: Pods\n      pods:\n        metric:\n          name: aiflow_api_latency_p95\n        target:\n          type: AverageValue\n          averageValue: \"500m\" # 500ms\n\n---\napiVersion: v1\nkind: ServiceMonitor\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\n    prometheus: kube-prometheus\nspec:\n  selector:\n    matchLabels:\n      app: aiflow-social-agent\n  endpoints:\n    - port: metrics\n      interval: 30s\n      path: /metrics\n      scheme: http\n      honorLabels: true\n      relabelings:\n        - sourceLabels: [__meta_kubernetes_pod_name]\n          targetLabel: pod\n        - sourceLabels: [__meta_kubernetes_pod_node_name]\n          targetLabel: node\n        - sourceLabels: [__meta_kubernetes_namespace]\n          targetLabel: namespace\n\n---\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\nspec:\n  minAvailable: 1\n  selector:\n    matchLabels:\n      app: aiflow-social-agent\n  unhealthyPodEvictionPolicy: IfHealthyBudget\n",
    "category": "Infrastructure"
  },
  {
    "name": "ingress.yaml",
    "path": "bridges/k8s/ingress.yaml",
    "content": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\n  annotations:\n    # Nginx ingress annotations\n    kubernetes.io/ingress.class: \"nginx\"\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    nginx.ingress.kubernetes.io/force-ssl-redirect: \"true\"\n\n    # Rate limiting\n    nginx.ingress.kubernetes.io/limit-rps: \"100\"\n    nginx.ingress.kubernetes.io/limit-burst-multiplier: \"5\"\n\n    # Timeouts\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: \"30\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"30\"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"30\"\n\n    # CORS\n    nginx.ingress.kubernetes.io/enable-cors: \"true\"\n    nginx.ingress.kubernetes.io/cors-allow-origin: \"https://agent-buildkit.orb.local\"\n    nginx.ingress.kubernetes.io/cors-allow-methods: \"GET, POST, OPTIONS\"\n\n    # Security headers\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      more_set_headers \"X-Frame-Options: DENY\";\n      more_set_headers \"X-Content-Type-Options: nosniff\";\n      more_set_headers \"X-XSS-Protection: 1; mode=block\";\n      more_set_headers \"Referrer-Policy: strict-origin-when-cross-origin\";\nspec:\n  tls:\n    - hosts:\n        - aiflow-agent.agents.orb.local\n      secretName: aiflow-agent-tls\n\n  rules:\n    - host: aiflow-agent.agents.orb.local\n      http:\n        paths:\n          # API endpoints\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: aiflow-social-agent\n                port:\n                  number: 8000\n\n          # Metrics endpoint (protected)\n          - path: /metrics\n            pathType: Exact\n            backend:\n              service:\n                name: aiflow-social-agent\n                port:\n                  number: 9090\n\n---\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: aiflow-social-agent\n  namespace: agents\n  labels:\n    app: aiflow-social-agent\nspec:\n  podSelector:\n    matchLabels:\n      app: aiflow-social-agent\n\n  policyTypes:\n    - Ingress\n    - Egress\n\n  ingress:\n    # Allow traffic from ingress controller\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: ingress-nginx\n      ports:\n        - protocol: TCP\n          port: 8000\n\n    # Allow traffic from BuildKit registry\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: agent-buildkit\n        - podSelector:\n            matchLabels:\n              app: buildkit-registry\n      ports:\n        - protocol: TCP\n          port: 8000\n\n    # Allow Prometheus scraping\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: observability\n        - podSelector:\n            matchLabels:\n              app: prometheus\n      ports:\n        - protocol: TCP\n          port: 9090\n\n  egress:\n    # Allow DNS\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: kube-system\n        - podSelector:\n            matchLabels:\n              k8s-app: kube-dns\n      ports:\n        - protocol: UDP\n          port: 53\n\n    # Allow BuildKit registry\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: agent-buildkit\n      ports:\n        - protocol: TCP\n          port: 80\n        - protocol: TCP\n          port: 443\n\n    # Allow OTEL collector\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: observability\n        - podSelector:\n            matchLabels:\n              app: otel-collector\n      ports:\n        - protocol: TCP\n          port: 4318\n\n    # Allow external API calls (Twitter, Telegram, etc.)\n    - to:\n        - namespaceSelector: {}\n      ports:\n        - protocol: TCP\n          port: 443\n",
    "category": "Infrastructure"
  },
  {
    "name": "kagent-bridge-example.yml",
    "path": "bridges/kagent-bridge-example.yml",
    "content": "ossaVersion: \"1.0\"\nagent:\n  id: kubernetes-ops-agent\n  name: Kubernetes Operations Agent\n  version: 1.0.0\n  description: OSSA agent with kagent.dev bridge for Kubernetes operations\n  role: orchestration\n  tags: [\"kubernetes\", \"k8s\", \"devops\", \"kagent\"]\n\n  runtime:\n    type: k8s\n    resources:\n      cpu: \"500m\"\n      memory: \"512Mi\"\n\n  capabilities:\n    - name: manage_deployments\n      description: Manage Kubernetes deployments\n      input_schema:\n        type: object\n        properties:\n          action:\n            type: string\n            enum: [\"create\", \"update\", \"delete\", \"scale\"]\n          deployment:\n            type: string\n          namespace:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          status:\n            type: string\n          message:\n            type: string\n\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n\n  # kagent.dev bridge configuration\n  bridge:\n    kagent:\n      enabled: true\n      api_version: kagent.dev/v1alpha2\n      agent_type: declarative\n      deployment:\n        replicas: 1\n        resources:\n          requests:\n            cpu: \"100m\"\n            memory: \"256Mi\"\n          limits:\n            cpu: \"1000m\"\n            memory: \"1Gi\"\n      model_config: default-model-config\n      system_message: |\n        You are a Kubernetes operations expert. You help users manage\n        and troubleshoot Kubernetes clusters. Use your tools to query\n        cluster state and perform operations safely.\n      tools:\n        - type: McpServer\n          mcpServer:\n            toolServer: kagent-tool-server\n            toolNames:\n              - k8s_get_resources\n              - k8s_get_available_api_resources\n              - k8s_apply_manifest\n              - k8s_delete_resource\n      a2a_config:\n        skills:\n          - id: cluster-management\n            name: Cluster Management\n            description: Manage Kubernetes cluster resources\n            examples:\n              - \"Scale deployment nginx to 3 replicas\"\n              - \"Get all pods in production namespace\"\n              - \"Delete failed jobs in default namespace\"\n            tags:\n              - kubernetes\n              - deployment\n              - operations\n          - id: troubleshooting\n            name: Cluster Troubleshooting\n            description: Diagnose and resolve cluster issues\n            examples:\n              - \"Why is my pod crashing?\"\n              - \"Check resource usage across nodes\"\n              - \"Find pods consuming most memory\"\n            tags:\n              - debugging\n              - diagnostics\n              - troubleshooting\n",
    "category": "Infrastructure"
  },
  {
    "name": "SLO-SLA.yaml",
    "path": "bridges/phase4/SLO-SLA.yaml",
    "content": "# AIFlow Social Agent - SLO/SLA Definitions\n# Service Level Objectives and Service Level Agreements\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: aiflow-slo-sla\n  namespace: agents-staging\n  labels:\n    app: aiflow-social-agent\n    component: observability\ndata:\n  slo.yaml: |\n    # Service Level Objectives (SLOs)\n    # Internal targets for service reliability\n    \n    slos:\n      # Availability SLO\n      - name: \"API Availability\"\n        description: \"Agent API should be available and responding to health checks\"\n        objective: \"99.5%\"\n        measurement_window: \"30d\"\n        target_success_rate: 0.995\n        indicators:\n          - type: \"uptime\"\n            query: \"sum(up{job='aiflow-social-agent'}) / count(up{job='aiflow-social-agent'})\"\n          - type: \"health_check\"\n            query: \"rate(aiflow_health_checks_total[5m])\"\n        alert_threshold: 0.99  # Alert if availability drops below 99%\n      \n      # Latency SLO\n      - name: \"API Response Time\"\n        description: \"95% of requests should complete within 500ms\"\n        objective: \"P95 < 500ms\"\n        measurement_window: \"7d\"\n        target_percentile: 95\n        target_latency_ms: 500\n        indicators:\n          - type: \"latency\"\n            query: \"histogram_quantile(0.95, rate(aiflow_api_latency_seconds_bucket[5m]))\"\n        alert_threshold: 600  # Alert if P95 exceeds 600ms\n      \n      # Error Rate SLO\n      - name: \"Error Rate\"\n        description: \"Error rate should be below 1%\"\n        objective: \"< 1%\"\n        measurement_window: \"7d\"\n        target_error_rate: 0.01\n        indicators:\n          - type: \"error_rate\"\n            query: \"rate(aiflow_api_requests_total{status=~'5..'}[5m]) / rate(aiflow_api_requests_total[5m])\"\n        alert_threshold: 0.02  # Alert if error rate exceeds 2%\n      \n      # BuildKit Integration SLO\n      - name: \"BuildKit Heartbeat Success\"\n        description: \"Heartbeat success rate to BuildKit registry\"\n        objective: \"99%\"\n        measurement_window: \"24h\"\n        target_success_rate: 0.99\n        indicators:\n          - type: \"heartbeat_success\"\n            query: \"rate(aiflow_buildkit_heartbeats_total{status='success'}[5m]) / rate(aiflow_buildkit_heartbeats_total[5m])\"\n        alert_threshold: 0.95  # Alert if success rate drops below 95%\n      \n      # Resource Utilization SLO\n      - name: \"Resource Efficiency\"\n        description: \"CPU and memory usage within acceptable bounds\"\n        objective: \"CPU < 80%, Memory < 85%\"\n        measurement_window: \"24h\"\n        indicators:\n          - type: \"cpu_utilization\"\n            query: \"rate(container_cpu_usage_seconds_total{pod=~'aiflow-social-agent.*'}[5m])\"\n            target: 0.80\n          - type: \"memory_utilization\"\n            query: \"container_memory_working_set_bytes{pod=~'aiflow-social-agent.*'} / container_spec_memory_limit_bytes{pod=~'aiflow-social-agent.*'}\"\n            target: 0.85\n  \n  sla.yaml: |\n    # Service Level Agreements (SLAs)\n    # External commitments to users/consumers\n    \n    slas:\n      # API Availability SLA\n      - name: \"API Availability Guarantee\"\n        description: \"Public commitment for API availability\"\n        commitment: \"99.9% uptime\"\n        measurement_window: \"monthly\"\n        remediation:\n          - threshold: 99.9\n            action: \"No action required\"\n          - threshold: 99.5\n            action: \"Internal postmortem required\"\n          - threshold: 99.0\n            action: \"Customer notification + service credits\"\n          - threshold: 95.0\n            action: \"Emergency response + full refund\"\n        exclusions:\n          - \"Scheduled maintenance (with 48h notice)\"\n          - \"Force majeure events\"\n          - \"Third-party service outages (BuildKit, K8s infrastructure)\"\n      \n      # Response Time SLA\n      - name: \"API Response Time Guarantee\"\n        description: \"Committed response time for API requests\"\n        commitment: \"P99 < 1 second\"\n        measurement_window: \"monthly\"\n        target_percentile: 99\n        target_latency_ms: 1000\n        remediation:\n          - threshold: 1000\n            action: \"No action required\"\n          - threshold: 2000\n            action: \"Performance investigation\"\n          - threshold: 5000\n            action: \"Immediate optimization required\"\n      \n      # Error Rate SLA\n      - name: \"Error Rate Guarantee\"\n        description: \"Maximum acceptable error rate\"\n        commitment: \"< 0.5% error rate\"\n        measurement_window: \"monthly\"\n        target_error_rate: 0.005\n        remediation:\n          - threshold: 0.005\n            action: \"No action required\"\n          - threshold: 0.01\n            action: \"Error investigation required\"\n          - threshold: 0.05\n            action: \"Critical incident declared\"\n      \n      # Support Response SLA\n      - name: \"Support Response Time\"\n        description: \"Response time for support requests\"\n        commitment:\n          - severity: \"P0 - Critical\"\n            response_time: \"15 minutes\"\n            resolution_time: \"4 hours\"\n          - severity: \"P1 - High\"\n            response_time: \"1 hour\"\n            resolution_time: \"24 hours\"\n          - severity: \"P2 - Medium\"\n            response_time: \"4 hours\"\n            resolution_time: \"72 hours\"\n          - severity: \"P3 - Low\"\n            response_time: \"24 hours\"\n            resolution_time: \"7 days\"\n  \n  error-budget.yaml: |\n    # Error Budget Policy\n    # Defines how error budget is calculated and consumed\n    \n    error_budget:\n      # Availability Error Budget\n      - slo_name: \"API Availability\"\n        target: 99.5%\n        measurement_window: 30d\n        budget_calculation:\n          total_time: 43200  # 30 days in minutes\n          allowed_downtime: 216  # 0.5% = 216 minutes\n        consumption_tracking:\n          - type: \"downtime\"\n            query: \"1 - (sum(up{job='aiflow-social-agent'}) / count(up{job='aiflow-social-agent'}))\"\n        policy:\n          - budget_remaining: 100-50\n            action: \"Normal operations, continue feature development\"\n          - budget_remaining: 50-25\n            action: \"Slow down feature releases, focus on reliability\"\n          - budget_remaining: 25-10\n            action: \"Feature freeze, only critical bug fixes\"\n          - budget_remaining: 0-10\n            action: \"Emergency mode: Stop all changes, incident response only\"\n      \n      # Latency Error Budget\n      - slo_name: \"API Response Time\"\n        target: \"P95 < 500ms\"\n        measurement_window: 7d\n        budget_calculation:\n          total_requests: \"N\"  # Dynamic based on traffic\n          allowed_slow_requests: \"5% of N\"  # Requests > 500ms\n        consumption_tracking:\n          - type: \"slow_requests\"\n            query: \"sum(rate(aiflow_api_latency_seconds_bucket{le='0.5'}[5m]))\"\n  \n  alerting-rules.yaml: |\n    # Prometheus Alerting Rules for SLO Violations\n    \n    groups:\n      - name: aiflow_slo_alerts\n        interval: 30s\n        rules:\n          # Availability Alert\n          - alert: AIFlowAvailabilityLow\n            expr: |\n              (\n                sum(up{job=\"aiflow-social-agent\"}) /\n                count(up{job=\"aiflow-social-agent\"})\n              ) < 0.99\n            for: 5m\n            labels:\n              severity: critical\n              slo: availability\n            annotations:\n              summary: \"AIFlow agent availability below SLO\"\n              description: \"Availability is {{ $value | humanizePercentage }}, below 99% threshold\"\n          \n          # Latency Alert\n          - alert: AIFlowHighLatency\n            expr: |\n              histogram_quantile(0.95, \n                rate(aiflow_api_latency_seconds_bucket[5m])\n              ) > 0.5\n            for: 10m\n            labels:\n              severity: warning\n              slo: latency\n            annotations:\n              summary: \"AIFlow API P95 latency above SLO\"\n              description: \"P95 latency is {{ $value }}s, above 500ms target\"\n          \n          # Error Rate Alert\n          - alert: AIFlowHighErrorRate\n            expr: |\n              (\n                rate(aiflow_api_requests_total{status=~\"5..\"}[5m]) /\n                rate(aiflow_api_requests_total[5m])\n              ) > 0.01\n            for: 5m\n            labels:\n              severity: critical\n              slo: error_rate\n            annotations:\n              summary: \"AIFlow error rate above SLO\"\n              description: \"Error rate is {{ $value | humanizePercentage }}, above 1% threshold\"\n          \n          # Error Budget Burn Rate Alert\n          - alert: AIFlowErrorBudgetBurnRateHigh\n            expr: |\n              (\n                1 - (sum(up{job=\"aiflow-social-agent\"}) / count(up{job=\"aiflow-social-agent\"}))\n              ) > 0.001  # Burning budget faster than 0.1%/hour\n            for: 1h\n            labels:\n              severity: warning\n              slo: error_budget\n            annotations:\n              summary: \"Error budget burning too quickly\"\n              description: \"Current burn rate will exhaust budget in {{ $value | humanizeDuration }}\"\n\n",
    "category": "Infrastructure"
  },
  {
    "name": "chaos-tests.yaml",
    "path": "bridges/phase4/chaos-tests.yaml",
    "content": "# Chaos Engineering Tests for AIFlow Social Agent\n# Using Chaos Mesh or LitmusChaos\n\n---\n# Test 1: Pod Failure\napiVersion: chaos-mesh.org/v1alpha1\nkind: PodChaos\nmetadata:\n  name: aiflow-pod-failure\n  namespace: agents-staging\nspec:\n  action: pod-failure\n  mode: one\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  duration: \"30s\"\n  scheduler:\n    cron: \"@every 1h\"\n\n---\n# Test 2: Pod Kill (Immediate termination)\napiVersion: chaos-mesh.org/v1alpha1\nkind: PodChaos\nmetadata:\n  name: aiflow-pod-kill\n  namespace: agents-staging\nspec:\n  action: pod-kill\n  mode: fixed-percent\n  value: \"50\"  # Kill 50% of pods\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  duration: \"1m\"\n\n---\n# Test 3: Network Delay\napiVersion: chaos-mesh.org/v1alpha1\nkind: NetworkChaos\nmetadata:\n  name: aiflow-network-delay\n  namespace: agents-staging\nspec:\n  action: delay\n  mode: one\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  delay:\n    latency: \"500ms\"\n    correlation: \"50\"\n    jitter: \"100ms\"\n  duration: \"2m\"\n  direction: to\n\n---\n# Test 4: Network Partition (BuildKit unreachable)\napiVersion: chaos-mesh.org/v1alpha1\nkind: NetworkChaos\nmetadata:\n  name: aiflow-buildkit-partition\n  namespace: agents-staging\nspec:\n  action: partition\n  mode: all\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  direction: to\n  target:\n    selector:\n      namespaces:\n        - agent-buildkit\n      labelSelectors:\n        app: buildkit-registry\n  duration: \"1m\"\n\n---\n# Test 5: CPU Stress\napiVersion: chaos-mesh.org/v1alpha1\nkind: StressChaos\nmetadata:\n  name: aiflow-cpu-stress\n  namespace: agents-staging\nspec:\n  mode: one\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  stressors:\n    cpu:\n      workers: 2\n      load: 80\n  duration: \"3m\"\n\n---\n# Test 6: Memory Stress\napiVersion: chaos-mesh.org/v1alpha1\nkind: StressChaos\nmetadata:\n  name: aiflow-memory-stress\n  namespace: agents-staging\nspec:\n  mode: one\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  stressors:\n    memory:\n      workers: 1\n      size: \"512MB\"\n  duration: \"2m\"\n\n---\n# Test 7: DNS Failure\napiVersion: chaos-mesh.org/v1alpha1\nkind: NetworkChaos\nmetadata:\n  name: aiflow-dns-failure\n  namespace: agents-staging\nspec:\n  action: partition\n  mode: all\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  direction: to\n  target:\n    selector:\n      namespaces:\n        - kube-system\n      labelSelectors:\n        k8s-app: kube-dns\n  duration: \"1m\"\n\n---\n# Test 8: Time Chaos (Clock skew)\napiVersion: chaos-mesh.org/v1alpha1\nkind: TimeChaos\nmetadata:\n  name: aiflow-time-skew\n  namespace: agents-staging\nspec:\n  mode: one\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  timeOffset: \"-10m\"  # Clock 10 minutes behind\n  duration: \"1m\"\n\n---\n# Test 9: HTTP Abort (500 errors)\napiVersion: chaos-mesh.org/v1alpha1\nkind: HTTPChaos\nmetadata:\n  name: aiflow-http-abort\n  namespace: agents-staging\nspec:\n  mode: one\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  port: 8000\n  path: \"/generate_post\"\n  method: POST\n  abort: true\n  duration: \"2m\"\n\n---\n# Test 10: HTTP Delay\napiVersion: chaos-mesh.org/v1alpha1\nkind: HTTPChaos\nmetadata:\n  name: aiflow-http-delay\n  namespace: agents-staging\nspec:\n  mode: all\n  selector:\n    namespaces:\n      - agents-staging\n    labelSelectors:\n      app: aiflow-social-agent\n  port: 8000\n  path: \"/generate_*\"\n  method: POST\n  delay: \"3s\"\n  duration: \"2m\"\n\n---\n# Chaos Experiment Schedule\napiVersion: chaos-mesh.org/v1alpha1\nkind: Schedule\nmetadata:\n  name: aiflow-chaos-schedule\n  namespace: agents-staging\nspec:\n  schedule: \"0 2 * * *\"  # Run daily at 2 AM\n  type: PodChaos\n  podChaos:\n    action: pod-kill\n    mode: one\n    selector:\n      namespaces:\n        - agents-staging\n      labelSelectors:\n        app: aiflow-social-agent\n\n",
    "category": "Infrastructure"
  },
  {
    "name": "agent-router.ossa.yaml",
    "path": "common_npm/agent-router.ossa.yaml",
    "content": "ossaVersion: \"1.0\"\n\nagent:\n  id: agent-router\n  name: \"Agent Router\"\n  version: \"1.0.0\"\n  role: \"integration\"\n  \n  description: |\n    Multi-provider LLM gateway with circuit breaker, intelligent routing, and failover.\n    \n    Features:\n    - Multi-provider support (OpenAI, Anthropic, Google, etc.)\n    - Intelligent routing based on model capabilities\n    - Circuit breaker pattern for fault tolerance\n    - Request/response caching\n    - Cost optimization\n    - Load balancing\n  \n  runtime:\n    type: \"docker\"\n    image: \"llm-platform/agent-router:1.0.0\"\n    \n    resources:\n      cpu: \"500m\"\n      memory: \"1Gi\"\n    \n    health_check:\n      type: \"http\"\n      endpoint: \"/health\"\n      port: 4000\n  \n  capabilities:\n    - name: llm_completion\n      description: \"Generate LLM completion with intelligent provider routing\"\n      input_schema:\n        type: object\n        required: [prompt]\n        properties:\n          prompt:\n            type: string\n            description: \"Input prompt for LLM\"\n          model:\n            type: string\n            description: \"Preferred model (optional, router will auto-select)\"\n            examples: [\"gpt-4\", \"claude-3-opus\", \"gemini-pro\"]\n          temperature:\n            type: number\n            minimum: 0\n            maximum: 2\n            default: 0.7\n          max_tokens:\n            type: integer\n            minimum: 1\n            maximum: 100000\n            default: 2000\n          provider:\n            type: string\n            enum: [\"openai\", \"anthropic\", \"google\", \"auto\"]\n            default: \"auto\"\n      output_schema:\n        type: object\n        required: [response, provider, model, usage]\n        properties:\n          response:\n            type: string\n          provider:\n            type: string\n          model:\n            type: string\n          usage:\n            type: object\n            properties:\n              prompt_tokens:\n                type: integer\n              completion_tokens:\n                type: integer\n              total_tokens:\n                type: integer\n              cost_usd:\n                type: number\n      timeout_seconds: 30\n      retry_policy:\n        max_attempts: 3\n        backoff: \"exponential\"\n    \n    - name: embedding_generation\n      description: \"Generate text embeddings for vector storage\"\n      input_schema:\n        type: object\n        required: [text]\n        properties:\n          text:\n            type: string\n          model:\n            type: string\n            default: \"text-embedding-ada-002\"\n      output_schema:\n        type: object\n        required: [embedding, dimensions]\n        properties:\n          embedding:\n            type: array\n            items:\n              type: number\n          dimensions:\n            type: integer\n          model:\n            type: string\n    \n    - name: health_check\n      description: \"Check health of all LLM providers\"\n      input_schema:\n        type: object\n        properties: {}\n      output_schema:\n        type: object\n        required: [healthy, providers]\n        properties:\n          healthy:\n            type: boolean\n          providers:\n            type: array\n            items:\n              type: object\n              properties:\n                name:\n                  type: string\n                status:\n                  type: string\n                  enum: [\"healthy\", \"degraded\", \"down\"]\n                latency_ms:\n                  type: number\n  \n  llm:\n    provider: \"auto\"\n    fallback_providers: [\"openai\", \"anthropic\", \"google\"]\n    model: \"gpt-4\"\n    temperature: 0.7\n    maxTokens: 2000\n  \n  protocols:\n    - type: \"http\"\n      version: \"1.1\"\n      endpoint: \"http://agent-router:4000/v1/chat/completions\"\n    \n    - type: \"sse\"\n      version: \"1.0\"\n      endpoint: \"http://agent-router:4000/v1/stream\"\n\n  compliance:\n    frameworks: [\"SOC2\"]\n    dataClassification: \"confidential\"\n\nextensions:\n  common_npm:\n    package: \"@llm/agent-router\"\n    port: 4000\n    version: \"1.0.0\"\n    \n    dependencies:\n      - \"@llm/agent-protocol\"\n      - \"@llm/agent-tracer\"\n    \n    providers:\n      - openai\n      - anthropic\n      - google\n      - azure\n    \n    circuit_breaker:\n      enabled: true\n      failure_threshold: 5\n      timeout_seconds: 60\n      half_open_requests: 3\n    \n    monitoring:\n      metrics: true\n      tracing: true\n      opentelemetry:\n        endpoint: \"http://agent-tracer:4318\"\n        service_name: \"agent-router\"\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "agent-router.v0.2.2.ossa.yaml",
    "path": "common_npm/agent-router.v0.2.2.ossa.yaml",
    "content": "apiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: agent-router\n  version: 1.0.0\n  description: |\n    Multi-provider LLM gateway with circuit breaker, intelligent routing, and failover.\n\n    Features:\n    - Multi-provider support (OpenAI, Anthropic, Google, etc.)\n    - Intelligent routing based on model capabilities\n    - Circuit breaker pattern for fault tolerance\n    - Request/response caching\n    - Cost optimization\n    - Load balancing\n  labels: {}\n  annotations:\n    ossa.io/migration: v1.0 to v0.2.2\n    ossa.io/migrated-date: 2025-10-31\nspec:\n  role: integration\n  taxonomy:\n    domain: integration\n    subdomain: general\n    capability: routing\n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.7\n    maxTokens: 2000\n  tools:\n    - type: mcp\n      name: llm_completion\n      server: agent-router\n    - type: mcp\n      name: embedding_generation\n      server: agent-router\n    - type: mcp\n      name: health_check\n      server: agent-router\n  extensions:\n    buildkit:\n      deployment:\n        replicas:\n          min: 1\n          max: 4\n      container:\n        image: llm-platform/agent-router:1.0.0\n        runtime: docker\n        resources: &a1\n          cpu: 500m\n          memory: 1Gi\n    runtime:\n      type: docker\n      image: llm-platform/agent-router:1.0.0\n      resources: *a1\n      health_check:\n        type: http\n        endpoint: /health\n        port: 4000\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "compliance-agent.yml",
    "path": "compliance-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  id: fedramp-compliance-scanner\n  name: FedRAMP Compliance Scanner\n  description: |\n    Automated FedRAMP compliance scanning agent that validates\n    infrastructure against FedRAMP Moderate controls.\n  version: '1.0.0'\n  role: compliance\n\n  author:\n    name: Bluefly Security Team\n    email: security@bluefly.io\n    organization: Bluefly.io\n\n  license: Apache-2.0\n\n  runtime:\n    type: k8s\n    image: registry.bluefly.io/agents/fedramp-scanner:1.0.0\n    command: ['/app/scanner']\n    args: ['--mode=continuous']\n    env:\n      LOG_LEVEL: info\n      SCAN_INTERVAL: '3600'\n    resources:\n      cpu: '500m'\n      memory: '1Gi'\n\n  capabilities:\n    - name: scan_infrastructure\n      description: Scan Kubernetes infrastructure for FedRAMP compliance\n      input_schema:\n        type: object\n        required: [namespace]\n        properties:\n          namespace:\n            type: string\n          controls:\n            type: array\n            items:\n              type: string\n      output_schema:\n        type: object\n        properties:\n          compliant:\n            type: boolean\n          violations:\n            type: array\n            items:\n              type: object\n              properties:\n                control:\n                  type: string\n                severity:\n                  type: string\n                  enum: [low, medium, high, critical]\n                description:\n                  type: string\n      examples:\n        - name: scan_production\n          input:\n            namespace: production\n            controls: ['AC-2', 'AC-3', 'AU-2']\n          output:\n            compliant: false\n            violations:\n              - control: 'AC-2'\n                severity: 'high'\n                description: 'Service account without expiration policy'\n\n    - name: remediate\n      description: Automatically remediate compliance violations\n      input_schema:\n        type: object\n        required: [violation_id]\n        properties:\n          violation_id:\n            type: string\n          auto_apply:\n            type: boolean\n      output_schema:\n        type: object\n        properties:\n          remediated:\n            type: boolean\n          actions:\n            type: array\n            items:\n              type: string\n\n    - name: generate_report\n      description: Generate FedRAMP compliance report\n      input_schema:\n        type: object\n        required: [format]\n        properties:\n          format:\n            type: string\n            enum: [pdf, html, json]\n      output_schema:\n        type: object\n        properties:\n          report_url:\n            type: string\n          summary:\n            type: object\n\n  policies:\n    compliance:\n      - fedramp\n      - soc2\n    data_residency:\n      - US\n    encryption: true\n    audit: true\n    retention: 2555 # 7 years (FedRAMP requirement)\n\n  integration:\n    protocol: grpc\n    endpoints:\n      scan:\n        path: /v1/scan\n        method: POST\n      remediate:\n        path: /v1/remediate\n        method: POST\n      report:\n        path: /v1/report\n        method: GET\n    auth:\n      type: mutual-tls\n      config:\n        ca_cert: /etc/certs/ca.crt\n        client_cert: /etc/certs/client.crt\n\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:8080/health\n    readiness_check: http://localhost:8080/ready\n\n  metadata:\n    tags:\n      - compliance\n      - fedramp\n      - security\n    keywords:\n      - compliance scanning\n      - automated remediation\n      - audit reporting\n    homepage: https://github.com/bluefly/fedramp-scanner\n    documentation: https://docs.bluefly.io/agents/fedramp-scanner\n",
    "category": "Production"
  },
  {
    "name": "research-team.ossa.json",
    "path": "crewai/research-team.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"research-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"CrewAI research agent for multi-agent collaboration\"\n  },\n  \"spec\": {\n    \"role\": \"You are a research specialist. Your goal is to gather comprehensive information on assigned topics.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.3\n    },\n    \"tools\": [\n      {\n        \"type\": \"http\",\n        \"name\": \"web_search\",\n        \"endpoint\": \"https://api.search.example.com\",\n        \"capabilities\": [\"search\", \"retrieve\"]\n      }\n    ]\n  },\n  \"extensions\": {\n    \"crewai\": {\n      \"enabled\": true,\n      \"agent_type\": \"researcher\",\n      \"role\": \"Research Specialist\",\n      \"goal\": \"Gather comprehensive and accurate information on assigned research topics\",\n      \"backstory\": \"You are an expert researcher with years of experience in information gathering and analysis. You excel at finding reliable sources and synthesizing complex information.\",\n      \"tools\": [\"web_search\", \"document_analyzer\"]\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "code-review-agent.ossa.json",
    "path": "cursor/code-review-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"code-review-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"AI-powered code review agent for Cursor IDE\"\n  },\n  \"spec\": {\n    \"role\": \"You are an expert code reviewer. Analyze code for bugs, security issues, performance problems, and best practices. Provide constructive feedback.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.2\n    },\n    \"tools\": [\n      {\n        \"type\": \"mcp\",\n        \"name\": \"analyze_code\",\n        \"server\": \"code-reviewer\",\n        \"capabilities\": [\"review\", \"suggest\", \"explain\"]\n      }\n    ]\n  },\n  \"extensions\": {\n    \"cursor\": {\n      \"enabled\": true,\n      \"agent_type\": \"composer\",\n      \"workspace_config\": {\n        \"rules_file\": \".cursor/.cursorrules\",\n        \"context_files\": [\"src/**/*.ts\", \"tests/**/*.ts\"],\n        \"ignore_patterns\": [\"node_modules/**\", \"dist/**\"]\n      },\n      \"capabilities\": {\n        \"code_generation\": false,\n        \"code_review\": true,\n        \"refactoring\": true,\n        \"testing\": false\n      },\n      \"model\": {\n        \"provider\": \"openai\",\n        \"name\": \"gpt-4\"\n      }\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "agent.ossa.yaml",
    "path": "drupal/ai_agents_ossa-module/.agents/example-agent/agent.ossa.yaml",
    "content": "apiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  name: example-agent\n  version: 1.0.0\n  description: Example OSSA agent for Drupal module demonstration\n  labels:\n    module: ai_agents_ossa\n    domain: example\n\nspec:\n  role: |\n    You are an example agent demonstrating OSSA integration with Drupal.\n    This agent shows how to structure agents in Drupal modules.\n\n  llm:\n    provider: openai\n    model: gpt-4-turbo\n    temperature: 0.7\n\n  taxonomy:\n    domain: example\n    capabilities:\n      - demonstrate-ossa\n      - drupal-integration\n\n  constraints:\n    cost:\n      maxTokensPerDay: 10000\n      maxCostPerDay: 1.00\n      currency: USD\n\n  observability:\n    logging:\n      level: info\n      format: json\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "gitlab-ml-recommender.ossa.yaml",
    "path": "drupal/gitlab-ml-recommender.ossa.yaml",
    "content": "# ============================================================================\n# OSSA Drupal Integration Example: GitLab ML Recommendation Engine\n# ============================================================================\n#\n# PURPOSE:\n#   Demonstrates OSSA integration with Drupal's AI Agent Orchestra module.\n#   Showcases a real-world RAG (Retrieval-Augmented Generation) pipeline for\n#   customer success recommendations using semantic search and LLM generation.\n#\n# KEY FEATURES:\n#   - RAG pipeline with Qdrant vector database for semantic search\n#   - GPT-4 powered recommendation generation\n#   - TimescaleDB aggregation for customer health metrics\n#   - Agent-to-Agent (A2A) communication via JSON-RPC\n#   - Event-driven architecture with Redis pub/sub\n#   - Enterprise-grade monitoring, caching, and compliance\n#\n# ARCHITECTURE:\n#   Drupal Module (ai_agent_orchestra)\n#     ↓ (service call)\n#   GitLabMlRecommendationsService\n#     ↓ (semantic search)\n#   Qdrant Vector DB\n#     ↓ (context retrieval)\n#   GPT-4 via Agent Router\n#     → AI Recommendations\n#\n# USE CASE:\n#   Customer Success teams get AI-powered, data-driven recommendations for\n#   proactive customer engagement based on historical successful interventions\n#   and current customer health signals.\n#\n# RELATED DOCUMENTATION:\n#   - OSSA Drupal Extensions: spec/OSSA_Drupal_Extensions.md\n#   - RAG Pipeline Guide: docs/patterns/rag-patterns.md\n#   - A2A Protocol: spec/OSSA_A2A_Protocol.md\n# ============================================================================\n\n# OSSA specification version - defines which features are available\nossaVersion: \"1.0\"\n\n# Agent metadata and configuration\nagent:\n  # Unique identifier for this agent (must be DNS-compatible: lowercase, hyphens)\n  id: gitlab-ml-recommender\n\n  # Human-readable name displayed in UIs\n  name: \"GitLab ML Recommendation Engine\"\n\n  # Semantic version for agent deployment tracking\n  version: \"1.0.0\"\n\n  # Agent role determines lifecycle and communication patterns:\n  # - \"integration\": Long-running service that connects external systems\n  # - \"chat\": Interactive conversational agent\n  # - \"worker\": Task-based processor (fire-and-forget or queued)\n  # - \"orchestrator\": Coordinates multiple agents\n  role: \"integration\"\n\n  # Detailed agent description (supports Markdown for rich documentation)\n  description: |\n    AI-powered customer success recommendation agent using RAG (Retrieval-Augmented Generation).\n\n    **Pipeline Architecture:**\n    1. Semantic search in Qdrant for similar successful cases\n    2. GPT-4 generation with retrieved context\n    3. Priority ranking based on customer health scores\n\n    **Integrates with:**\n    - GitLabMlRecommendationsService (RAG generation)\n    - GitLabMlDashboardService (health metrics)\n    - QdrantVectorService (semantic search)\n\n  # Runtime configuration - defines how the agent is deployed and executed\n  runtime:\n    # Execution environment type:\n    # - \"docker\": Containerized deployment with image specification\n    # - \"serverless\": FaaS deployment (AWS Lambda, Google Cloud Functions, etc.)\n    # - \"kubernetes\": Native k8s deployment with CRD\n    # - \"local\": Direct process execution (dev/testing only)\n    type: \"docker\"\n\n    # Docker image reference (registry/name:tag)\n    # Should follow semantic versioning and be immutable (no \"latest\" tag)\n    image: \"llm-platform/ml-recommender:1.0.0\"\n\n    # Language and dependency requirements (enforced at build time)\n    requirements:\n      # PHP version constraint (Drupal requirement)\n      php: \">=8.1\"\n\n      # Node.js version for build tools and frontend assets\n      node: \">=20.0.0\"\n\n      # Composer packages required for Drupal integration\n      packages:\n        - \"guzzlehttp/guzzle\"      # HTTP client for external API calls\n        - \"symfony/http-client\"     # Alternative HTTP client with retry logic\n\n    # Resource limits (Kubernetes-style requests/limits)\n    # These prevent resource exhaustion and enable autoscaling decisions\n    resources:\n      cpu: \"1000m\"      # 1 CPU core (1000 millicores)\n      memory: \"2Gi\"     # 2 gigabytes RAM\n\n    # Health check configuration for container orchestration\n    # Used by Kubernetes liveness/readiness probes and load balancers\n    health_check:\n      type: \"http\"          # HTTP GET request for health status\n      endpoint: \"/health\"   # Health check endpoint path\n      port: 8080            # Container port to check\n\n  # Capabilities define what the agent can do (contract-first design)\n  # Each capability is a discrete, testable unit of functionality with:\n  # - Type-safe input/output schemas (JSON Schema)\n  # - Usage examples for documentation and testing\n  # - Timeout and retry policies for reliability\n  capabilities:\n    # ========================================================================\n    # Capability 1: Generate Recommendations (RAG Pipeline)\n    # ========================================================================\n    # This is the core capability demonstrating OSSA's RAG pattern:\n    # 1. Semantic search in Qdrant for similar successful customer cases\n    # 2. Context injection into GPT-4 prompt\n    # 3. AI-generated recommendations with rationale\n    # 4. Priority ranking based on customer health signals\n    #\n    # FLOW:\n    #   Drupal Request → Service Layer → Qdrant Search → GPT-4 Generation\n    #   → Priority Ranking → Structured Response\n    # ========================================================================\n    - name: generate_recommendations\n\n      # Capability description (appears in API docs and UI)\n      description: \"Generate AI recommendations using RAG pipeline (Qdrant semantic search + GPT-4)\"\n\n      # Input schema using JSON Schema (OpenAPI-compatible)\n      # This defines the contract for calling this capability\n      input_schema:\n        type: object\n\n        # Required fields - validation will fail if missing\n        required: [customer_id]\n\n        properties:\n          # Customer UUID from GitLab (primary identifier)\n          customer_id:\n            type: string\n            format: uuid  # Validates UUID format (RFC 4122)\n            description: \"Customer UUID from GitLab\"\n\n          # Context filter for targeted recommendations\n          # Different contexts use different embedding collections\n          context:\n            type: string\n            enum: [health, churn, engagement, technical]\n            description: \"Recommendation context filter\"\n\n          # Result limit for controlling response size and cost\n          limit:\n            type: integer\n            default: 10       # Default if not provided\n            minimum: 1        # At least 1 recommendation\n            maximum: 50       # Max to prevent token exhaustion\n            description: \"Maximum number of recommendations\"\n\n\n      # Output schema defines the structure of the response\n      # This ensures consistent data contracts across all agents\n      output_schema:\n        type: object\n\n        # Required response fields (must always be present)\n        required: [customerId, recommendations, generatedAt]\n\n        properties:\n          # Echo back the customer ID for request correlation\n          customerId:\n            type: string\n            format: uuid\n\n          # Array of AI-generated recommendations\n          recommendations:\n            type: array\n            items:\n              type: object\n\n              # Each recommendation must have these core fields\n              required: [id, title, priority, category]\n\n              properties:\n                # Unique recommendation ID for tracking and analytics\n                id:\n                  type: string\n                  format: uuid\n\n                # Short, actionable title (shown in UI cards)\n                title:\n                  type: string\n                  maxLength: 255  # Database column constraint\n\n                # Detailed explanation of the recommendation\n                description:\n                  type: string\n\n                # Priority level for sorting and alerting\n                priority:\n                  type: string\n                  enum: [critical, high, medium, low]\n\n                # Recommendation category for filtering and routing\n                category:\n                  type: string\n                  enum: [engagement, technical, health, success]\n\n                # Concrete action steps (Drupal renders as checklist)\n                actionItems:\n                  type: array\n                  items:\n                    type: string\n\n                # AI-generated rationale explaining \"why\" this recommendation\n                # This is the key value from RAG - evidence from similar cases\n                rationale:\n                  type: string\n\n                # References to similar customer cases from vector search\n                # Provides transparency and builds trust in AI recommendations\n                similarCases:\n                  type: array\n                  items:\n                    type: object\n\n          # ISO 8601 timestamp for audit trail\n          generatedAt:\n            type: string\n            format: date-time\n\n\n      # Examples for documentation, testing, and contract validation\n      # Used by OSSA validators and API documentation generators\n      examples:\n        - name: \"Health context recommendations\"\n          input:\n            customer_id: \"123e4567-e89b-12d3-a456-426614174000\"\n            context: \"health\"\n            limit: 5\n          output:\n            customerId: \"123e4567-e89b-12d3-a456-426614174000\"\n            recommendations:\n              - id: \"rec-001\"\n                title: \"Schedule health check meeting\"\n                description: \"Conduct comprehensive health review with technical team\"\n                priority: \"high\"\n                category: \"engagement\"\n                actionItems:\n                  - \"Send meeting invitation for next week\"\n                  - \"Prepare health check questionnaire\"\n                  - \"Review usage metrics before meeting\"\n                rationale: \"Early issue identification strengthens customer relationships\"\n            generatedAt: \"2025-10-24T12:00:00Z\"\n\n      # Timeout prevents hung requests and enables circuit breaker patterns\n      timeout_seconds: 30\n\n      # Retry policy for transient failures (network issues, rate limits)\n      retry_policy:\n        max_attempts: 3           # Total attempts (initial + 2 retries)\n        backoff: \"exponential\"    # 1s, 2s, 4s, 8s... (prevents thundering herd)\n\n    # ========================================================================\n    # Capability 2: Get Dashboard Overview\n    # ========================================================================\n    # Provides aggregated customer health metrics from TimescaleDB.\n    # This is a read-only, fast query capability for dashboard UIs.\n    # ========================================================================\n    - name: get_dashboard_overview\n\n      description: \"Retrieve customer health dashboard data aggregated from TimescaleDB\"\n\n\n      # Minimal input - just a time range selector\n      input_schema:\n        type: object\n        required: [time_range]\n        properties:\n          # Time range for metric aggregation (TimescaleDB time bucket)\n          time_range:\n            type: string\n            enum: [\"24h\", \"7d\", \"30d\", \"90d\"]\n            description: \"Time range for dashboard data\"\n\n      # Dashboard metrics output (all pre-aggregated in TimescaleDB)\n      output_schema:\n        type: object\n        required: [totalCustomers, healthDistribution, churnRisks]\n        properties:\n          totalCustomers:\n            type: integer\n          healthDistribution:\n            type: object\n            properties:\n              healthy:\n                type: integer\n              warning:\n                type: integer\n              critical:\n                type: integer\n          churnRisks:\n            type: object\n            properties:\n              low:\n                type: integer\n              medium:\n                type: integer\n              high:\n                type: integer\n              critical:\n                type: integer\n          activeAlerts:\n            type: integer\n          recommendations:\n            type: integer\n          trends:\n            type: object\n            properties:\n              healthChange:\n                type: number\n              churnChange:\n                type: number\n              engagementChange:\n                type: number\n\n\n      # Fast timeout for dashboard queries (should be cached)\n      timeout_seconds: 10\n\n    # ========================================================================\n    # Capability 3: Get Active Alerts\n    # ========================================================================\n    # Returns active health alerts for customer success team triage.\n    # Supports filtering by severity and status for alert management workflows.\n    # ========================================================================\n    - name: get_active_alerts\n\n      description: \"Retrieve active customer health alerts\"\n      \n      input_schema:\n        type: object\n        properties:\n          severity:\n            type: string\n            enum: [critical, high, medium, low]\n          status:\n            type: string\n            enum: [active, acknowledged, resolved]\n            default: \"active\"\n      \n      output_schema:\n        type: object\n        required: [alerts, total]\n        properties:\n          alerts:\n            type: array\n            items:\n              type: object\n              properties:\n                id:\n                  type: string\n                customerId:\n                  type: string\n                customerName:\n                  type: string\n                severity:\n                  type: string\n                type:\n                  type: string\n                message:\n                  type: string\n                status:\n                  type: string\n                createdAt:\n                  type: string\n                  format: date-time\n          total:\n            type: integer\n\n  # ========================================================================\n  # LLM Configuration\n  # ========================================================================\n  # Defines the language model used for generation tasks.\n  # For RAG pipelines, choose models with good reasoning and context handling.\n  # ========================================================================\n  llm:\n    # Provider name (openai, anthropic, azure-openai, etc.)\n    provider: \"openai\"\n\n    # Model identifier - GPT-4 for high-quality reasoning over retrieved context\n    model: \"gpt-4\"\n\n    # Temperature controls randomness (0.0=deterministic, 1.0=creative)\n    # 0.7 balances consistency with natural variation\n    temperature: 0.7\n\n    # Maximum tokens per generation (controls cost and latency)\n    maxTokens: 2000\n\n  # ========================================================================\n  # Tools Configuration (MCP and HTTP endpoints)\n  # ========================================================================\n  # Defines external tools the agent can invoke during execution.\n  # MCP (Model Context Protocol) provides standardized tool interfaces.\n  # ========================================================================\n  tools:\n    # Qdrant vector database for semantic search (RAG retrieval step)\n    - type: \"mcp\"\n      server: \"qdrant-mcp\"              # MCP server name (from config)\n      namespace: \"default\"               # Kubernetes namespace\n      capabilities:\n        - semantic_search                # Find similar customer cases\n        - vector_retrieval               # Fetch embeddings by ID\n        - get_point                      # Get specific vector point\n        - search_points                  # Batch vector search\n\n    # Agent Router for LLM and embedding generation\n    - type: \"http\"\n      server: \"agent-router\"\n      endpoint: \"http://agent-router:4000\"\n      capabilities:\n        - llm_generation                 # GPT-4 text generation\n        - embedding_generation           # text-embedding-ada-002\n\n  # ========================================================================\n  # Communication Protocols\n  # ========================================================================\n  # Defines how external systems can interact with this agent.\n  # Multiple protocols enable different integration patterns.\n  # ========================================================================\n  protocols:\n    # RESTful HTTP API for traditional request/response (most common)\n    - type: \"http\"\n      version: \"1.1\"\n      endpoint: \"/api/v1/recommendations\"\n\n    # Server-Sent Events for real-time streaming (dashboards, live updates)\n    - type: \"sse\"\n      version: \"1.0\"\n      endpoint: \"/api/v1/stream\"\n\n    # JSON-RPC for agent-to-agent communication (A2A protocol)\n    - type: \"json-rpc\"\n      version: \"2.0\"\n      endpoint: \"/api/v1/rpc\"\n\n  # ========================================================================\n  # Compliance and Governance\n  # ========================================================================\n  # Defines regulatory frameworks and data handling requirements.\n  # Used for audit trails, data retention, and access control.\n  # ========================================================================\n  compliance:\n    # Regulatory frameworks this agent complies with\n    frameworks: [\"SOC2\", \"HIPAA\"]\n\n    # Data sensitivity level (public, internal, confidential, restricted)\n    dataClassification: \"confidential\"\n\n    # Data retention policy for audit and compliance\n    retentionPolicy: \"7years\"\n\n# ============================================================================\n# OSSA Drupal Extensions\n# ============================================================================\n# Drupal-specific configuration for integration with ai_agent_orchestra module.\n# This section is OSSA's extension mechanism for framework-specific features.\n# ============================================================================\nextensions:\n  drupal:\n    # Drupal module that implements this agent\n    module: \"ai_agent_orchestra\"\n\n    # Drupal service ID for dependency injection\n    # Registered in ai_agent_orchestra.services.yml\n    service: \"ai_agent_orchestra.gitlab_ml_recommendations\"\n\n    # Drupal module dependencies (must be enabled)\n    dependencies:\n      - \"ai_agents\"                  # Core AI agent framework\n      - \"ai_provider_langchain\"      # LangChain integration\n      - \"ai_provider_openai\"         # OpenAI provider\n\n    # Database tables created by this agent's schema\n    database:\n      tables:\n        - \"gitlab_ml_metrics\"           # Customer health metrics (TimescaleDB)\n        - \"gitlab_ml_alerts\"            # Active health alerts\n        - \"gitlab_ml_recommendations\"   # Generated recommendations\n      schema_version: \"1.0.0\"           # For schema migrations\n\n    # ======================================================================\n    # RAG Pipeline Configuration\n    # ======================================================================\n    # Retrieval-Augmented Generation settings for semantic search and LLM.\n    # This is the core of the recommendation engine.\n    # ======================================================================\n    rag_pipeline:\n      vector_db: \"qdrant\"                              # Vector database type\n      collection: \"gitlab_customer_embeddings\"         # Qdrant collection name\n      embedding_model: \"text-embedding-ada-002\"        # OpenAI embedding model\n      similarity_limit: 5                              # Top-K results from search\n      similarity_threshold: 0.7                        # Minimum cosine similarity\n      llm_service: \"http://agent-router:4000\"          # LLM generation endpoint\n\n    # ======================================================================\n    # Observability Configuration (OpenTelemetry)\n    # ======================================================================\n    # Distributed tracing, metrics, and structured logging for production.\n    # ======================================================================\n    monitoring:\n      metrics: true           # Prometheus metrics\n      tracing: true           # OpenTelemetry traces\n      logging: true           # Structured JSON logs\n      opentelemetry:\n        endpoint: \"http://agent-tracer:4318\"     # OTLP collector endpoint\n        service_name: \"gitlab-ml-recommender\"    # Service identifier in traces\n        headers:\n          \"x-service-version\": \"1.0.0\"           # Custom trace metadata\n\n    # ======================================================================\n    # Drupal Cache Integration\n    # ======================================================================\n    # Caches recommendation results to reduce LLM costs and latency.\n    # ======================================================================\n    caching:\n      enabled: true\n      backend: \"redis\"        # Drupal cache backend (redis, database, memcache)\n      ttl: 3600               # Cache TTL in seconds (1 hour)\n      tags:                   # Cache tags for invalidation\n        - \"gitlab_ml\"\n        - \"recommendations\"\n\n    # Drupal permissions required to use this agent\n    permissions:\n      - \"administer ai agents\"       # Full agent management\n      - \"execute ai agents\"           # Execute agent capabilities\n      - \"view ai agent results\"       # View recommendation history\n\n    # ======================================================================\n    # Agent-to-Agent (A2A) Communication\n    # ======================================================================\n    # Enables this agent to call other agents for compliance checks,\n    # cost optimization, and orchestration workflows.\n    # ======================================================================\n    a2a_config:\n      enabled: true\n      protocol: \"json-rpc\"              # JSON-RPC 2.0 for A2A calls\n      endpoints:\n        # Compliance validator ensures recommendations meet policies\n        - \"http://compliance-validator:8080/a2a\"\n        # Cost optimizer prevents budget overruns\n        - \"http://cost-optimizer:8080/a2a\"\n      authentication:\n        type: \"bearer\"                  # Bearer token authentication\n        secretRef:                      # Kubernetes secret reference\n          name: \"drupal-a2a-credentials\"\n          key: \"bearer-token\"\n\n    # ======================================================================\n    # Event Bus Integration (Redis Pub/Sub)\n    # ======================================================================\n    # Publishes events for real-time dashboards and workflow automation.\n    # ======================================================================\n    event_bus:\n      enabled: true\n      # Event topics this agent publishes to\n      topics:\n        - \"customer.health.changed\"      # Health score updates\n        - \"recommendations.generated\"    # New recommendations available\n        - \"alerts.created\"               # New health alerts\n        - \"metrics.updated\"              # Metric aggregation complete\n      redis:\n        host: \"redis://buildkit-redis:16379\"\n        db: 0\n\n# ============================================================================\n# End of OSSA Drupal Integration Example\n# ============================================================================\n#\n# VALIDATION:\n#   ossa validate examples/drupal/gitlab-ml-recommender.ossa.yaml\n#\n# DEPLOYMENT:\n#   1. Enable required Drupal modules: drush en ai_agent_orchestra\n#   2. Import agent manifest: drush ossa:import gitlab-ml-recommender.ossa.yaml\n#   3. Clear Drupal cache: drush cr\n#   4. Test capabilities: drush ossa:test gitlab-ml-recommender\n#\n# INTEGRATION POINTS:\n#   - Drupal Service: ai_agent_orchestra.gitlab_ml_recommendations\n#   - Database Tables: gitlab_ml_* (see schema in module)\n#   - Cache Tags: gitlab_ml, recommendations\n#   - Permissions: administer/execute/view ai agents\n#   - Events: customer.health.changed, recommendations.generated\n#\n# RELATED EXAMPLES:\n#   - examples/bridges/aiflow-bridge-example.yml (social agent bridge)\n#   - examples/openapi-extensions/worker-agent-api.openapi.yml (OpenAPI)\n#   - spec/OSSA_Drupal_Extensions.md (full Drupal spec)\n# ============================================================================\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "gitlab-ml-recommender.v0.2.2.ossa.yaml",
    "path": "drupal/gitlab-ml-recommender.v0.2.2.ossa.yaml",
    "content": "apiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: gitlab-ml-recommender\n  version: 1.0.0\n  description: |\n    AI-powered customer success recommendation agent using RAG (Retrieval-Augmented Generation).\n\n    Pipeline:\n    1. Semantic search in Qdrant for similar successful cases\n    2. GPT-4 generation with context\n    3. Priority ranking based on customer health\n\n    Integrates with:\n    - GitLabMlRecommendationsService (RAG generation)\n    - GitLabMlDashboardService (health metrics)\n    - QdrantVectorService (semantic search)\n  labels: {}\n  annotations:\n    ossa.io/migration: v1.0 to v0.2.2\n    ossa.io/migrated-date: 2025-10-31\nspec:\n  role: integration\n  taxonomy:\n    domain: data\n    subdomain: general\n    capability: general\n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.7\n    maxTokens: 2000\n  tools:\n    - type: mcp\n      name: generate_recommendations\n      server: gitlab-ml-recommender\n    - type: mcp\n      name: get_dashboard_overview\n      server: gitlab-ml-recommender\n    - type: mcp\n      name: get_active_alerts\n      server: gitlab-ml-recommender\n  extensions:\n    buildkit:\n      deployment:\n        replicas:\n          min: 1\n          max: 4\n      container:\n        image: llm-platform/ml-recommender:1.0.0\n        runtime: docker\n        resources: &a1\n          cpu: 1000m\n          memory: 2Gi\n    runtime:\n      type: docker\n      image: llm-platform/ml-recommender:1.0.0\n      requirements:\n        php: \">=8.1\"\n        node: \">=20.0.0\"\n        packages:\n          - guzzlehttp/guzzle\n          - symfony/http-client\n      resources: *a1\n      health_check:\n        type: http\n        endpoint: /health\n        port: 8080\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "agent.yml",
    "path": "enterprise/agent.yml",
    "content": "# Enterprise OSSA Agent Example (400+ lines)\n# Platinum conformance level - Enterprise-grade with all features\n\nossa: 1.0\nagent:\n  name: enterprise-ai-orchestrator\n  version: 3.5.0\n  description: Enterprise-grade AI orchestration platform with multi-model support\n  author: Enterprise AI Division\n  license: Commercial\n  conformance: platinum\n  tags:\n    - enterprise\n    - orchestration\n    - multi-model\n    - secure\n    - scalable\n\ndiscover:\n  auto: true\n  protocol: uadp\n  registry: https://registry.ossa.ai\n  endpoints:\n    - https://discovery.ossa.ai/agents\n    - https://enterprise.ossa.ai/discovery\n\ncapabilities:\n  # Core AI Capabilities\n  - text_generation\n  - text_analysis\n  - code_generation\n  - code_review\n  - image_generation\n  - image_analysis\n  - speech_to_text\n  - text_to_speech\n  - translation\n  - summarization\n  # Orchestration Capabilities\n  - workflow_orchestration\n  - agent_coordination\n  - task_distribution\n  - load_balancing\n  # Enterprise Features\n  - audit_logging\n  - compliance_checking\n  - data_governance\n  - security_scanning\n\napi:\n  POST /orchestrate:\n    capability: workflow_orchestration\n    description: Orchestrate complex AI workflows\n\n  POST /generate/text:\n    capability: text_generation\n    description: Generate text using multiple models\n\n  POST /generate/code:\n    capability: code_generation\n    description: Generate code with review\n\n  POST /analyze/document:\n    capability: text_analysis\n    description: Deep document analysis\n\n  POST /analyze/image:\n    capability: image_analysis\n    description: Computer vision analysis\n\n  POST /coordinate:\n    capability: agent_coordination\n    description: Coordinate multiple agents\n\n  GET /health:\n    description: Comprehensive health status\n\n  GET /metrics:\n    description: Detailed Prometheus metrics\n\n  GET /ready:\n    description: Readiness probe\n\n  GET /live:\n    description: Liveness probe\n\nmonitoring:\n  io_aware: true\n\n  logs:\n    format: jsonl\n    level: info\n    trace: true\n    retention: 90d\n    outputs:\n      - type: elasticsearch\n        config:\n          url: https://logs.enterprise.com\n      - type: file\n        config:\n          path: /var/log/ossa/orchestrator.log\n          rotation: hourly\n          max_files: 168\n    sampling:\n      enabled: true\n      rate: 1.0\n      rules:\n        - level: debug\n          rate: 0.1\n        - level: error\n          rate: 1.0\n\n  metrics:\n    enabled: true\n    endpoint: /metrics\n    format: prometheus\n    interval: 30\n    exporters:\n      - type: prometheus\n        endpoint: http://prometheus:9090\n      - type: datadog\n        endpoint: https://api.datadoghq.com\n      - type: cloudwatch\n        config:\n          region: us-east-1\n    custom_metrics:\n      - name: workflow_executions_total\n        type: counter\n        labels: [workflow_type, status, tenant]\n      - name: model_latency_seconds\n        type: histogram\n        labels: [model, operation]\n        buckets: [0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10]\n      - name: active_agents\n        type: gauge\n        labels: [agent_type]\n      - name: token_usage_total\n        type: counter\n        labels: [model, tenant, operation]\n\n  traces:\n    enabled: true\n    format: otlp\n    endpoint: https://traces.enterprise.com:4317\n    sampling:\n      type: adaptive\n      rate: 0.1\n      max_per_second: 1000\n    propagation: [tracecontext, baggage, b3]\n    io_capture:\n      enabled: true\n      max_input_size: 10MB\n      max_output_size: 10MB\n      truncate: true\n\n  health:\n    enabled: true\n    endpoint: /health\n    interval: 15\n    checks:\n      - name: postgres_primary\n        type: tcp\n        config:\n          port: 5432\n          timeout: 5\n        critical: true\n      - name: redis_cache\n        type: tcp\n        config:\n          port: 6379\n          timeout: 5\n      - name: elasticsearch\n        type: http\n        config:\n          url: http://elasticsearch:9200/_cluster/health\n          timeout: 10\n      - name: model_servers\n        type: grpc\n        config:\n          port: 50051\n          timeout: 5\n        critical: true\n\n  alerts:\n    enabled: true\n    channels:\n      - name: pagerduty\n        type: pagerduty\n        config:\n          integration_key: \"${PAGERDUTY_KEY}\"\n      - name: slack\n        type: slack\n        config:\n          webhook_url: \"${SLACK_WEBHOOK}\"\n      - name: email\n        type: email\n        config:\n          smtp_host: smtp.enterprise.com\n          from: alerts@enterprise.com\n    rules:\n      - name: high_error_rate\n        condition: \"error_rate > 0.05\"\n        severity: critical\n        channels: [pagerduty, slack]\n      - name: high_latency\n        condition: \"p95_latency > 5s\"\n        severity: high\n        channels: [slack]\n        throttle: 300\n\n  redaction:\n    enabled: true\n    patterns:\n      - pattern: \"\\\\b[A-Z]{2}\\\\d{2}\\\\s?\\\\d{4}\\\\s?\\\\d{4}\\\\s?\\\\d{4}\\\\s?\\\\d{4}\\\\b\"\n        name: credit_card\n        replacement: \"[CC-REDACTED]\"\n      - pattern: \"\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b\"\n        name: ssn\n        replacement: \"[SSN-REDACTED]\"\n      - pattern: \"\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b\"\n        name: email\n        replacement: \"[EMAIL-REDACTED]\"\n      - pattern: \"Bearer\\\\s+[A-Za-z0-9\\\\-._~\\\\+/]+={0,2}\"\n        name: bearer_token\n        replacement: \"[TOKEN-REDACTED]\"\n\n  retention:\n    logs:\n      duration: 90d\n      archive:\n        enabled: true\n        location: s3://enterprise-logs-archive\n        after: 30d\n    metrics:\n      duration: 365d\n      archive:\n        enabled: true\n        location: s3://enterprise-metrics-archive\n        after: 90d\n    traces:\n      duration: 30d\n\nperformance:\n  token_optimization:\n    enabled: true\n    strategies:\n      - type: flash_attention\n        config:\n          block_size: 512\n      - type: paged_kv\n        config:\n          page_size: 4096\n      - type: grouped_query\n        config:\n          num_groups: 8\n    max_context: 128000\n    compression:\n      enabled: true\n      method: zstd\n      level: 3\n\n  cache:\n    enabled: true\n    layers:\n      - name: l1_memory\n        type: memory\n        size: 1GB\n        ttl: 60\n      - name: l2_redis\n        type: redis\n        ttl: 3600\n        config:\n          host: redis-primary\n          port: 6379\n          password: \"${REDIS_PASSWORD}\"\n      - name: l3_disk\n        type: disk\n        size: 100GB\n        config:\n          path: /var/cache/ossa\n    key_strategy: hybrid\n    eviction:\n      policy: lru\n      max_entries: 100000\n\n  quantization:\n    enabled: true\n    method: awq\n    target_bits: 4\n    calibration:\n      dataset: enterprise-calibration-v2\n      samples: 512\n      method: percentile\n\n  batching:\n    enabled: true\n    dynamic: true\n    max_batch_size: 128\n    timeout_ms: 50\n    padding: bucket\n    buckets: [128, 256, 512, 1024, 2048, 4096]\n\n  resources:\n    limits:\n      cpu: \"16\"\n      memory: 64Gi\n      disk: 500Gi\n    requests:\n      cpu: \"8\"\n      memory: 32Gi\n    gpu:\n      required: true\n      type: nvidia\n      model: A100\n      count: 4\n      memory: 80GB\n      compute_capability: \"8.0\"\n    network:\n      bandwidth: 10Gbps\n      timeout: 60000\n      retry:\n        enabled: true\n        max_attempts: 5\n        backoff: exponential\n        initial_delay: 1000\n        max_delay: 30000\n\n  scaling:\n    enabled: true\n    type: both\n    horizontal:\n      min_replicas: 3\n      max_replicas: 100\n      target_cpu: 70\n      target_memory: 80\n      metrics:\n        - name: requests_per_second\n          target: 1000\n          type: average\n        - name: pending_workflows\n          target: 100\n          type: average\n    vertical:\n      enabled: true\n      update_mode: auto\n      cpu:\n        min: \"4\"\n        max: \"32\"\n      memory:\n        min: 16Gi\n        max: 128Gi\n\n  optimization:\n    compiler:\n      enabled: true\n      backend: tensorrt\n      mode: max_performance\n    runtime:\n      torch_dynamo: true\n      cuda_graphs: true\n      amp:\n        enabled: true\n        dtype: float16\n      fusion: true\n    model:\n      pruning:\n        enabled: true\n        sparsity: 0.5\n      distillation:\n        enabled: false\n\nbridge:\n  mcp:\n    enabled: true\n    server_type: websocket\n    tools:\n      - name: orchestrateWorkflow\n        description: Orchestrate AI workflow\n        capability: workflow_orchestration\n      - name: coordinateAgents\n        description: Coordinate multiple agents\n        capability: agent_coordination\n    resources:\n      - uri: ossa://workflows\n        name: Available Workflows\n        mimeType: application/json\n    config:\n      max_message_size: 10485760\n      timeout_ms: 30000\n      retry_count: 3\n\n  a2a:\n    enabled: true\n    card_url: https://enterprise.ai/agents/orchestrator.json\n    schema_version: \"1.0\"\n    capabilities_mapping:\n      workflow_orchestration: orchestrate\n      agent_coordination: coordinate\n\n  openapi:\n    enabled: true\n    spec_url: ./openapi.yaml\n    spec_version: \"3.1\"\n    servers:\n      - url: https://api.enterprise.ai\n        description: Production API\n      - url: https://staging.enterprise.ai\n        description: Staging API\n\n  langchain:\n    enabled: true\n    tool_class: EnterpriseOrchestrator\n    chain_type: agent\n    memory:\n      type: vector\n      max_tokens: 128000\n    callbacks:\n      - EnterpriseLogger\n      - ComplianceAuditor\n    export:\n      as_tool: true\n      as_chain: true\n      as_agent: true\n\n  crewai:\n    enabled: true\n    agent_type: manager\n    role: Enterprise AI Orchestrator\n    goal: Efficiently orchestrate complex AI workflows\n    backstory: Advanced orchestration system managing enterprise AI operations\n    max_iter: 50\n    allow_delegation: true\n\n  autogen:\n    enabled: true\n    agent_type: assistant\n    system_message: Enterprise AI orchestration and coordination\n    human_input_mode: NEVER\n    code_execution:\n      enabled: true\n      work_dir: /tmp/autogen\n      use_docker: true\n    max_consecutive_auto_reply: 25\n\n  custom:\n    drupal:\n      enabled: true\n      modules: [mcp, experience_builder, eca]\n      api_version: \"11.x\"\n    gitlab:\n      enabled: true\n      ci_component: gitlab.com/blueflyio/agent-platform/gitlab_components/golden@v0.1.0",
    "category": "Production"
  },
  {
    "name": "drupal-v1.yml",
    "path": "extensions/drupal-v1.yml",
    "content": "# OSSA Drupal Extension Schema\n# Extension specification for Drupal LLM Platform deployment\n# Compatible with Drupal 10+ and llm-platform modules\n\napiVersion: ossa/v1\nkind: ExtensionSchema\nmetadata:\n  name: drupal-extension\n  version: v1\n  namespace: ossa/extensions\n  \nspec:\n  platform: drupal\n  compatibleWith:\n    - \"drupal/11\"\n    - \"drupal/10\"\n  \n  description: \"Extension schema for Drupal LLM Platform agent deployment and orchestration\"\n\n  additionalFields:\n    module:\n      type: string\n      required: true\n      pattern: \"^[a-z][a-z0-9_]*$\"\n      description: \"Drupal module that owns this agent\"\n      examples:\n        - \"ai_agents\"\n        - \"ai_agent_orchestra\"\n        - \"ai_agent_marketplace\"\n\n    service:\n      type: string\n      required: true\n      pattern: \"^[a-z][a-z0-9_]*\\\\.[a-z][a-z0-9_]*$\"\n      description: \"Drupal service ID for agent execution (module.service format)\"\n      examples:\n        - \"ai_agents.executor\"\n        - \"ai_agent_orchestra.gitlab_ml_recommendations\"\n        - \"ai_agent_marketplace.discovery\"\n\n    dependencies:\n      type: array\n      items:\n        type: string\n        pattern: \"^[a-z][a-z0-9_]*$\"\n      description: \"Required Drupal modules (must be installed)\"\n      examples:\n        - [\"ai_agents\", \"ai_provider_langchain\", \"ai_provider_openai\"]\n\n    database:\n      type: object\n      properties:\n        tables:\n          type: array\n          items:\n            type: string\n          description: \"Required database tables (without prefix)\"\n          examples:\n            - [\"gitlab_ml_metrics\", \"gitlab_ml_alerts\"]\n        migrations:\n          type: array\n          items:\n            type: string\n          description: \"Required migration IDs\"\n        schema_version:\n          type: string\n          description: \"Database schema version\"\n\n    rag_pipeline:\n      type: object\n      description: \"RAG (Retrieval-Augmented Generation) pipeline configuration\"\n      properties:\n        vector_db:\n          type: string\n          enum: [\"qdrant\", \"weaviate\", \"pinecone\"]\n          default: \"qdrant\"\n          description: \"Vector database for semantic search\"\n        collection:\n          type: string\n          description: \"Vector collection name\"\n        embedding_model:\n          type: string\n          default: \"text-embedding-ada-002\"\n          description: \"Embedding model for vector generation\"\n        similarity_limit:\n          type: integer\n          default: 5\n          minimum: 1\n          maximum: 100\n          description: \"Number of similar documents to retrieve\"\n        similarity_threshold:\n          type: number\n          default: 0.7\n          minimum: 0\n          maximum: 1\n          description: \"Minimum similarity score (0-1)\"\n        llm_service:\n          type: string\n          format: uri\n          description: \"LLM service endpoint for generation\"\n          examples:\n            - \"http://agent-router:4000\"\n            - \"http://localhost:3007\"\n\n    monitoring:\n      type: object\n      description: \"Observability and monitoring configuration\"\n      properties:\n        metrics:\n          type: boolean\n          default: true\n          description: \"Enable Prometheus metrics\"\n        tracing:\n          type: boolean\n          default: true\n          description: \"Enable OpenTelemetry tracing\"\n        logging:\n          type: boolean\n          default: true\n          description: \"Enable structured logging\"\n        opentelemetry:\n          type: object\n          properties:\n            endpoint:\n              type: string\n              format: uri\n              description: \"OpenTelemetry collector endpoint\"\n              examples:\n                - \"http://agent-tracer:4318\"\n            service_name:\n              type: string\n              description: \"Service name for tracing\"\n            headers:\n              type: object\n              additionalProperties:\n                type: string\n              description: \"Additional headers for OTLP export\"\n\n    caching:\n      type: object\n      description: \"Drupal caching configuration for agent results\"\n      properties:\n        enabled:\n          type: boolean\n          default: true\n        backend:\n          type: string\n          enum: [\"redis\", \"database\", \"memory\"]\n          default: \"redis\"\n        ttl:\n          type: integer\n          description: \"Cache TTL in seconds\"\n          default: 3600\n        tags:\n          type: array\n          items:\n            type: string\n          description: \"Cache tags for invalidation\"\n\n    permissions:\n      type: array\n      items:\n        type: string\n      description: \"Required Drupal permissions\"\n      examples:\n        - [\"administer ai agents\", \"execute ai agents\"]\n\n    a2a_config:\n      type: object\n      description: \"Agent-to-Agent communication configuration\"\n      properties:\n        enabled:\n          type: boolean\n          default: false\n        protocol:\n          type: string\n          enum: [\"json-rpc\", \"http\", \"sse\"]\n          default: \"json-rpc\"\n        endpoints:\n          type: array\n          items:\n            type: string\n            format: uri\n        authentication:\n          type: object\n          properties:\n            type:\n              type: string\n              enum: [\"bearer\", \"oauth2\", \"mtls\"]\n            secretRef:\n              type: object\n              properties:\n                name:\n                  type: string\n                key:\n                  type: string\n\n    event_bus:\n      type: object\n      description: \"Event bus integration for pub/sub\"\n      properties:\n        enabled:\n          type: boolean\n          default: false\n        topics:\n          type: array\n          items:\n            type: string\n          description: \"Event topics to subscribe/publish\"\n        redis:\n          type: object\n          properties:\n            host:\n              type: string\n              format: uri\n            db:\n              type: integer\n              default: 0\n\n  validation:\n    required:\n      - module\n      - service\n    \n    customRules:\n      - name: \"validate-drupal-service-format\"\n        rule: \"Service ID must follow module.service naming convention\"\n        \n      - name: \"validate-module-exists\"\n        rule: \"Module specified must be installed in Drupal\"\n        \n      - name: \"validate-dependencies\"\n        rule: \"All dependencies must be installed Drupal modules\"\n        \n      - name: \"validate-rag-pipeline\"\n        rule: \"If rag_pipeline specified, vector_db and collection are required\"\n        \n      - name: \"validate-monitoring-endpoint\"\n        rule: \"If monitoring.tracing is true, opentelemetry.endpoint must be provided\"\n\n  examples:\n    - name: \"GitLab ML Recommendation Agent\"\n      description: \"RAG-powered customer success agent\"\n      manifest:\n        drupal:\n          module: \"ai_agent_orchestra\"\n          service: \"ai_agent_orchestra.gitlab_ml_recommendations\"\n          dependencies:\n            - \"ai_agents\"\n            - \"ai_provider_langchain\"\n          rag_pipeline:\n            vector_db: \"qdrant\"\n            collection: \"gitlab_customer_embeddings\"\n            similarity_limit: 5\n            llm_service: \"http://agent-router:4000\"\n          monitoring:\n            metrics: true\n            tracing: true\n            opentelemetry:\n              endpoint: \"http://agent-tracer:4318\"\n\n  migration:\n    fromVersion: \"none\"\n    toVersion: \"v1\"\n    breakingChanges: []\n    migrationGuide: \"https://ossa.dev/docs/drupal/migration\"\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "kagent-v1.yml",
    "path": "extensions/kagent-v1.yml",
    "content": "# OSSA kAgent Extension Schema\n# Production-grade specification for Kubernetes-native agent deployment\n# Compatible with kagent.dev/v1alpha1 CRDs\n\napiVersion: ossa/v1\nkind: ExtensionSchema\nmetadata:\n  name: kagent-extension\n  version: v1alpha1\n  namespace: ossa/extensions\nspec:\n  compatibleWith:\n    - kagent.dev/v1alpha1\n  description: \"Extension schema for Kubernetes-native agent deployment via kAgent\"\n\n  additionalFields:\n    agent:\n      kubernetes:\n        namespace:\n          type: string\n          default: \"default\"\n          description: \"Target Kubernetes namespace\"\n        labels:\n          type: object\n          additionalProperties:\n            type: string\n          description: \"Kubernetes labels for agent CRD\"\n        annotations:\n          type: object\n          additionalProperties:\n            type: string\n          description: \"Kubernetes annotations for agent CRD\"\n        resourceLimits:\n          type: object\n          properties:\n            cpu:\n              type: string\n              default: \"100m\"\n            memory:\n              type: string\n              default: \"256Mi\"\n          description: \"Kubernetes resource limits\"\n\n      toolRefs:\n        type: array\n        items:\n          type: object\n          required: [name, type]\n          properties:\n            name:\n              type: string\n              description: \"Tool name\"\n            type:\n              type: string\n              enum: [mcp, kubernetes, http, custom]\n              description: \"Tool type\"\n            serverRef:\n              type: object\n              properties:\n                name:\n                  type: string\n                namespace:\n                  type: string\n                  default: \"default\"\n              description: \"Reference to MCP server or Kubernetes resource\"\n            config:\n              type: object\n              additionalProperties: true\n              description: \"Tool-specific configuration\"\n\n      a2aConfig:\n        type: object\n        properties:\n          enabled:\n            type: boolean\n            default: false\n          endpoints:\n            type: array\n            items:\n              type: string\n            description: \"A2A protocol endpoints\"\n          protocol:\n            type: string\n            enum: [json-rpc, http, sse]\n            default: \"json-rpc\"\n          authentication:\n            type: object\n            properties:\n              type:\n                type: string\n                enum: [mtls, bearer, oauth2]\n              credentials:\n                type: string\n                format: secret\n          description: \"Agent-to-Agent communication configuration\"\n\n      guardrails:\n        type: object\n        properties:\n          requireApproval:\n            type: boolean\n            default: true\n          costLimits:\n            type: object\n            properties:\n              maxTokensPerDay:\n                type: integer\n              maxTokensPerRequest:\n                type: integer\n              maxCostPerDay:\n                type: number\n              currency:\n                type: string\n                default: \"USD\"\n          allowedActions:\n            type: array\n            items:\n              type: string\n            description: \"Permitted agent actions\"\n          blockedActions:\n            type: array\n            items:\n              type: string\n            description: \"Forbidden agent actions\"\n          auditLog:\n            type: object\n            properties:\n              destination:\n                type: string\n                enum: [compliance-engine, agent-tracer, external]\n              retention:\n                type: string\n                pattern: \"^\\d+[years|months|days]$\"\n              description: \"Audit logging configuration\"\n\n      meshIntegration:\n        type: object\n        properties:\n          enabled:\n            type: boolean\n            default: false\n          istioIntegration:\n            type: boolean\n            default: false\n          ambientMesh:\n            type: boolean\n            default: false\n          description: \"Service mesh integration (Istio/Cilium)\"\n\n  validation:\n    required:\n      - kubernetes.namespace\n      - toolRefs\n    customRules:\n      - name: \"validate-tool-references\"\n        rule: \"All toolRefs must reference valid MCP servers or Kubernetes resources\"\n      - name: \"validate-a2a-endpoints\"\n        rule: \"If a2aConfig.enabled is true, endpoints must be provided\"\n      - name: \"validate-cost-limits\"\n        rule: \"If costLimits specified, maxTokensPerDay must be positive\"\n\n  migration:\n    fromVersion: \"v0.1.9\"\n    toVersion: \"v1alpha1\"\n    breakingChanges: []\n    migrationGuide: \"https://ossa.dev/docs/kagent/migration\"\n\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "hello-world-complete.ossa.yaml",
    "path": "getting-started/hello-world-complete.ossa.yaml",
    "content": "# ============================================================================\n# OSSA v0.2.x - Complete \"Hello World\" Agent Example\n# ============================================================================\n# \n# PURPOSE:\n#   This is a minimal, fully-compliant OSSA agent manifest demonstrating\n#   all required fields and best practices. Use this as a starting point\n#   for your first agent.\n#\n# LEARNING OBJECTIVES:\n#   1. Understand OSSA manifest structure (apiVersion, kind, metadata, spec)\n#   2. Learn required vs optional fields\n#   3. See how to define agent capabilities (tools)\n#   4. Understand LLM configuration\n#   5. Learn basic observability setup\n#\n# VALIDATION:\n#   ossa validate examples/getting-started/hello-world-complete.ossa.yaml\n#\n# DEPLOYMENT:\n#   This agent can be deployed to any OSSA-compatible runtime:\n#   - Kubernetes (via agent-buildkit)\n#   - Docker Compose\n#   - Serverless (AWS Lambda, Google Cloud Functions)\n#   - Local development\n#\n# INTEGRATION PATTERNS:\n#   - Standalone agent (no dependencies)\n#   - Can be called via HTTP/gRPC\n#   - Can participate in multi-agent workflows\n#   - Compatible with MCP (Model Context Protocol)\n#\n# ============================================================================\n\napiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  # REQUIRED: Agent identifier (DNS-1123 format for Kubernetes compatibility)\n  # Must be lowercase alphanumeric with hyphens, max 253 chars\n  name: hello-world-agent\n  \n  # REQUIRED: Semantic version (semver 2.0.0)\n  # Format: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n  version: 1.0.0\n  \n  # REQUIRED: Human-readable description\n  # Should explain what the agent does, its purpose, and key capabilities\n  description: |\n    A minimal OSSA-compliant agent that demonstrates basic capabilities.\n    This agent can greet users, echo messages, and report its status.\n    Perfect for learning OSSA fundamentals and testing deployments.\n  \n  # OPTIONAL: Key-value labels for organization and filtering\n  # Common labels: environment, team, domain, classification\n  labels:\n    environment: development\n    team: platform-engineering\n    domain: examples\n    complexity: minimal\n  \n  # OPTIONAL: Arbitrary metadata for tooling (not used for filtering)\n  # Common annotations: documentation URL, support contact, runbooks\n  annotations:\n    documentation: https://docs.ossa.io/examples/hello-world\n    support: support@example.com\n    runbook: https://runbooks.example.com/hello-world-agent\n\nspec:\n  # REQUIRED: Agent role/system prompt describing behavior and capabilities\n  # This is the \"personality\" and instructions for the LLM\n  # Should be clear, specific, and aligned with the agent's purpose\n  role: |\n    You are a helpful assistant agent that can:\n    1. Greet users with personalized messages\n    2. Echo back messages sent to you\n    3. Report your current status and health\n    \n    Always be friendly, concise, and helpful. If you receive a request\n    you cannot handle, politely explain your limitations.\n  \n  # REQUIRED: LLM configuration\n  # Defines which language model powers this agent\n  llm:\n    # REQUIRED: LLM provider (openai, anthropic, google, azure, ollama, custom)\n    provider: openai\n    \n    # REQUIRED: Model identifier (specific to provider)\n    # OpenAI: gpt-4, gpt-4-turbo, gpt-3.5-turbo\n    # Anthropic: claude-3-opus-20240229, claude-3-sonnet-20240229\n    # Google: gemini-pro, gemini-pro-vision\n    model: gpt-3.5-turbo\n    \n    # OPTIONAL: Temperature (0.0-2.0) - Controls randomness\n    # 0.0 = deterministic, 1.0 = balanced, 2.0 = very creative\n    # Lower values better for structured tasks, higher for creative tasks\n    temperature: 0.7\n    \n    # OPTIONAL: Maximum tokens per request\n    # Limits response length. Set based on expected output size\n    maxTokens: 1000\n    \n    # OPTIONAL: Top-p (nucleus sampling) - 0.0-1.0\n    # Alternative to temperature. 0.9 = consider top 90% probability mass\n    topP: 0.9\n  \n  # REQUIRED: Available tools/capabilities for the agent\n  # Each tool represents a capability the agent can use\n  # Must have at least one tool\n  tools:\n    # Tool 1: Greeting capability\n    - type: function\n      name: greet_user\n      description: |\n        Generate a personalized greeting message for a user.\n        Takes a user name and optional context, returns a friendly greeting.\n      # Tool-specific configuration\n      config:\n        # Example: This could reference a function, API endpoint, or MCP server\n        handler: greet_handler\n        timeout: 5\n      \n      # OPTIONAL: Authentication for tool access\n      auth:\n        type: none  # Options: bearer, oauth2, mtls, apikey, none\n    \n    # Tool 2: Echo capability\n    - type: function\n      name: echo_message\n      description: |\n        Echo back a message sent to the agent.\n        Useful for testing and demonstrating basic agent communication.\n      config:\n        handler: echo_handler\n        timeout: 2\n    \n    # Tool 3: Status reporting\n    - type: http\n      name: get_status\n      description: |\n        Get the current status and health of the agent.\n        Returns agent metadata, uptime, and capability status.\n      endpoint: http://localhost:8080/status\n      config:\n        method: GET\n        timeout: 3\n      auth:\n        type: none\n  \n  # OPTIONAL: Autonomy configuration\n  # Controls how independently the agent can operate\n  autonomy:\n    # Level of autonomy: supervised, autonomous, fully_autonomous\n    # supervised = requires human approval for actions\n    # autonomous = can act independently within constraints\n    # fully_autonomous = complete independence (use with caution)\n    level: supervised\n    \n    # Whether human approval is required before executing actions\n    approval_required: true\n    \n    # Whitelist of permitted actions (if specified, only these are allowed)\n    allowed_actions:\n      - greet_user\n      - echo_message\n      - get_status\n    \n    # Blacklist of forbidden actions\n    blocked_actions: []\n  \n  # OPTIONAL: Constraints and limits\n  constraints:\n    # Cost constraints (prevent runaway spending)\n    cost:\n      # Maximum tokens per day (prevents excessive API usage)\n      maxTokensPerDay: 100000\n      \n      # Maximum tokens per request\n      maxTokensPerRequest: 2000\n      \n      # Maximum cost per day (in specified currency)\n      maxCostPerDay: 10.00\n      \n      # Currency code (ISO 4217, 3-letter code)\n      currency: USD\n    \n    # Performance constraints\n    performance:\n      # Maximum latency in seconds\n      maxLatencySeconds: 5.0\n      \n      # Maximum concurrent requests\n      maxConcurrentRequests: 10\n      \n      # Request timeout in seconds\n      timeoutSeconds: 30\n    \n    # Resource constraints (for Kubernetes deployments)\n    resources:\n      cpu: \"100m\"      # 0.1 CPU cores (Kubernetes format)\n      memory: \"256Mi\"  # 256 megabytes (Kubernetes format)\n      # gpu: \"1\"       # Optional GPU requirement\n  \n  # OPTIONAL: Observability configuration\n  # Enables monitoring, tracing, and logging\n  observability:\n    # Distributed tracing (OpenTelemetry, Jaeger, Zipkin)\n    tracing:\n      enabled: true\n      exporter: otlp  # Options: otlp, jaeger, zipkin, custom\n      endpoint: http://localhost:4318  # OTLP collector endpoint\n    \n    # Metrics collection (Prometheus, OTLP)\n    metrics:\n      enabled: true\n      exporter: prometheus  # Options: prometheus, otlp, custom\n      endpoint: http://localhost:9090/metrics\n    \n    # Logging configuration\n    logging:\n      level: info  # Options: debug, info, warn, error\n      format: json  # Options: json, text\n\n# ============================================================================\n# USAGE EXAMPLES\n# ============================================================================\n#\n# 1. VALIDATE THIS MANIFEST:\n#    $ ossa validate examples/getting-started/hello-world-complete.ossa.yaml\n#\n# 2. DEPLOY TO KUBERNETES (via agent-buildkit):\n#    $ buildkit agents deploy examples/getting-started/hello-world-complete.ossa.yaml\n#\n# 3. TEST LOCALLY:\n#    $ ossa validate examples/getting-started/hello-world-complete.ossa.yaml --verbose\n#\n# 4. INTEGRATE WITH MCP:\n#    This agent can be exposed via MCP (Model Context Protocol) for use\n#    with Claude Desktop, Cursor, or other MCP-compatible tools.\n#\n# 5. USE IN MULTI-AGENT WORKFLOW:\n#    This agent can be orchestrated alongside other agents using\n#    agent-buildkit's workflow engine.\n#\n# ============================================================================\n# NEXT STEPS\n# ============================================================================\n#\n# After understanding this example:\n# 1. Review examples/intermediate/ for more complex patterns\n# 2. Check examples/advanced/ for enterprise patterns\n# 3. Read the full OSSA specification at spec/v0.2.x/ossa-0.2.x.schema.json\n# 4. Explore integration examples in examples/bridges/\n# 5. See migration guides in examples/migration-guides/\n#\n# ============================================================================\n# RELATED DOCUMENTATION\n# ============================================================================\n#\n# - OSSA Specification: spec/v0.2.x/ossa-0.2.x.schema.json\n# - Schema Reference: docs/schemas/\n# - API Reference: openapi/\n# - GitHub Repository: https://github.com/blueflyio/openstandardagents\n#\n# ============================================================================\n\n",
    "category": "Getting Started"
  },
  {
    "name": "agent-to-agent-orchestration.ossa.yaml",
    "path": "integration-patterns/agent-to-agent-orchestration.ossa.yaml",
    "content": "# ============================================================================\n# Integration Pattern: Agent-to-Agent Orchestration\n# ============================================================================\n#\n# PURPOSE:\n#   Demonstrates how multiple OSSA agents can work together in orchestrated\n#   workflows. This pattern enables complex multi-agent systems where agents\n#   coordinate to solve problems beyond any single agent's capabilities.\n#\n# USE CASES:\n#   - Multi-step workflows requiring specialized agents\n#   - Research → Analysis → Writing pipelines\n#   - Code review → Testing → Deployment workflows\n#   - Customer support escalation chains\n#   - Data processing pipelines with multiple stages\n#\n# ARCHITECTURE:\n#   Orchestrator Agent (coordinates workflow)\n#     ↓\n#   Worker Agent 1 (specialized task)\n#     ↓\n#   Worker Agent 2 (specialized task)\n#     ↓\n#   Aggregator Agent (combines results)\n#\n# PROTOCOLS:\n#   - HTTP/gRPC for synchronous communication\n#   - Message queues for asynchronous workflows\n#   - MCP (Model Context Protocol) for tool sharing\n#   - Event-driven patterns for reactive workflows\n#\n# ============================================================================\n\n# ----------------------------------------------------------------------------\n# ORCHESTRATOR AGENT\n# ----------------------------------------------------------------------------\n# Coordinates the workflow, delegates tasks to worker agents, and aggregates results\n\napiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  name: workflow-orchestrator\n  version: 1.0.0\n  description: |\n    Orchestrates multi-agent workflows by coordinating specialized worker agents.\n    Manages workflow state, handles failures, and aggregates results.\n\nspec:\n  role: |\n    You are a workflow orchestrator. Your job is to:\n    1. Break down complex tasks into subtasks\n    2. Delegate subtasks to appropriate worker agents\n    3. Monitor progress and handle failures\n    4. Aggregate results from worker agents\n    5. Provide final output to the user\n    \n    Always coordinate clearly, handle errors gracefully, and provide status updates.\n  \n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.3  # Lower temperature for more deterministic orchestration\n  \n  tools:\n    # Tool: Invoke Research Agent\n    - type: http\n      name: invoke_research_agent\n      description: |\n        Delegate research tasks to the specialized research agent.\n        Returns comprehensive research results on the requested topic.\n      endpoint: http://research-agent:8080/api/v1/research\n      config:\n        method: POST\n        timeout: 60  # Research can take time\n      auth:\n        type: bearer\n        credentials: ORCHESTRATOR_TOKEN\n    \n    # Tool: Invoke Analysis Agent\n    - type: http\n      name: invoke_analysis_agent\n      description: |\n        Delegate analysis tasks to the specialized analysis agent.\n        Analyzes data and provides insights.\n      endpoint: http://analysis-agent:8080/api/v1/analyze\n      config:\n        method: POST\n        timeout: 30\n      auth:\n        type: bearer\n        credentials: ORCHESTRATOR_TOKEN\n    \n    # Tool: Invoke Writing Agent\n    - type: http\n      name: invoke_writing_agent\n      description: |\n        Delegate writing tasks to the specialized writing agent.\n        Creates well-structured content based on research and analysis.\n      endpoint: http://writing-agent:8080/api/v1/write\n      config:\n        method: POST\n        timeout: 45\n      auth:\n        type: bearer\n        credentials: ORCHESTRATOR_TOKEN\n    \n    # Tool: Check Agent Status\n    - type: http\n      name: check_agent_status\n      description: |\n        Check the status and health of worker agents.\n        Returns availability, current load, and capability status.\n      endpoint: http://agent-registry:8080/api/v1/agents/status\n      config:\n        method: GET\n        timeout: 5\n  \n  autonomy:\n    level: autonomous\n    approval_required: false\n    allowed_actions:\n      - invoke_research_agent\n      - invoke_analysis_agent\n      - invoke_writing_agent\n      - check_agent_status\n  \n  constraints:\n    cost:\n      maxTokensPerDay: 500000\n      maxCostPerDay: 50.00\n      currency: USD\n    performance:\n      maxLatencySeconds: 120  # Multi-agent workflows take longer\n      maxConcurrentRequests: 5\n      timeoutSeconds: 180\n  \n  observability:\n    tracing:\n      enabled: true\n      exporter: otlp\n      endpoint: http://jaeger:4318\n    metrics:\n      enabled: true\n      exporter: prometheus\n      endpoint: http://prometheus:9090/metrics\n    logging:\n      level: info\n      format: json\n\n# ----------------------------------------------------------------------------\n# RESEARCH WORKER AGENT\n# ----------------------------------------------------------------------------\n# Specialized agent for research tasks\n\n---\napiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  name: research-worker\n  version: 1.0.0\n  description: |\n    Specialized research agent that gathers comprehensive information on topics.\n    Used by orchestrator for research-intensive subtasks.\n\nspec:\n  role: |\n    You are a research specialist. Your job is to:\n    1. Gather accurate, up-to-date information on requested topics\n    2. Use multiple sources and verify information\n    3. Provide well-sourced, comprehensive research results\n    4. Cite sources and provide evidence\n    \n    Always prioritize accuracy over speed. Verify facts from multiple sources.\n  \n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.2  # Lower temperature for factual accuracy\n  \n  tools:\n    - type: http\n      name: web_search\n      description: Search the web for current information\n      endpoint: https://api.search.com/search\n      config:\n        method: POST\n        timeout: 15\n      auth:\n        type: apikey\n        credentials: SEARCH_API_KEY\n    \n    - type: http\n      name: academic_search\n      description: Search academic papers and publications\n      endpoint: https://api.academic.com/search\n      config:\n        method: POST\n        timeout: 20\n      auth:\n        type: apikey\n        credentials: ACADEMIC_API_KEY\n  \n  autonomy:\n    level: autonomous\n    approval_required: false\n  \n  constraints:\n    cost:\n      maxTokensPerDay: 200000\n      maxCostPerDay: 20.00\n      currency: USD\n    performance:\n      maxLatencySeconds: 60\n      maxConcurrentRequests: 10\n\n# ----------------------------------------------------------------------------\n# ANALYSIS WORKER AGENT\n# ----------------------------------------------------------------------------\n# Specialized agent for data analysis\n\n---\napiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  name: analysis-worker\n  version: 1.0.0\n  description: |\n    Specialized analysis agent that processes data and provides insights.\n    Used by orchestrator for analysis-intensive subtasks.\n\nspec:\n  role: |\n    You are a data analysis specialist. Your job is to:\n    1. Analyze data and research results\n    2. Identify patterns, trends, and insights\n    3. Provide clear, actionable recommendations\n    4. Support conclusions with data\n    \n    Always be objective, data-driven, and clear in your analysis.\n  \n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.3\n  \n  tools:\n    - type: function\n      name: statistical_analysis\n      description: Perform statistical analysis on datasets\n      config:\n        handler: stats_handler\n        language: python\n        timeout: 30\n    \n    - type: function\n      name: data_visualization\n      description: Create visualizations from data\n      config:\n        handler: viz_handler\n        language: python\n        timeout: 20\n  \n  autonomy:\n    level: autonomous\n    approval_required: false\n  \n  constraints:\n    cost:\n      maxTokensPerDay: 200000\n      maxCostPerDay: 20.00\n      currency: USD\n    performance:\n      maxLatencySeconds: 45\n      maxConcurrentRequests: 8\n\n# ----------------------------------------------------------------------------\n# WRITING WORKER AGENT\n# ----------------------------------------------------------------------------\n# Specialized agent for content creation\n\n---\napiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  name: writing-worker\n  version: 1.0.0\n  description: |\n    Specialized writing agent that creates well-structured content.\n    Used by orchestrator for writing-intensive subtasks.\n\nspec:\n  role: |\n    You are a writing specialist. Your job is to:\n    1. Create well-structured, clear content\n    2. Synthesize information from research and analysis\n    3. Write in appropriate style and tone\n    4. Ensure accuracy and clarity\n    \n    Always write clearly, engagingly, and accurately. Structure content logically.\n  \n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.7  # Higher temperature for more creative writing\n  \n  tools:\n    - type: function\n      name: format_document\n      description: Format documents in various styles (Markdown, HTML, LaTeX)\n      config:\n        handler: format_handler\n        timeout: 10\n  \n  autonomy:\n    level: autonomous\n    approval_required: false\n  \n  constraints:\n    cost:\n      maxTokensPerDay: 200000\n      maxCostPerDay: 20.00\n      currency: USD\n    performance:\n      maxLatencySeconds: 45\n      maxConcurrentRequests: 8\n\n# ============================================================================\n# WORKFLOW EXAMPLE\n# ============================================================================\n#\n# User Request: \"Research quantum computing trends and write a report\"\n#\n# Orchestrator Workflow:\n#   1. Receive request\n#   2. Invoke research-worker → Get research results\n#   3. Invoke analysis-worker → Analyze research, identify trends\n#   4. Invoke writing-worker → Create report from research + analysis\n#   5. Return final report to user\n#\n# Error Handling:\n#   - If research-worker fails → Retry with backup research agent\n#   - If analysis-worker fails → Use simpler analysis approach\n#   - If writing-worker fails → Return research + analysis directly\n#\n# ============================================================================\n# DEPLOYMENT\n# ============================================================================\n#\n# 1. Deploy all agents:\n#    $ buildkit agents deploy examples/integration-patterns/agent-to-agent-orchestration.ossa.yaml\n#\n# 2. Configure service discovery:\n#    - Ensure agents can discover each other (DNS, service mesh, registry)\n#    - Set up authentication tokens\n#    - Configure network policies\n#\n# 3. Set up observability:\n#    - Distributed tracing across agents\n#    - Metrics aggregation\n#    - Log correlation\n#\n# ============================================================================\n# RELATED PATTERNS\n# ============================================================================\n#\n# - examples/integration-patterns/mcp-bridge-integration.ossa.yaml\n# - examples/integration-patterns/event-driven-agents.ossa.yaml\n# - examples/integration-patterns/openapi-service-exposure.ossa.yaml\n# - examples/agent-manifests/orchestrators/orchestrator-agent.yaml\n#\n# ============================================================================\n\n",
    "category": "Advanced Patterns"
  },
  {
    "name": "compliance-validator.ossa.yaml",
    "path": "kagent/compliance-validator.ossa.yaml",
    "content": "# OSSA kAgent Reference Implementation #5\n# Compliance Validator Agent\n# Domain: compliance.validation.continuous\n\napiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: compliance-validator\n  version: 1.0.0\n  description: \"Continuous compliance validation for SOC2, HIPAA, FedRAMP, and NIST frameworks\"\n\nspec:\n  taxonomy:\n    domain: compliance\n    subdomain: validation\n    capability: continuous\n\n  role: |\n    You are a compliance validation agent that continuously monitors infrastructure\n    and applications for compliance violations. You enforce SOC2, HIPAA, FedRAMP,\n    and NIST cybersecurity framework requirements. You generate audit reports\n    and maintain compliance evidence.\n\n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.1\n    maxTokens: 8000\n\n  tools:\n    - type: mcp\n      server: kubernetes-mcp\n      capabilities:\n        - audit_rbac\n        - check_network_policies\n        - validate_encryption\n\n    - type: mcp\n      server: buildkit-compliance-engine\n      capabilities:\n        - validate_policies\n        - generate_audit_reports\n        - track_compliance_status\n        - collect_evidence\n\n    - type: mcp\n      server: buildkit-agent-tracer\n      capabilities:\n        - trace_access\n        - audit_logs\n\n  autonomy:\n    level: autonomous\n    approval_required: false\n    allowed_actions:\n      - validate_compliance\n      - generate_reports\n      - collect_evidence\n      - send_alerts\n      - block_non_compliant_deployments\n\n  constraints:\n    cost:\n      maxTokensPerDay: 150000\n      maxCostPerDay: 35.0\n    performance:\n      maxLatencySeconds: 45\n      validationInterval: 1800\n\n  extensions:\n    kagent:\n      kubernetes:\n        namespace: compliance\n        labels:\n          app: compliance-validator\n          team: compliance\n          environment: production\n          frameworks: soc2-hipaa-fedramp-nist\n        annotations:\n          compliance.level: \"critical\"\n          audit.required: \"true\"\n        resourceLimits:\n          cpu: \"1000m\"\n          memory: \"2Gi\"\n\n      guardrails:\n        requireApproval: false\n        costLimits:\n          maxTokensPerDay: 150000\n        allowedActions:\n          - validate_all_namespaces\n          - block_deployments\n          - generate_evidence\n        auditLog:\n          destination: compliance-engine\n          retention: 10years\n\n      a2aConfig:\n        enabled: true\n        protocol: json-rpc\n        endpoints:\n          - http://security-scanner:8080/a2a\n          - http://documentation-agent:8080/a2a\n          - http://k8s-troubleshooter:8080/a2a\n        authentication:\n          type: mtls\n\n      meshIntegration:\n        enabled: true\n        istioIntegration: true\n        ambientMesh: true\n",
    "category": "Infrastructure"
  },
  {
    "name": "cost-optimizer.ossa.yaml",
    "path": "kagent/cost-optimizer.ossa.yaml",
    "content": "# OSSA kAgent Reference Implementation #3\n# Cost Optimizer Agent\n# Domain: infrastructure.cost.optimization\n\napiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: cost-optimizer\n  version: 1.0.0\n  description: \"Intelligent cost optimization agent for Kubernetes workloads\"\n\nspec:\n  taxonomy:\n    domain: infrastructure\n    subdomain: cost\n    capability: optimization\n\n  role: |\n    You are a cost optimization agent that analyzes Kubernetes resource usage,\n    identifies waste, and recommends optimizations. You use VORTEX v3 for\n    token reduction (85%) and monitor cloud costs across providers.\n\n  llm:\n    provider: openai\n    model: gpt-4-turbo\n    temperature: 0.3\n    maxTokens: 2000\n\n  tools:\n    - type: mcp\n      server: kubernetes-mcp\n      capabilities:\n        - get_resource_usage\n        - get_node_metrics\n        - analyze_costs\n\n    - type: mcp\n      server: buildkit-agent-router\n      capabilities:\n        - route_to_cheapest_model\n        - optimize_token_usage\n        - apply_vortex_optimization\n\n    - type: mcp\n      server: buildkit-agent-tracer\n      capabilities:\n        - track_costs\n        - analyze_spending\n\n  autonomy:\n    level: supervised\n    approval_required: true\n    allowed_actions:\n      - analyze_costs\n      - generate_recommendations\n      - create_optimization_reports\n    blocked_actions:\n      - scale_down_workloads\n      - delete_resources\n\n  constraints:\n    cost:\n      maxTokensPerDay: 30000\n      maxCostPerDay: 5.0\n    performance:\n      maxLatencySeconds: 20\n      optimizationInterval: 7200\n\n  extensions:\n    kagent:\n      kubernetes:\n        namespace: finops\n        labels:\n          app: cost-optimizer\n          team: finops\n          environment: production\n        resourceLimits:\n          cpu: \"250m\"\n          memory: \"256Mi\"\n\n      guardrails:\n        requireApproval: true\n        costLimits:\n          maxTokensPerDay: 30000\n        auditLog:\n          destination: compliance-engine\n          retention: 7years\n\n      a2aConfig:\n        enabled: true\n        protocol: json-rpc\n        endpoints:\n          - http://k8s-troubleshooter:8080/a2a\n",
    "category": "Infrastructure"
  },
  {
    "name": "documentation-agent.ossa.yaml",
    "path": "kagent/documentation-agent.ossa.yaml",
    "content": "# OSSA kAgent Reference Implementation #4\n# Documentation Agent\n# Domain: documentation.generation.automated\n\napiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: documentation-agent\n  version: 1.0.0\n  description: \"Automated technical documentation generation and maintenance agent\"\n\nspec:\n  taxonomy:\n    domain: documentation\n    subdomain: generation\n    capability: automated\n\n  role: |\n    You are a technical documentation agent that generates and maintains\n    comprehensive documentation for Kubernetes deployments, APIs, and infrastructure.\n    You integrate with doc-engine for PDF generation and support multiple formats.\n\n  llm:\n    provider: anthropic\n    model: claude-3-opus-20240229\n    temperature: 0.4\n    maxTokens: 16000\n\n  tools:\n    - type: mcp\n      server: kubernetes-mcp\n      capabilities:\n        - discover_resources\n        - extract_metadata\n        - analyze_architecture\n\n    - type: mcp\n      server: buildkit-doc-engine\n      capabilities:\n        - generate_pdf\n        - create_diagrams\n        - format_markdown\n\n    - type: mcp\n      server: buildkit-agent-protocol\n      capabilities:\n        - search_codebase\n        - analyze_apis\n\n  autonomy:\n    level: autonomous\n    approval_required: false\n    allowed_actions:\n      - generate_documentation\n      - update_docs\n      - create_diagrams\n      - publish_to_wiki\n\n  constraints:\n    cost:\n      maxTokensPerDay: 200000\n      maxCostPerDay: 50.0\n    performance:\n      maxLatencySeconds: 120\n      generationInterval: 86400\n\n  extensions:\n    kagent:\n      kubernetes:\n        namespace: docs\n        labels:\n          app: documentation-agent\n          team: documentation\n          environment: production\n        resourceLimits:\n          cpu: \"500m\"\n          memory: \"1Gi\"\n\n      guardrails:\n        requireApproval: false\n        costLimits:\n          maxTokensPerDay: 200000\n        auditLog:\n          destination: compliance-engine\n          retention: 3years\n\n      a2aConfig:\n        enabled: true\n        protocol: json-rpc\n        endpoints:\n          - http://compliance-validator:8080/a2a\n",
    "category": "Infrastructure"
  },
  {
    "name": "k8s-troubleshooter-v1.ossa.yaml",
    "path": "kagent/k8s-troubleshooter-v1.ossa.yaml",
    "content": "# OSSA v1.0 KAgent Example\n# Kubernetes Troubleshooter Agent with KAgent Bridge\n# Fully compatible with kagent.dev/v1alpha2\n\nossaVersion: \"1.0\"\n\nagent:\n  id: k8s-troubleshooter\n  name: Kubernetes Troubleshooter\n  version: 1.0.0\n  description: Autonomous Kubernetes cluster troubleshooting agent with diagnostic capabilities\n  role: monitoring\n  tags:\n    - kubernetes\n    - troubleshooting\n    - infrastructure\n    - diagnostics\n\n  runtime:\n    type: k8s\n    image: ossa/k8s-troubleshooter:1.0.0\n    resources:\n      cpu: \"500m\"\n      memory: \"512Mi\"\n    health_check:\n      type: http\n      endpoint: /health\n      port: 8080\n      initial_delay_seconds: 30\n      period_seconds: 10\n      timeout_seconds: 5\n      failure_threshold: 3\n\n  capabilities:\n    - name: diagnose_pod_failures\n      description: Diagnose why pods are failing or crashing\n      input_schema:\n        type: object\n        required:\n          - namespace\n          - pod_name\n        properties:\n          namespace:\n            type: string\n            description: Kubernetes namespace\n          pod_name:\n            type: string\n            description: Pod name pattern\n      output_schema:\n        type: object\n        properties:\n          status:\n            type: string\n            enum: [healthy, degraded, failed]\n          issues:\n            type: array\n            items:\n              type: object\n              properties:\n                type:\n                  type: string\n                severity:\n                  type: string\n                  enum: [critical, warning, info]\n                message:\n                  type: string\n                remediation:\n                  type: string\n      timeout_seconds: 120\n      retry_policy:\n        max_attempts: 3\n        backoff: exponential\n\n    - name: analyze_resource_constraints\n      description: Analyze CPU and memory resource constraints\n      input_schema:\n        type: object\n        required:\n          - namespace\n        properties:\n          namespace:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          cpu_pressure:\n            type: boolean\n          memory_pressure:\n            type: boolean\n          recommendations:\n            type: array\n            items:\n              type: string\n      timeout_seconds: 60\n\n    - name: check_network_connectivity\n      description: Verify network connectivity between services\n      input_schema:\n        type: object\n        required:\n          - source_service\n          - target_service\n        properties:\n          source_service:\n            type: string\n          target_service:\n            type: string\n          namespace:\n            type: string\n            default: default\n      output_schema:\n        type: object\n        properties:\n          reachable:\n            type: boolean\n          latency_ms:\n            type: number\n          errors:\n            type: array\n            items:\n              type: string\n\n  policies:\n    compliance:\n      - soc2-type2\n      - iso27001\n    data_residency:\n      - US\n    encryption: true\n    audit: true\n    pii_handling: prohibit\n\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://k8s-troubleshooter:8080\n      health: /health\n      metrics: /metrics\n      openapi: /api/openapi.json\n    auth:\n      type: jwt\n      config:\n        issuer: https://auth.company.com\n        audience: k8s-troubleshooter\n    rate_limits:\n      requests_per_second: 10\n      requests_per_minute: 500\n      burst: 20\n\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:8080/health\n    phoenix_arise:\n      enabled: true\n      project: infrastructure-agents\n      export_interval_seconds: 60\n\n  dependencies:\n    required:\n      - agent_id: security-scanner\n        min_version: 1.0.0\n        max_version: 2.0.0\n    optional:\n      - agent_id: cost-optimizer\n        fallback: skip_optimization\n\n  metadata:\n    author: Platform Team\n    maintainer: platform-team@company.com\n    homepage: https://github.com/company/k8s-troubleshooter\n    repository: https://github.com/company/k8s-troubleshooter\n    documentation: https://docs.company.com/agents/k8s-troubleshooter\n    license: Apache-2.0\n    keywords:\n      - kubernetes\n      - troubleshooting\n      - monitoring\n      - diagnostics\n\n  # Multi-framework bridge configuration\n  bridge:\n    # KAgent bridge for Kubernetes-native deployment\n    kagent:\n      enabled: true\n      api_version: kagent.dev/v1alpha2\n      agent_type: declarative\n      deployment:\n        replicas: 2\n        resources:\n          requests:\n            cpu: \"250m\"\n            memory: \"256Mi\"\n          limits:\n            cpu: \"500m\"\n            memory: \"512Mi\"\n      model_config: gpt-4\n      system_message: |\n        You are an expert Kubernetes troubleshooter. You diagnose pod failures,\n        network issues, resource constraints, and configuration problems.\n        You use kubectl and monitoring tools to identify root causes and suggest remediation steps.\n      a2a_config:\n        skills:\n          - id: diagnose_pod_failures\n            name: Diagnose Pod Failures\n            description: Identify why pods are failing or crashing in Kubernetes\n            examples:\n              - Why is my-app-pod crashing in the production namespace?\n              - Diagnose ImagePullBackOff errors in the staging environment\n            tags:\n              - kubernetes\n              - pods\n              - diagnostics\n          - id: analyze_resource_constraints\n            name: Analyze Resource Constraints\n            description: Check for CPU and memory pressure in namespaces\n            examples:\n              - Are there resource constraints in the production namespace?\n              - Check memory pressure for my-service\n            tags:\n              - kubernetes\n              - resources\n              - performance\n          - id: check_network_connectivity\n            name: Check Network Connectivity\n            description: Verify network connectivity between Kubernetes services\n            examples:\n              - Can frontend-service reach backend-service?\n              - Test network connectivity from app-a to app-b\n            tags:\n              - kubernetes\n              - networking\n              - connectivity\n\n    # MCP bridge for Claude Desktop/Cursor integration\n    mcp:\n      enabled: true\n      server_type: stdio\n      tools:\n        - name: diagnose_pod\n          description: Diagnose Kubernetes pod issues\n          input_schema:\n            type: object\n            properties:\n              namespace:\n                type: string\n              pod_name:\n                type: string\n          output_schema:\n            type: object\n            properties:\n              status:\n                type: string\n              issues:\n                type: array\n          capability: diagnose_pod_failures\n\n    # A2A protocol bridge for agent-to-agent communication\n    a2a:\n      enabled: true\n      card_url: https://company.com/agents/k8s-troubleshooter/card.json\n      schema_version: \"1.0\"\n\n    # OpenAPI bridge for REST API integration\n    openapi:\n      enabled: true\n      spec_url: http://k8s-troubleshooter:8080/api/openapi.json\n      spec_version: \"3.1\"\n",
    "category": "Infrastructure"
  },
  {
    "name": "k8s-troubleshooter-v1.v0.2.2.ossa.yaml",
    "path": "kagent/k8s-troubleshooter-v1.v0.2.2.ossa.yaml",
    "content": "apiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: k8s-troubleshooter\n  version: 1.0.0\n  description: Autonomous Kubernetes cluster troubleshooting agent with diagnostic capabilities\n  labels:\n    kubernetes: \"true\"\n    troubleshooting: \"true\"\n    infrastructure: \"true\"\n    diagnostics: \"true\"\n  annotations:\n    ossa.io/migration: v1.0 to v0.2.2\n    ossa.io/migrated-date: 2025-10-29\nspec:\n  role: monitoring\n  taxonomy:\n    domain: infrastructure\n    subdomain: kubernetes\n    capability: troubleshooting\n  tools:\n    - type: mcp\n      name: diagnose_pod_failures\n      server: k8s-troubleshooter\n      capabilities:\n        - with_input_schema\n    - type: mcp\n      name: analyze_resource_constraints\n      server: k8s-troubleshooter\n      capabilities:\n        - with_input_schema\n    - type: mcp\n      name: check_network_connectivity\n      server: k8s-troubleshooter\n      capabilities:\n        - with_input_schema\n  observability:\n    tracing:\n      enabled: true\n    metrics:\n      enabled: true\n    logging:\n      level: info\n      format: json\n  extensions:\n    mcp:\n      enabled: true\n      server_type: stdio\n      tools:\n        - name: diagnose_pod_failures\n          description: Diagnose why pods are failing or crashing\n        - name: analyze_resource_constraints\n          description: Analyze CPU and memory resource constraints\n        - name: check_network_connectivity\n          description: Verify network connectivity between services\n    buildkit:\n      deployment:\n        replicas:\n          min: 1\n          max: 4\n        health_check:\n          path: /health\n          port: 8080\n      container:\n        image: ossa/k8s-troubleshooter:1.0.0\n        runtime: k8s\n        resources: &a1\n          cpu: 500m\n          memory: 512Mi\n    kagent:\n      kubernetes:\n        namespace: default\n        labels:\n          app: k8s-troubleshooter\n        resourceLimits: *a1\n      deployment:\n        replicas: 2\n        strategy: rolling-update\n    runtime:\n      type: k8s\n      image: ossa/k8s-troubleshooter:1.0.0\n      resources: *a1\n      health_check:\n        type: http\n        endpoint: /health\n        port: 8080\n        initial_delay_seconds: 30\n        period_seconds: 10\n        timeout_seconds: 5\n        failure_threshold: 3\n    integration:\n      protocol: http\n      endpoints:\n        base_url: http://k8s-troubleshooter:8080\n        health: /health\n        metrics: /metrics\n        openapi: /api/openapi.json\n      auth:\n        type: jwt\n        config:\n          issuer: https://auth.company.com\n          audience: k8s-troubleshooter\n      rate_limits:\n        requests_per_second: 10\n        requests_per_minute: 500\n        burst: 20\n",
    "category": "Infrastructure"
  },
  {
    "name": "k8s-troubleshooter.ossa.yaml",
    "path": "kagent/k8s-troubleshooter.ossa.yaml",
    "content": "# ============================================================================\n# OSSA kAgent Reference Implementation: Kubernetes Troubleshooter Agent\n# ============================================================================\n#\n# This manifest demonstrates OSSA compliance for Kubernetes-native agent\n# deployments with comprehensive diagnostic and troubleshooting capabilities.\n#\n# Key Features:\n#   - K8s runtime integration with pod/node discovery\n#   - RBAC-based permission model for safe cluster operations\n#   - MCP server integration for kubectl command execution\n#   - Supervised autonomy with approval gates\n#   - Service mesh integration (Istio/Ambient)\n#   - Agent-to-Agent (A2A) communication patterns\n#   - Audit logging for compliance and observability\n#\n# Domain: infrastructure.kubernetes.troubleshooting\n# ============================================================================\n\napiVersion: ossa/v1\nkind: Agent\nmetadata:\n  # Basic agent identification metadata\n  name: k8s-troubleshooter\n  version: 1.0.0\n  description: \"Autonomous Kubernetes cluster troubleshooting agent with diagnostic capabilities\"\n\nspec:\n  # =========================================================================\n  # TAXONOMY: Agent Classification & Capabilities\n  # =========================================================================\n  # Defines the functional domain and specialization of this agent within\n  # the infrastructure ecosystem. Used for discovery, routing, and validation.\n  taxonomy:\n    domain: infrastructure           # Primary domain: infrastructure/devops\n    subdomain: kubernetes           # K8s-specific agent\n    capability: troubleshooting     # Core capability: diagnostics & remediation\n\n  # =========================================================================\n  # ROLE: Agent Behavior & Expertise Profile\n  # =========================================================================\n  # Instructs the LLM on this agent's purpose, expertise areas, and approach.\n  # Guides decision-making for K8s diagnosis and troubleshooting workflows.\n  role: |\n    You are an expert Kubernetes troubleshooter. You diagnose pod failures, network issues,\n    resource constraints, and configuration problems. You use kubectl and monitoring tools\n    to identify root causes and suggest remediation steps.\n\n  # =========================================================================\n  # LLM CONFIGURATION: Model Selection & Behavior\n  # =========================================================================\n  # Configures the Large Language Model backend used for reasoning and\n  # diagnostic recommendations. Temperature kept low (0.2) for consistency.\n  llm:\n    provider: openai                # LLM provider for inference\n    model: gpt-4                    # Model with strong K8s/YAML reasoning\n    temperature: 0.2                # Low temperature: consistent diagnostics\n    maxTokens: 4000                 # Token budget for diagnostic analysis\n\n  # =========================================================================\n  # TOOLS: MCP Server Integration & Capabilities\n  # =========================================================================\n  # Declares MCP (Model Context Protocol) servers that provide K8s API access\n  # and kubectl execution capabilities. MCP enables structured interaction\n  # with Kubernetes cluster resources and diagnostic tools.\n  tools:\n    # ===== Kubernetes MCP Server =====\n    # Provides direct access to Kubernetes API resources and kubectl execution\n    # for pod inspection, log retrieval, and event analysis\n    - type: mcp\n      server: kubernetes-mcp\n      namespace: default            # Default K8s namespace for queries\n      capabilities:\n        - get_pods                  # Query pod status and configuration\n        - get_logs                  # Stream pod container logs\n        - get_events                # Retrieve K8s cluster events\n        - describe_resource         # Get detailed resource descriptions\n        - get_metrics               # Access Prometheus/kubelet metrics\n\n    # ===== BuildKit Agent Protocol Server =====\n    # Provides documentation search and log analysis capabilities\n    # for correlating K8s issues with known patterns and solutions\n    - type: mcp\n      server: buildkit-agent-protocol\n      namespace: default\n      capabilities:\n        - search_documentation      # Search troubleshooting KB/runbooks\n        - analyze_logs              # Pattern matching in aggregated logs\n\n  # =========================================================================\n  # AUTONOMY: Permission Model & Action Gates\n  # =========================================================================\n  # Defines the supervision level, approval requirements, and permitted actions.\n  # Follows principle of least privilege for cluster safety.\n  autonomy:\n    level: supervised               # Requires human approval for actions\n    approval_required: true         # All actions need explicit approval\n\n    # ===== ALLOWED READ-ONLY ACTIONS =====\n    # Safe diagnostic operations that don't modify cluster state\n    allowed_actions:\n      - read_pods                   # Query pod metadata/status\n      - read_logs                   # Access application logs\n      - read_events                 # View cluster events\n      - read_metrics                # Access performance metrics\n\n    # ===== BLOCKED DESTRUCTIVE ACTIONS =====\n    # Dangerous operations explicitly forbidden to prevent cluster damage\n    blocked_actions:\n      - delete_pods                 # Prevent accidental pod termination\n      - scale_deployments           # Prevent replica count changes\n      - modify_configs              # Prevent ConfigMap/Secret changes\n\n  # =========================================================================\n  # CONSTRAINTS: Cost & Performance Limits\n  # =========================================================================\n  # Enforces resource limits to prevent excessive API/LLM usage and costs.\n  # Token limits control diagnostic depth; latency limits ensure responsiveness.\n  constraints:\n    cost:\n      maxTokensPerDay: 50000        # Daily token budget for all operations\n      maxTokensPerRequest: 4000     # Per-request token limit\n      maxCostPerDay: 10.0           # USD cost ceiling per day\n      currency: USD\n\n    performance:\n      maxLatencySeconds: 30         # Max response time for diagnostics\n      maxConcurrentRequests: 5      # Concurrent diagnostic requests\n\n  # =========================================================================\n  # EXTENSIONS: kAgent-Specific Kubernetes Integration\n  # =========================================================================\n  # kAgent extensions provide Kubernetes-native deployment configuration,\n  # RBAC integration, service mesh support, and compliance frameworks.\n  extensions:\n    kagent:\n      # =====================================================================\n      # KUBERNETES RUNTIME CONFIGURATION\n      # =====================================================================\n      # Configures how the agent pod itself runs within the cluster,\n      # including namespace, resource limits, and identification labels.\n      kubernetes:\n        namespace: production        # Production namespace for agent pod\n\n        # ===== POD LABELS =====\n        # Standard Kubernetes labels for discovery, monitoring, and routing\n        labels:\n          app: k8s-troubleshooter   # App identifier for selectors\n          team: platform            # Team ownership\n          environment: production   # Environment classification\n\n        # ===== POD ANNOTATIONS =====\n        # Metadata annotations for observability and contact information\n        annotations:\n          description: \"Kubernetes troubleshooting agent\"\n          contact: \"platform-team@company.com\"  # Escalation contact\n\n        # ===== RESOURCE LIMITS =====\n        # Container resource requests/limits to prevent resource starvation\n        # or runaway consumption on cluster nodes\n        resourceLimits:\n          cpu: \"500m\"               # CPU allocation for agent execution\n          memory: \"512Mi\"           # Memory allocation for LLM context\n\n      # =====================================================================\n      # GUARDRAILS: RBAC & Approval Framework\n      # =====================================================================\n      # Enforces mandatory approvals, resource consumption limits, and\n      # specific K8s API action permissions through RBAC-style rules.\n      guardrails:\n        requireApproval: true       # Mandatory approval gate before actions\n\n        costLimits:\n          maxTokensPerDay: 50000    # Daily LLM token consumption limit\n          maxCostPerDay: 10.0       # Financial ceiling (USD)\n          currency: USD\n\n        # ===== K8S API PERMISSION MODEL =====\n        # RBAC-style permissions for specific Kubernetes API resources\n        # Format: kubernetes:<verb>:<resource>\n        allowedActions:\n          - kubernetes:get:pods     # Read pod objects (GET /pods)\n          - kubernetes:get:logs     # Stream logs (GET /pods/logs)\n          - kubernetes:get:events   # List events (GET /events)\n\n        # ===== AUDIT LOGGING =====\n        # Records all agent actions for compliance, debugging, and security\n        auditLog:\n          destination: compliance-engine  # Audit destination service\n          retention: 7years               # Compliance data retention\n\n      # =====================================================================\n      # AGENT-TO-AGENT (A2A) COMMUNICATION CONFIG\n      # =====================================================================\n      # Enables this agent to communicate with other agents (security-scanner,\n      # cost-optimizer) for collaborative diagnostics using JSON-RPC protocol.\n      # Supports multi-agent troubleshooting workflows.\n      a2aConfig:\n        enabled: true               # Enable inter-agent communication\n        protocol: json-rpc          # JSON-RPC 2.0 for agent calls\n\n        # ===== A2A ENDPOINT REGISTRY =====\n        # Other agents this troubleshooter can invoke for specialized analysis\n        endpoints:\n          - http://security-scanner:8080/a2a    # Security audit queries\n          - http://cost-optimizer:8080/a2a      # Cost analysis queries\n\n        # ===== AUTHENTICATION =====\n        # mTLS (mutual TLS) ensures encrypted, authenticated agent-to-agent\n        # communication within the service mesh\n        authentication:\n          type: mtls               # Mutual TLS certificates required\n\n      # =====================================================================\n      # SERVICE MESH INTEGRATION\n      # =====================================================================\n      # Integrates with Kubernetes service mesh technologies for:\n      #   - Encrypted inter-pod communication\n      #   - Observability (traces, metrics)\n      #   - Traffic policy enforcement\n      #   - mTLS authentication between agents\n      meshIntegration:\n        enabled: true               # Enable service mesh features\n        istioIntegration: true      # Istio sidecar injection\n        ambientMesh: true           # Ambient mode support (Istio 1.14+)\n\n# ============================================================================\n# OPERATIONAL NOTES\n# ============================================================================\n#\n# DEPLOYMENT:\n#   This manifest deploys an agent pod to the production namespace with\n#   K8s cluster discovery enabled. The agent pod receives an Istio sidecar\n#   for encrypted inter-agent communication and observability.\n#\n# RBAC REQUIREMENTS:\n#   Requires ClusterRole with permissions for:\n#     - pods (get, list, watch)\n#     - pods/logs (get)\n#     - events (get, list, watch)\n#     - nodes (get, list)\n#     - deployments (get, list)\n#\n# SECURITY CONSIDERATIONS:\n#   - All actions require explicit approval via guardrails\n#   - No destructive actions permitted (no delete/modify)\n#   - mTLS required for agent-to-agent communication\n#   - Audit logging for compliance and troubleshooting\n#   - Resource limits prevent denial-of-service\n#\n# MONITORING & OBSERVABILITY:\n#   - Metrics exported to Prometheus via agent instrumentation\n#   - Traces propagated to Jaeger via Istio sidecars\n#   - Pod logs aggregated via standard K8s logging\n#   - Audit events recorded in compliance-engine\n#\n# ============================================================================\n",
    "category": "Infrastructure"
  },
  {
    "name": "security-scanner.ossa.yaml",
    "path": "kagent/security-scanner.ossa.yaml",
    "content": "# ============================================================================\n# OSSA kAgent Reference Implementation #2\n# Security Scanner Agent - Comprehensive Annotation\n# Domain: security.vulnerability.scanning\n# Purpose: Continuous vulnerability scanning, CVE detection, compliance validation\n# Last Updated: 2025-11-10\n# ============================================================================\n\napiVersion: ossa/v1\nkind: Agent\nmetadata:\n  # Core identity metadata for the security scanning agent\n  name: security-scanner\n  version: 1.0.0\n  description: \"Continuous security vulnerability scanning and compliance validation agent\"\n\nspec:\n  # Taxonomy defines the agent's operational domain and classification\n  # Used for service discovery, capability matching, and policy routing\n  taxonomy:\n    domain: security          # Primary domain for security operations\n    subdomain: vulnerability  # Specialization: vulnerability management\n    capability: scanning      # Core capability: security scanning\n\n  # Role definition: Defines agent's purpose, boundaries, and security responsibilities\n  # This instructs the LLM on its operational context within the security ecosystem\n  role: |\n    You are a security scanning agent that continuously monitors Kubernetes clusters\n    for vulnerabilities, misconfigurations, and compliance violations. You integrate\n    with CVE databases, security benchmarks (CIS, NIST), and provide actionable remediation.\n\n  # LLM Configuration: Controls AI model behavior for security scanning operations\n  # Low temperature (0.1) ensures deterministic, consistent security analysis\n  llm:\n    provider: anthropic\n    model: claude-3-sonnet-20240229\n    temperature: 0.1           # Low temperature for consistent vulnerability assessment\n    maxTokens: 8000            # Token limit for detailed security reports\n\n  # Tools: Defines integrations with security scanning and compliance validation systems\n  # Each tool maps to specific security capabilities: image scanning, RBAC validation, config auditing\n  tools:\n    # Kubernetes-based security operations via MCP server\n    # Provides cluster-level visibility into security posture\n    - type: mcp\n      server: kubernetes-mcp\n      capabilities:\n        - scan_images          # CVE scanning for container images (registry vulnerability detection)\n        - check_rbac           # Role-based access control validation (IAM security)\n        - audit_configs        # Configuration audit against security benchmarks (CIS, NIST)\n\n    # Compliance validation and security policy enforcement via buildkit engine\n    # Enables continuous compliance checking against organizational policies\n    - type: mcp\n      server: buildkit-compliance-engine\n      capabilities:\n        - validate_compliance  # Verify compliance against frameworks (SOC2, FedRAMP, etc.)\n        - check_policies       # Enforce organization-specific security policies\n        - generate_reports     # Create compliance and vulnerability reports\n\n    # Trivy vulnerability scanner: External HTTP service for container/image scanning\n    # Integrates with CVE databases for real-time vulnerability detection\n    - type: http\n      name: trivy-scanner\n      endpoint: http://trivy:8080\n      auth:\n        type: bearer           # Bearer token authentication for API access\n\n  # Autonomy Level: Determines agent decision-making authority and approval workflows\n  # Security agents typically operate autonomously for scanning but require approval for remediation\n  autonomy:\n    level: autonomous          # Can execute scan operations without human intervention\n    approval_required: false   # Scans execute automatically per schedule\n    allowed_actions:\n      - scan_all_namespaces    # Permission: scan all Kubernetes namespaces for vulnerabilities\n      - generate_reports       # Permission: create vulnerability and compliance reports\n      - send_alerts            # Permission: notify security teams of findings\n    blocked_actions:\n      - remediate_automatically  # BLOCKED: Prevent autonomous remediation (human oversight required)\n      - modify_resources         # BLOCKED: Prevent direct cluster modifications\n\n  # Constraints: Operational boundaries for cost, performance, and scanning frequency\n  # Prevents resource exhaustion and maintains predictable operational costs\n  constraints:\n    cost:\n      maxTokensPerDay: 100000   # Daily LLM token budget for security analysis\n      maxCostPerDay: 25.0       # Daily cost cap in USD for AI operations\n    performance:\n      maxLatencySeconds: 60     # Maximum acceptable latency for vulnerability scan results\n      scanInterval: 3600        # Scan frequency: 1 hour (3600 seconds) between full scans\n\n  # Extensions: Kubernetes-specific configurations for agent deployment and runtime governance\n  # Contains kAgent-specific settings for the Kubernetes environment\n  extensions:\n    kagent:\n      # Kubernetes deployment configuration: Where and how agent runs in cluster\n      kubernetes:\n        namespace: security     # Dedicated security namespace for agent isolation\n        labels:\n          app: security-scanner        # Application identifier\n          team: security               # Team ownership\n          environment: production      # Environment classification\n          compliance: soc2-fedramp     # Compliance frameworks: SOC2, FedRAMP\n\n        # Resource limits: Prevents runaway resource consumption during intensive scans\n        resourceLimits:\n          cpu: \"1000m\"                 # 1 CPU core limit\n          memory: \"1Gi\"                # 1GB memory limit for scan operations\n\n      # Guardrails: Security controls and oversight mechanisms for agent operations\n      # Ensures compliance, auditability, and cost control\n      guardrails:\n        requireApproval: false         # Scans don't require approval (scheduled automation)\n        costLimits:\n          maxTokensPerDay: 100000      # Daily token budget enforcement\n        auditLog:\n          destination: compliance-engine  # Send all operations to compliance system\n          retention: 10years              # 10-year retention for regulatory compliance\n\n      # Agent-to-Agent (A2A) Configuration: Inter-agent communication and coordination\n      # Enables security agent to collaborate with other agents (troubleshooter, validator)\n      a2aConfig:\n        enabled: true                  # Enable inter-agent communication\n        protocol: json-rpc             # Communication protocol: JSON-RPC over HTTP\n        endpoints:\n          - http://k8s-troubleshooter:8080/a2a      # Endpoint: Kubernetes troubleshooting agent\n          - http://compliance-validator:8080/a2a    # Endpoint: Compliance validation agent\n\n# ============================================================================\n# SECURITY FEATURES SUMMARY:\n# - CVE Detection: Trivy integration for container image vulnerability scanning\n# - Compliance Checking: Validates against SOC2, FedRAMP, CIS, NIST standards\n# - RBAC Validation: Ensures Kubernetes access controls are properly configured\n# - Config Auditing: Scans cluster configurations against security baselines\n# - Vulnerability Reporting: Generates detailed security and compliance reports\n# - Alert Management: Autonomous notification of security findings\n# - Audit Trail: 10-year retention of all operations via compliance engine\n# - Cost Controls: Daily token and monetary budgets prevent resource exhaustion\n# - Approval Workflows: Blocks autonomous remediation; requires human oversight\n# ============================================================================\n",
    "category": "Infrastructure"
  },
  {
    "name": "chain-agent.ossa.json",
    "path": "langchain/chain-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"langchain-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"LangChain agent with tool chain\"\n  },\n  \"spec\": {\n    \"role\": \"You are a LangChain agent that uses tools to accomplish tasks.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.5\n    },\n    \"tools\": [\n      {\n        \"type\": \"function\",\n        \"name\": \"calculator\",\n        \"capabilities\": [\"add\", \"subtract\", \"multiply\", \"divide\"]\n      },\n      {\n        \"type\": \"http\",\n        \"name\": \"web_search\",\n        \"endpoint\": \"https://api.search.example.com\",\n        \"capabilities\": [\"search\"]\n      }\n    ]\n  },\n  \"extensions\": {\n    \"langchain\": {\n      \"enabled\": true,\n      \"chain_type\": \"agent\",\n      \"tool_class\": \"LangChainTool\",\n      \"memory\": {\n        \"type\": \"buffer\",\n        \"max_tokens\": 1000\n      }\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "workflow-agent.ossa.json",
    "path": "langflow/workflow-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"workflow-orchestrator\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Langflow workflow orchestration agent\"\n  },\n  \"spec\": {\n    \"role\": \"You orchestrate complex workflows by coordinating multiple AI agents and tools.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.5\n    },\n    \"tools\": []\n  },\n  \"extensions\": {\n    \"langflow\": {\n      \"enabled\": true,\n      \"flow_id\": \"workflow-orchestrator-v1\",\n      \"flow_name\": \"Multi-Agent Workflow Orchestrator\",\n      \"endpoint\": \"https://api.langflow.example.com\",\n      \"components\": [\n        {\n          \"id\": \"llm-1\",\n          \"type\": \"OpenAI\",\n          \"name\": \"Primary LLM\"\n        },\n        {\n          \"id\": \"agent-1\",\n          \"type\": \"Agent\",\n          \"name\": \"Workflow Coordinator\"\n        }\n      ]\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "state-machine-agent.ossa.json",
    "path": "langgraph/state-machine-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"state-machine-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"LangGraph state machine agent\"\n  },\n  \"spec\": {\n    \"role\": \"You are a state machine agent that processes requests through defined states.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.3\n    },\n    \"tools\": []\n  },\n  \"extensions\": {\n    \"langgraph\": {\n      \"enabled\": true,\n      \"graph_name\": \"request-processor\",\n      \"state_schema\": {\n        \"messages\": \"list\",\n        \"current_state\": \"str\",\n        \"data\": \"dict\"\n      },\n      \"nodes\": [\n        {\n          \"name\": \"start\",\n          \"function\": \"initialize\"\n        },\n        {\n          \"name\": \"process\",\n          \"function\": \"process_request\"\n        },\n        {\n          \"name\": \"validate\",\n          \"function\": \"validate_response\"\n        }\n      ],\n      \"edges\": [\n        {\n          \"from\": \"start\",\n          \"to\": \"process\"\n        },\n        {\n          \"from\": \"process\",\n          \"to\": \"validate\",\n          \"condition\": \"should_validate\"\n        }\n      ],\n      \"checkpoint\": {\n        \"enabled\": true,\n        \"type\": \"memory\"\n      }\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "rag-agent.ossa.json",
    "path": "llamaindex/rag-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"rag-query-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"LlamaIndex RAG query engine agent\"\n  },\n  \"spec\": {\n    \"role\": \"You answer questions by retrieving and synthesizing information from a knowledge base.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.1\n    },\n    \"tools\": []\n  },\n  \"extensions\": {\n    \"llamaindex\": {\n      \"enabled\": true,\n      \"agent_type\": \"query_engine\",\n      \"llm\": {\n        \"provider\": \"openai\",\n        \"model\": \"gpt-4\",\n        \"temperature\": 0.1\n      },\n      \"vector_store\": {\n        \"type\": \"pinecone\",\n        \"config\": {\n          \"index_name\": \"knowledge-base\",\n          \"environment\": \"us-east-1\"\n        }\n      },\n      \"retrieval\": {\n        \"top_k\": 5,\n        \"similarity_top_k\": 10\n      }\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "from-langchain-to-ossa.yaml",
    "path": "migration-guides/from-langchain-to-ossa.yaml",
    "content": "# ============================================================================\n# Migration Guide: LangChain Agents → OSSA\n# ============================================================================\n#\n# PURPOSE:\n#   This guide demonstrates how to migrate a LangChain agent to OSSA format.\n#   LangChain uses Python-based agent definitions with tools and chains.\n#   OSSA uses declarative YAML manifests that are framework-agnostic.\n#\n# KEY DIFFERENCES:\n#   1. LangChain: Code-based (Python), OSSA: Declarative (YAML)\n#   2. LangChain: Framework-specific, OSSA: Framework-agnostic\n#   3. LangChain: Runtime-coupled, OSSA: Runtime-independent\n#   4. LangChain: Tool execution in code, OSSA: Tool declaration in manifest\n#\n# MIGRATION BENEFITS:\n#   - Deploy to any runtime (not just Python/LangChain)\n#   - Standardized agent definitions across teams\n#   - Better observability and compliance\n#   - Easier testing and validation\n#   - Framework independence\n#\n# ============================================================================\n\n# ----------------------------------------------------------------------------\n# EXAMPLE 1: Simple LangChain Agent → OSSA\n# ----------------------------------------------------------------------------\n#\n# LANGCHAIN CODE (Before):\n# ```python\n# from langchain.agents import initialize_agent, Tool\n# from langchain.llms import OpenAI\n#\n# llm = OpenAI(temperature=0)\n# tools = [\n#     Tool(\n#         name=\"Search\",\n#         func=search_function,\n#         description=\"Search the web for current information\"\n#     ),\n#     Tool(\n#         name=\"Calculator\",\n#         func=calculator_function,\n#         description=\"Perform mathematical calculations\"\n#     )\n# ]\n# agent = initialize_agent(tools, llm, agent=\"zero-shot-react-description\")\n# ```\n#\n# OSSA MANIFEST (After):\n# ----------------------------------------------------------------------------\n\napiVersion: ossa/v0.2.2\nkind: Agent\n\nmetadata:\n  name: langchain-migrated-agent\n  version: 1.0.0\n  description: |\n    Migrated from LangChain zero-shot-react-description agent.\n    Provides web search and calculator capabilities.\n\nspec:\n  role: |\n    You are a helpful assistant that can search the web and perform calculations.\n    Use the available tools to answer user questions accurately.\n    When searching, provide sources. When calculating, show your work.\n  \n  llm:\n    provider: openai\n    model: gpt-3.5-turbo\n    temperature: 0  # Matches LangChain's temperature=0\n  \n  tools:\n    # LangChain Tool: Search → OSSA Tool\n    - type: http\n      name: Search\n      description: Search the web for current information\n      endpoint: https://api.search-service.com/search\n      config:\n        method: POST\n        timeout: 10\n      auth:\n        type: apikey\n        credentials: SEARCH_API_KEY\n    \n    # LangChain Tool: Calculator → OSSA Tool\n    - type: function\n      name: Calculator\n      description: Perform mathematical calculations\n      config:\n        handler: calculator_handler\n        language: python\n        timeout: 5\n\n# ----------------------------------------------------------------------------\n# EXAMPLE 2: LangChain Agent with Custom Tools → OSSA\n# ----------------------------------------------------------------------------\n#\n# LANGCHAIN CODE (Before):\n# ```python\n# from langchain.agents import AgentExecutor, create_react_agent\n# from langchain.prompts import PromptTemplate\n# from langchain.tools import DuckDuckGoSearchRun\n#\n# tools = [DuckDuckGoSearchRun()]\n# prompt = PromptTemplate.from_template(\"\"\"\n#     Answer the following questions as best you can.\n#     Use the following tools: {tools}\n#     Question: {input}\n# \"\"\")\n# agent = create_react_agent(llm, tools, prompt)\n# agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n# ```\n#\n# OSSA MANIFEST (After):\n# ----------------------------------------------------------------------------\n\n---\napiVersion: ossa/v0.2.2\nkind: Agent\n\nmetadata:\n  name: react-agent-migrated\n  version: 1.0.0\n  description: |\n    Migrated LangChain ReAct agent with DuckDuckGo search.\n    Uses ReAct (Reasoning + Acting) pattern for tool use.\n\nspec:\n  # The role field replaces LangChain's prompt template\n  role: |\n    Answer the following questions as best you can.\n    Use the available tools to gather information and answer accurately.\n    Think step by step: reason about what you need, then act using tools.\n  \n  llm:\n    provider: openai\n    model: gpt-4  # ReAct works better with more capable models\n    temperature: 0.3\n  \n  tools:\n    # DuckDuckGo Search Tool\n    - type: http\n      name: DuckDuckGoSearch\n      description: Search the web using DuckDuckGo for current information\n      endpoint: https://api.duckduckgo.com/\n      config:\n        method: GET\n        timeout: 10\n      auth:\n        type: none\n  \n  # Enable verbose logging (equivalent to LangChain's verbose=True)\n  observability:\n    logging:\n      level: debug\n      format: json\n\n# ----------------------------------------------------------------------------\n# EXAMPLE 3: LangChain Multi-Agent System → OSSA Orchestration\n# ----------------------------------------------------------------------------\n#\n# LANGCHAIN CODE (Before):\n# ```python\n# from langchain.agents import AgentExecutor\n# from langchain.agents.agent_types import AgentType\n#\n# # Supervisor agent\n# supervisor = initialize_agent(\n#     tools=[],\n#     llm=llm,\n#     agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION\n# )\n#\n# # Worker agents\n# research_agent = initialize_agent(research_tools, llm, ...)\n# writing_agent = initialize_agent(writing_tools, llm, ...)\n# ```\n#\n# OSSA APPROACH (After):\n#   Create separate OSSA manifests for each agent, then orchestrate them.\n#   See examples/agent-manifests/orchestrators/ for orchestration patterns.\n#\n# ----------------------------------------------------------------------------\n\n---\napiVersion: ossa/v0.2.2\nkind: Agent\n\nmetadata:\n  name: research-agent\n  version: 1.0.0\n  description: Research agent migrated from LangChain multi-agent system\n\nspec:\n  role: |\n    You are a research specialist. Your job is to gather accurate,\n    up-to-date information on topics requested by the supervisor agent.\n    Provide comprehensive, well-sourced research results.\n  \n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.2\n  \n  tools:\n    - type: http\n      name: WebSearch\n      description: Search the web for information\n      endpoint: https://api.search.com/search\n    - type: http\n      name: AcademicSearch\n      description: Search academic papers and publications\n      endpoint: https://api.academic.com/search\n\n---\napiVersion: ossa/v0.2.2\nkind: Agent\n\nmetadata:\n  name: writing-agent\n  version: 1.0.0\n  description: Writing agent migrated from LangChain multi-agent system\n\nspec:\n  role: |\n    You are a writing specialist. Your job is to create well-structured,\n    clear content based on research provided by the research agent.\n    Write in a professional, engaging style.\n  \n  llm:\n    provider: openai\n    model: gpt-4\n    temperature: 0.7\n  \n  tools:\n    - type: function\n      name: FormatDocument\n      description: Format documents in various styles (Markdown, HTML, LaTeX)\n      config:\n        handler: format_handler\n\n# ============================================================================\n# MIGRATION CHECKLIST\n# ============================================================================\n#\n# [ ] 1. Identify LangChain agent type (zero-shot, react, conversational, etc.)\n# [ ] 2. Map LangChain tools to OSSA tools (type: http, function, mcp, etc.)\n# [ ] 3. Convert prompt templates to OSSA role field\n# [ ] 4. Map LLM configuration (model, temperature, etc.)\n# [ ] 5. Define autonomy level (supervised vs autonomous)\n# [ ] 6. Add observability configuration (tracing, metrics, logging)\n# [ ] 7. Define constraints (cost limits, performance, resources)\n# [ ] 8. Validate manifest: ossa validate <manifest.yaml>\n# [ ] 9. Test agent behavior matches LangChain version\n# [ ] 10. Update deployment configuration\n# [ ] 11. Update documentation and runbooks\n#\n# ============================================================================\n# COMMON PATTERNS\n# ============================================================================\n#\n# LangChain Tool → OSSA Tool Type Mapping:\n#   - Python function → type: function\n#   - API endpoint → type: http\n#   - Database query → type: custom (with config)\n#   - File operations → type: function or mcp\n#\n# LangChain Agent Types → OSSA Role Patterns:\n#   - zero-shot-react-description → ReAct-style role with tool descriptions\n#   - conversational-react-description → Conversational role with memory\n#   - structured-chat → Structured role with schema validation\n#\n# ============================================================================\n# VALIDATION & TESTING\n# ============================================================================\n#\n# 1. Validate OSSA manifest:\n#    $ ossa validate examples/migration-guides/from-langchain-to-ossa.yaml\n#\n# 2. Compare behavior:\n#    - Run LangChain agent with test inputs\n#    - Run OSSA agent with same inputs\n#    - Compare outputs and behavior\n#\n# 3. Performance testing:\n#    - Measure latency differences\n#    - Compare resource usage\n#    - Validate cost constraints\n#\n# ============================================================================\n# NEXT STEPS\n# ============================================================================\n#\n# After migration:\n# 1. Deploy OSSA agent to your infrastructure\n# 2. Set up observability (tracing, metrics, logs)\n# 3. Configure cost and performance constraints\n# 4. Integrate with agent registry/discovery\n# 5. Document agent capabilities and usage\n#\n# See also:\n# - examples/migration-guides/from-anthropic-sdk-to-ossa.yaml\n# - examples/migration-guides/from-mcp-to-ossa.yaml\n# - examples/advanced/ for complex patterns\n#\n# ============================================================================\n\n",
    "category": "Migration Guides"
  },
  {
    "name": "agent.yml",
    "path": "minimal/agent.yml",
    "content": "# ========================================\n# Hello World - Minimal OSSA Agent Example\n# ========================================\n#\n# Use Case:\n#   Simplest possible OSSA agent to demonstrate core concepts\n#   and provide a starting template for beginners.\n#\n# Target Audience:\n#   Developers learning OSSA fundamentals, new agent creators,\n#   teams evaluating OSSA for their infrastructure.\n#\n# Complexity Level:\n#   Minimal - ~50 lines, covers essential fields only, no advanced features\n#\n# Key Concepts Demonstrated:\n#   1. Minimal required fields for OSSA compliance\n#   2. Basic capability definition (greeting, echo, status)\n#   3. Simple REST API endpoint mapping\n#   4. Service discovery configuration\n#\n# Related Examples:\n#   - See ../production/ for enterprise-grade examples\n#   - See ../advanced/ for complex multi-capability agents\n#   - See ../kagent/ for Kubernetes-integrated examples\n#\n# Learning Path:\n#   1. Start here to understand basic structure\n#   2. Move to ../production/ for best practices\n#   3. Explore ../advanced/ for custom configurations\n#\n# ========================================\n\n# OSSA specification version (required)\n# This declares which version of the OSSA spec this manifest adheres to\n# Current stable version: 1.0\nossa: 1.0\n\n# Agent metadata section (required)\nagent:\n  # Unique identifier for this agent across all deployments\n  # Format: lowercase alphanumeric + hyphens (DNS-safe)\n  # Example: \"hello-world\", \"user-auth-agent\", \"data-processor-v2\"\n  name: hello-world\n\n  # Semantic version of the agent (major.minor.patch)\n  # Increment when creating breaking changes, features, or fixes\n  # Example: 1.0.0 → 1.0.1 (patch fix) → 1.1.0 (new feature) → 2.0.0 (breaking change)\n  version: 1.0.0\n\n  # Human-readable description displayed in registries and dashboards\n  # Keep to 1-2 sentences; detailed docs belong in README/wiki\n  description: Minimal OSSA-compliant agent example\n\n  # Author or organization name for attribution and support contact\n  # Can be team name, company, or individual contributor\n  author: OSSA Community\n\n  # Software license identifier (SPDX standard)\n  # Common: MIT, Apache-2.0, GPL-3.0, Proprietary\n  # See https://spdx.org/licenses/ for complete list\n  license: MIT\n\n# Service discovery configuration (required for production)\n# Controls how other services find and register this agent\ndiscover:\n  # Enable automatic service discovery\n  # true = agent automatically registers itself when deployed\n  # false = manual registration required via external registry\n  auto: true\n\n# Agent capabilities (required)\n# Lists logical functions/features this agent can perform\n# Each capability can be invoked through REST API endpoints\n# Format: list of capability names (lowercase, hyphen-separated)\ncapabilities:\n  # Simple greeting capability - generates personalized responses\n  - greeting\n\n  # Echo capability - reflects input back (useful for testing/debugging)\n  - echo\n\n  # Status capability - reports agent health and runtime information\n  - status\n\n# REST API endpoint definitions (required)\n# Maps HTTP methods + paths to agent capabilities\n# Enables external services to invoke agent functionality\napi:\n  # POST /greet endpoint\n  # HTTP Method: POST (creates/executes something)\n  # Path: /greet (relative to agent base URL)\n  POST /greet:\n    # Which capability this endpoint invokes\n    # Must match a name in the capabilities list above\n    capability: greeting\n\n    # Human-readable description for API documentation\n    # Displayed in OpenAPI/Swagger documentation\n    description: Generate a personalized greeting\n\n  # POST /echo endpoint\n  # Demonstrates request body processing capability\n  POST /echo:\n    # Routes to echo capability defined above\n    capability: echo\n\n    # Documents expected behavior in API docs\n    description: Echo input back to user\n\n  # GET /status endpoint\n  # HTTP Method: GET (retrieves information without side effects)\n  # Used for health checks, monitoring, and readiness probes\n  GET /status:\n    # Links to status capability for runtime inspection\n    capability: status\n\n    # Documents the purpose of status endpoint\n    description: Get agent status\n\n# ========================================\n# Validation & Next Steps\n# ========================================\n#\n# To validate this manifest:\n#\n#   ossa validate ./agent.yml\n#\n# To validate with strict OSSA 1.0 compliance:\n#\n#   ossa validate ./agent.yml --version 1.0 --strict\n#\n# To create a new agent from this template:\n#\n#   ossa init my-agent --template minimal\n#   # Then customize agent.yml with your values\n#\n# To run this agent locally:\n#\n#   ossa run ./agent.yml --port 3000\n#   # Then test endpoints:\n#   curl -X POST http://localhost:3000/greet -H \"Content-Type: application/json\" -d '{\"name\":\"World\"}'\n#   curl -X GET http://localhost:3000/status\n#\n# Key Next Steps:\n#   1. Customize name, description, author for your use case\n#   2. Define actual implementation for each capability\n#   3. Add request/response schemas for type safety\n#   4. Add authentication/authorization if needed (see ../production/)\n#   5. Push to registry: ossa publish ./agent.yml\n#\n# ========================================\n",
    "category": "Getting Started"
  },
  {
    "name": "openapi.yaml",
    "path": "minimal/openapi.yaml",
    "content": "openapi: 3.1.0\ninfo:\n  title: Hello World Agent\n  version: 1.0.0\n  description: Minimal OSSA-compliant agent API\n\nservers:\n  - url: http://localhost:3000\n    description: Local development server\n\npaths:\n  /greet:\n    post:\n      summary: Generate greeting\n      operationId: greet\n      tags: [greeting]\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [name]\n              properties:\n                name:\n                  type: string\n                  description: Name to greet\n                language:\n                  type: string\n                  enum: [en, es, fr, de]\n                  default: en\n      responses:\n        '200':\n          description: Greeting generated successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  message:\n                    type: string\n                  timestamp:\n                    type: string\n                    format: date-time\n\n  /echo:\n    post:\n      summary: Echo input\n      operationId: echo\n      tags: [echo]\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required: [message]\n              properties:\n                message:\n                  type: string\n      responses:\n        '200':\n          description: Message echoed\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  echo:\n                    type: string\n                  received_at:\n                    type: string\n                    format: date-time\n\n  /status:\n    get:\n      summary: Get agent status\n      operationId: getStatus\n      tags: [status]\n      responses:\n        '200':\n          description: Agent status\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    enum: [online, offline, maintenance]\n                  version:\n                    type: string\n                  uptime:\n                    type: integer\n                    description: Uptime in seconds\n",
    "category": "Getting Started"
  },
  {
    "name": "swarm-agent.ossa.json",
    "path": "openai/swarm-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"swarm-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"OpenAI Agents SDK swarm agent\"\n  },\n  \"spec\": {\n    \"role\": \"You are a helpful AI assistant that can coordinate with other agents to solve complex tasks.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4o\",\n      \"temperature\": 0.7\n    },\n    \"tools\": [\n      {\n        \"type\": \"function\",\n        \"name\": \"search_web\",\n        \"capabilities\": [\"search\", \"retrieve\"]\n      },\n      {\n        \"type\": \"function\",\n        \"name\": \"execute_code\",\n        \"capabilities\": [\"run\", \"evaluate\"]\n      }\n    ]\n  },\n  \"extensions\": {\n    \"openai_agents\": {\n      \"enabled\": true,\n      \"model\": \"gpt-4o\",\n      \"instructions\": \"You are a helpful AI assistant that can coordinate with other agents to solve complex tasks.\",\n      \"tools_mapping\": [\n        {\n          \"ossa_capability\": \"search_web\",\n          \"openai_tool_name\": \"web_search\",\n          \"description\": \"Search the web for information\"\n        },\n        {\n          \"ossa_capability\": \"execute_code\",\n          \"openai_tool_name\": \"code_executor\",\n          \"description\": \"Execute Python code safely\"\n        }\n      ],\n      \"guardrails\": {\n        \"enabled\": true,\n        \"max_tool_calls\": 10,\n        \"timeout_seconds\": 300\n      },\n      \"memory\": {\n        \"enabled\": true,\n        \"type\": \"session\",\n        \"max_messages\": 50\n      }\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  },
  {
    "name": "minimal-agent-api.openapi.yml",
    "path": "openapi-extensions/minimal-agent-api.openapi.yml",
    "content": "# ============================================================================\n# OSSA OpenAPI Extensions Example: Minimal Agent API\n# ============================================================================\n#\n# PURPOSE:\n#   Demonstrates the minimal OpenAPI 3.1 specification with OSSA extensions\n#   for defining agent APIs. Shows how to add OSSA metadata to standard\n#   OpenAPI specs for agent discovery, validation, and lifecycle management.\n#\n# KEY CONCEPTS:\n#   - OpenAPI 3.1 as the base specification (JSON Schema compatible)\n#   - OSSA extensions via x-ossa-* fields (vendor extensions)\n#   - Agent capabilities mapped to OpenAPI operations\n#   - Type-safe contracts with JSON Schema validation\n#   - LLM configuration at the operation level\n#\n# ARCHITECTURE:\n#   OpenAPI 3.1 Spec\n#     + x-ossa-metadata (document-level OSSA info)\n#     + x-ossa (agent configuration)\n#     + x-ossa-capability (operation-level capability metadata)\n#     + x-ossa-autonomy (operation-level autonomy controls)\n#     + x-ossa-llm (operation-level LLM configuration)\n#     → OSSA-compliant Agent API\n#\n# USE CASE:\n#   Simple greeting agent that generates personalized greetings in multiple\n#   languages using GPT-3.5-turbo. Demonstrates OSSA's OpenAPI-first approach.\n#\n# RELATED DOCUMENTATION:\n#   - OSSA OpenAPI Extensions: spec/OSSA_OpenAPI_Extensions.md\n#   - OpenAPI 3.1 Spec: https://spec.openapis.org/oas/v3.1.0\n#   - Worker Agent Example: examples/openapi-extensions/worker-agent-api.openapi.yml\n# ============================================================================\n\nopenapi: 3.1.0\n\n# ============================================================================\n# API Information Block (Standard OpenAPI)\n# ============================================================================\ninfo:\n  title: Hello World Agent API\n  version: 1.0.0\n  description: |\n    Minimal OSSA-compliant agent API demonstrating basic OpenAPI extensions.\n    This example shows a simple greeting agent with OSSA metadata.\n\n# ============================================================================\n# OSSA Metadata Extension (Document-Level)\n# ============================================================================\n# x-ossa-metadata provides OSSA-specific information about the API document.\n# This is separate from the agent configuration (x-ossa) to allow for\n# governance, compliance, and operational metadata.\n# ============================================================================\nx-ossa-metadata:\n  # OSSA specification version this document conforms to\n  version: 0.2.2\n\n  # Compliance information for governance and audit\n  compliance:\n    level: basic              # basic, intermediate, advanced, enterprise\n    frameworks:\n      - OSSA                  # Open Standard for System Agents\n      - OpenAPI 3.1           # Base specification\n\n# ============================================================================\n# OSSA Agent Configuration Extension\n# ============================================================================\n# x-ossa defines the agent's identity, type, and compliance status.\n# This metadata enables agent registries, discovery, and validation tools.\n# ============================================================================\nx-ossa:\n  # OSSA version (should match x-ossa-metadata.version)\n  version: 0.2.2\n\n  # Agent identity and type\n  agent:\n    # Unique agent identifier (DNS-compatible)\n    id: hello-world-agent\n\n    # Agent type determines execution model:\n    # - \"worker\": Task-based, stateless execution\n    # - \"chat\": Interactive, stateful conversation\n    # - \"orchestrator\": Coordinates other agents\n    # - \"integration\": Long-running service connector\n    type: worker\n\n    # Compliance tracking for validation pipelines\n    compliance:\n      # Standards this agent implementation adheres to\n      standards:\n        - openapi-first       # API-first design approach\n\n      # Validation status (set by OSSA validators)\n      validated: true\n      validatedAt: \"2024-01-15T10:00:00Z\"  # ISO 8601 timestamp\n\n# ============================================================================\n# API Paths (Standard OpenAPI with OSSA Extensions)\n# ============================================================================\npaths:\n  # ==========================================================================\n  # /greet - Generate Personalized Greeting\n  # ==========================================================================\n  # Demonstrates OSSA capability mapping to OpenAPI operation.\n  # Each operation represents one agent capability with:\n  # - Standard OpenAPI request/response schemas\n  # - OSSA capability metadata (x-ossa-capability)\n  # - Autonomy controls (x-ossa-autonomy)\n  # - LLM configuration (x-ossa-llm)\n  # ==========================================================================\n  /greet:\n    post:\n      # Standard OpenAPI operation metadata\n      summary: Generate greeting\n      description: Generates a personalized greeting using LLM\n\n      # Unique operation identifier (used for code generation)\n      operationId: greet\n\n      # Tags for grouping operations in documentation\n      tags:\n        - Greeting\n\n      # ======================================================================\n      # OSSA Capability Extension\n      # ======================================================================\n      # Maps this OpenAPI operation to an OSSA agent capability.\n      # Capability name must match agent manifest capability IDs.\n      # ======================================================================\n      x-ossa-capability: greeting\n\n      # ======================================================================\n      # OSSA Autonomy Extension\n      # ======================================================================\n      # Defines autonomy level and approval requirements for this operation.\n      # Controls how much freedom the agent has when executing this capability.\n      # ======================================================================\n      x-ossa-autonomy:\n        # Autonomy levels:\n        # - \"autonomous\": Agent can execute without human approval\n        # - \"supervised\": Human must approve before execution\n        # - \"collaborative\": Human and agent work together\n        level: autonomous\n\n        # Whether approval is required (overrides level if true)\n        approval_required: false\n\n      # ======================================================================\n      # OSSA LLM Extension\n      # ======================================================================\n      # Specifies which LLM to use for this specific operation.\n      # Allows per-operation model selection for cost/performance optimization.\n      # ======================================================================\n      x-ossa-llm:\n        provider: openai             # LLM provider (openai, anthropic, etc.)\n        model: gpt-3.5-turbo         # Model identifier (fast, low-cost)\n        temperature: 0.7             # Creativity level (0.0-1.0)\n\n      # Standard OpenAPI request body definition\n      requestBody:\n        required: true\n        content:\n          # JSON content type (most common for agent APIs)\n          application/json:\n            # JSON Schema for request validation\n            schema:\n              type: object\n\n              # Required fields (validated before execution)\n              required:\n                - name\n\n              properties:\n                # Person's name to include in greeting\n                name:\n                  type: string\n                  description: Name to greet\n                  example: \"Alice\"\n\n                # Target language for greeting (enum constraint)\n                language:\n                  type: string\n                  enum:\n                    - en    # English\n                    - es    # Spanish\n                    - fr    # French\n                    - de    # German\n                  default: en\n                  description: Language for greeting\n\n      # Response definitions (standard OpenAPI)\n      responses:\n        # Success response (200 OK)\n        '200':\n          description: Greeting generated successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  # Generated greeting text\n                  message:\n                    type: string\n                    description: The greeting message\n                    example: \"Hello, Alice! Welcome to OSSA.\"\n\n                  # Timestamp for audit trail\n                  timestamp:\n                    type: string\n                    format: date-time\n                    description: When the greeting was generated\n\n  # ==========================================================================\n  # /status - Agent Health Check\n  # ==========================================================================\n  # Standard health check endpoint for monitoring and orchestration.\n  # Does not use LLM, so no x-ossa-llm extension needed.\n  # ==========================================================================\n  /status:\n    get:\n      summary: Get agent status\n      description: Returns the current status of the agent\n      operationId: getStatus\n\n      tags:\n        - Status\n\n      responses:\n        '200':\n          description: Agent status\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  # Current operational status\n                  status:\n                    type: string\n                    enum:\n                      - online        # Agent is operational\n                      - offline       # Agent is not responding\n                      - maintenance   # Agent is in maintenance mode\n                    description: Current agent status\n\n                  # Agent version for deployment tracking\n                  version:\n                    type: string\n                    description: Agent version\n\n                  # Uptime metric for monitoring\n                  uptime:\n                    type: integer\n                    description: Uptime in seconds\n\n# ============================================================================\n# End of Minimal OSSA OpenAPI Example\n# ============================================================================\n#\n# VALIDATION:\n#   # Validate OpenAPI spec\n#   swagger-cli validate minimal-agent-api.openapi.yml\n#\n#   # Validate OSSA extensions\n#   ossa validate minimal-agent-api.openapi.yml\n#\n# CODE GENERATION:\n#   # Generate server stub\n#   openapi-generator generate -i minimal-agent-api.openapi.yml \\\n#     -g python-flask -o ./server\n#\n#   # Generate client SDK\n#   openapi-generator generate -i minimal-agent-api.openapi.yml \\\n#     -g typescript-axios -o ./client\n#\n# KEY TAKEAWAYS:\n#   1. OSSA extends OpenAPI 3.1 with x-ossa-* vendor extensions\n#   2. Standard OpenAPI tooling still works (validators, generators, docs)\n#   3. OSSA extensions add agent-specific metadata (capabilities, autonomy, LLM)\n#   4. One OpenAPI operation = One agent capability\n#   5. Type-safe contracts with JSON Schema validation\n#\n# RELATED EXAMPLES:\n#   - examples/openapi-extensions/worker-agent-api.openapi.yml (full features)\n#   - examples/drupal/gitlab-ml-recommender.ossa.yaml (YAML manifest format)\n#   - spec/OSSA_OpenAPI_Extensions.md (complete specification)\n# ============================================================================\n\n",
    "category": "OpenAPI Extensions"
  },
  {
    "name": "orchestrator-agent-api.openapi.yml",
    "path": "openapi-extensions/orchestrator-agent-api.openapi.yml",
    "content": "# ============================================================================\n# OSSA Multi-Agent Orchestrator OpenAPI Specification\n# ============================================================================\n# Purpose: REST API definition for orchestrator agent with OSSA extensions\n#\n# Key Concepts:\n# - OpenAPI-First Design: API specification drives implementation\n# - OSSA Extensions: x-ossa-* fields add agent-specific metadata\n# - Multi-Agent Coordination: Delegate workflow steps to specialized agents\n# - Workflow Orchestration: Manage complex multi-step processes\n#\n# OSSA Extensions Used:\n# - x-ossa-metadata: Top-level compliance and governance metadata\n# - x-ossa: Agent identity and compliance standards\n# - x-agent: Agent-specific capabilities, tools, and rules\n# - x-ossa-capability: Endpoint-level capability mapping\n# - x-ossa-autonomy: Approval requirements and allowed actions\n# - x-ossa-constraints: Cost, performance, and time limits\n# - x-ossa-tools: MCP server integrations for agent coordination\n# - x-ossa-llm: LLM configuration for intelligent orchestration\n#\n# Related Examples:\n# - examples/agent-manifests/orchestrators/orchestrator-agent.yaml (OSSA manifest)\n# - examples/production/agent.yml (Worker agent pattern)\n# - examples/openapi-extensions/worker-agent-api.openapi.yml (Worker API)\n#\n# Integration Pattern:\n# 1. Orchestrator receives workflow request\n# 2. Uses agent-router to discover capable worker agents\n# 3. Delegates workflow steps to appropriate workers\n# 4. Aggregates results and returns unified response\n# ============================================================================\n\nopenapi: 3.1.0\n\n# ============================================================================\n# API METADATA: Basic information about this API\n# ============================================================================\ninfo:\n  title: Multi-Agent Orchestrator API\n  version: 1.0.0\n  description: |\n    Orchestrator agent that coordinates multiple worker agents to complete complex workflows.\n    Demonstrates advanced OSSA extensions for multi-agent coordination.\n\n    Features:\n    - Dynamic agent discovery and routing\n    - Parallel and sequential workflow execution\n    - Automatic retry and compensation handling\n    - Real-time workflow status tracking\n    - Cost and performance constraints enforcement\n\n    Architecture:\n    - Orchestrator coordinates worker agents via agent-router\n    - Worker agents registered in agent-mesh\n    - Workflow state tracked in workflow-engine\n    - All communication over secure, authenticated channels\n\n# ============================================================================\n# x-ossa-metadata: Top-level OSSA compliance and governance metadata\n# ============================================================================\n# This extension provides organizational governance information and\n# compliance requirements that apply to the entire API\nx-ossa-metadata:\n  # OSSA specification version this API conforms to\n  version: 0.2.2\n\n  # Compliance level and frameworks this API adheres to\n  compliance:\n    # enterprise: Full compliance with all OSSA enterprise requirements\n    # - Comprehensive security, monitoring, and governance\n    # - Production-ready with SLAs and support\n    level: enterprise\n\n    # Frameworks this API complies with\n    frameworks:\n      - OSSA               # OSSA agent specification\n      - OpenAPI 3.1        # OpenAPI 3.1.0 specification\n      - RFC7807            # Problem Details for HTTP APIs\n\n  # Governance: Approval and authorization metadata\n  governance:\n    # Whether this API has been approved for production use\n    approved: true\n\n    # Team or individual who approved this API\n    approvedBy: Platform Team\n\n    # Date of approval (ISO 8601 format)\n    approvalDate: \"2024-01-15\"\n\n  # Security: Classification and requirements\n  security:\n    # Data classification level (public/internal/confidential/secret)\n    # - internal: Company-internal use only, no external access\n    classification: internal\n\n    # Authentication required for all endpoints\n    authentication: required\n\n    # TLS 1.3 required for all connections\n    encryption: tls1.3\n\n  # Observability: Monitoring and tracing configuration\n  observability:\n    # Enable distributed tracing (OpenTelemetry)\n    tracing: true\n\n    # Enable metrics collection (Prometheus)\n    metrics: true\n\n    # Enable structured logging (JSON format)\n    logging: true\n\n# ============================================================================\n# x-ossa: Agent identity and OSSA-specific configuration\n# ============================================================================\n# This extension identifies the agent and its OSSA compliance status\nx-ossa:\n  # OSSA specification version\n  version: 0.2.2\n\n  # Agent identity and type\n  agent:\n    # Unique identifier for this agent (must match manifest)\n    id: workflow-orchestrator\n\n    # Agent type determines its role in the ecosystem\n    # - orchestrator: Coordinates other agents\n    # - worker: Performs delegated tasks\n    # - specialist: Domain-specific expertise\n    type: orchestrator\n\n    # Compliance standards this agent follows\n    compliance:\n      standards:\n        - openapi-first  # API specification drives implementation\n        - dry           # Don't Repeat Yourself - reusable components\n        - crud          # Consistent Create, Read, Update, Delete patterns\n        - solid         # SOLID design principles (OOP best practices)\n        - type-safe     # Strong typing in requests/responses\n\n      # Whether this agent has been validated against OSSA spec\n      validated: true\n\n      # Timestamp of last validation (ISO 8601 format)\n      validatedAt: \"2024-01-15T10:30:00Z\"\n\n# ============================================================================\n# x-agent: Agent-specific capabilities, tools, and operational rules\n# ============================================================================\n# This extension defines what the agent can do and how it operates\nx-agent:\n  # Capabilities: High-level functions this agent provides\n  capabilities:\n    - workflow-execution    # Execute multi-step workflows\n    - agent-coordination    # Discover and manage worker agents\n    - task-delegation      # Delegate workflow steps to workers\n    - result-aggregation   # Combine results from multiple agents\n\n  # Tools: External systems this agent integrates with (MCP servers)\n  tools:\n    - agent-router      # Service discovery and routing for agents\n    - agent-mesh        # Agent communication and coordination\n    - workflow-engine   # Workflow state management and execution\n\n  # Environment: Runtime configuration and limits\n  environment:\n    # Maximum worker agents that can be coordinated simultaneously\n    # - Prevents resource exhaustion and coordination overhead\n    maxConcurrentAgents: 10\n\n    # Default timeout (seconds) for workflow execution\n    # - Individual steps may have their own timeouts\n    defaultTimeout: 300\n\n  # Rules: Operational policies this agent must follow\n  rules:\n    # Validate all task delegations before sending to workers\n    # - Ensures workers have required capabilities\n    # - Prevents invalid requests and wasted resources\n    - validate-all-delegations\n\n    # Critical workflows require human approval before execution\n    # - Workflows marked priority: critical\n    # - Prevents automated execution of high-risk operations\n    - require-approval-for-critical-workflows\n\n    # Audit all coordination activities for compliance\n    # - Log all agent discoveries, delegations, and results\n    # - Enables troubleshooting and compliance reporting\n    - audit-all-coordinations\n\n# ============================================================================\n# COMPONENTS: Reusable schemas, parameters, and responses\n# ============================================================================\ncomponents:\n  schemas:\n    # ========================================================================\n    # WorkflowRequest: Client submits workflow to orchestrator\n    # ========================================================================\n    WorkflowRequest:\n      type: object\n      required:\n        - workflowId    # Required for idempotency and status tracking\n        - steps         # At least one step must be defined\n      properties:\n        # Unique workflow identifier for tracking and idempotency\n        # - Client generates UUID to prevent duplicate submissions\n        # - Used to query workflow status via GET /workflows/{workflowId}\n        workflowId:\n          type: string\n          description: Unique workflow identifier\n\n        # Array of workflow steps to execute\n        # - Steps can be executed sequentially or in parallel\n        # - Orchestrator determines execution order based on dependencies\n        steps:\n          type: array\n          items:\n            type: object\n            properties:\n              # Unique step identifier within this workflow\n              # - Used for dependency tracking (e.g., step2 depends on step1)\n              stepId:\n                type: string\n\n              # Type of agent required for this step\n              # - worker: General-purpose task execution\n              # - specialist: Domain-specific expertise (e.g., code review, security)\n              # - critic: Validation and quality assurance\n              agentType:\n                type: string\n                enum:\n                  - worker\n                  - specialist\n                  - critic\n\n              # Required capability for this step\n              # - Used by agent-router to find suitable agents\n              # - Example: \"sentiment_analysis\", \"code_review\", \"vulnerability_scan\"\n              capability:\n                type: string\n\n              # Input data for this workflow step\n              # - Passed to the worker agent's capability function\n              # - Schema validated by worker agent\n              # - Can reference outputs from previous steps\n              input:\n                type: object\n                additionalProperties: true\n\n        # Workflow priority affects scheduling and resource allocation\n        # - critical: Requires approval, highest priority, dedicated resources\n        # - high: Fast-tracked execution, priority over normal/low\n        # - normal: Standard execution (default)\n        # - low: Best-effort execution, can be preempted\n        priority:\n          type: string\n          enum:\n            - low\n            - normal\n            - high\n            - critical\n          default: normal\n\n    # ========================================================================\n    # WorkflowResponse: Orchestrator returns workflow status and results\n    # ========================================================================\n    WorkflowResponse:\n      type: object\n      properties:\n        # Workflow identifier from request (for correlation)\n        workflowId:\n          type: string\n\n        # Overall workflow status\n        # - pending: Workflow accepted but not yet started\n        # - running: At least one step is executing\n        # - completed: All steps completed successfully\n        # - failed: At least one step failed (check steps for details)\n        status:\n          type: string\n          enum:\n            - pending\n            - running\n            - completed\n            - failed\n\n        # Status and results for each workflow step\n        steps:\n          type: array\n          items:\n            type: object\n            properties:\n              # Step identifier from request\n              stepId:\n                type: string\n\n              # Step execution status\n              # - Same values as workflow status\n              # - Individual step status drives overall workflow status\n              status:\n                type: string\n\n              # ID of the agent that executed this step\n              # - Used for debugging and performance analysis\n              # - Retrieved from agent-router based on capability\n              agentId:\n                type: string\n\n              # Output from worker agent's capability function\n              # - Schema defined by worker agent\n              # - Can be used as input to subsequent steps\n              result:\n                type: object\n                additionalProperties: true\n\n        # Combined results from all workflow steps\n        # - Orchestrator aggregates individual step results\n        # - Structure depends on workflow type and logic\n        # - Example: Combined sentiment scores, merged analysis reports\n        aggregatedResult:\n          type: object\n          additionalProperties: true\n\n# ============================================================================\n# PATHS: API endpoints for workflow orchestration\n# ============================================================================\npaths:\n  # ==========================================================================\n  # POST /api/v1/workflows/execute: Submit workflow for execution\n  # ==========================================================================\n  /api/v1/workflows/execute:\n    post:\n      summary: Execute multi-agent workflow\n      description: |\n        Coordinates multiple agents to execute a complex workflow.\n        Each step can be delegated to different agents based on their capabilities.\n\n        Workflow Execution Process:\n        1. Orchestrator validates workflow request\n        2. Uses agent-router to discover agents with required capabilities\n        3. Delegates workflow steps to worker agents (parallel or sequential)\n        4. Monitors execution and handles failures (retry/compensation)\n        5. Aggregates results from all steps\n        6. Returns unified response\n\n        Agent Discovery:\n        - Agent-router queries agent-mesh for agents with matching capabilities\n        - Health checks ensure only healthy agents receive tasks\n        - Load balancing distributes work across available agents\n\n        Failure Handling:\n        - Retry with exponential backoff (up to 3 attempts)\n        - Compensation actions for saga pattern\n        - Fallback workflows for critical operations\n      operationId: executeWorkflow\n      tags:\n        - Orchestration\n\n      # ======================================================================\n      # x-ossa-capability: Maps endpoint to agent capability\n      # ======================================================================\n      # Enables capability-based routing and authorization\n      x-ossa-capability:\n        name: workflow-execution\n        description: Execute multi-agent workflow with task delegation\n\n      # ======================================================================\n      # x-ossa-autonomy: Defines autonomy level and action permissions\n      # ======================================================================\n      # Controls what the agent can do without human approval\n      x-ossa-autonomy:\n        # Autonomy levels:\n        # - autonomous: Full self-direction, no approval needed\n        # - semi-autonomous: Can execute but not modify system (this level)\n        # - supervised: Human approval required for all actions\n        level: semi-autonomous\n\n        # Approval required before execution (false for normal priority)\n        # - Set to true for critical priority workflows (via rules)\n        approval_required: false\n\n        # Actions this endpoint is permitted to perform\n        allowed_actions:\n          - delegate_tasks       # Send tasks to worker agents\n          - aggregate_results    # Combine outputs from multiple agents\n          - coordinate_agents    # Discover and communicate with agents\n\n        # Actions explicitly blocked for safety\n        blocked_actions:\n          - modify_agent_configs  # Cannot change agent configurations\n          - delete_agents        # Cannot remove agents from system\n\n      # ======================================================================\n      # x-ossa-constraints: Resource and performance limits\n      # ======================================================================\n      # Enforces cost, performance, and time budgets\n      x-ossa-constraints:\n        # Cost constraints: Prevent runaway token/cost usage\n        cost:\n          # Maximum tokens per 24-hour period (all workflows)\n          maxTokensPerDay: 200000\n\n          # Maximum tokens per single workflow execution\n          maxTokensPerRequest: 10000\n\n          # Maximum dollar cost per 24-hour period\n          maxCostPerDay: 50.0\n\n          # Currency for cost calculations\n          currency: USD\n\n        # Performance constraints: Ensure responsiveness\n        performance:\n          # Maximum end-to-end latency (seconds) before timeout\n          # - 600 seconds = 10 minutes (should include retries)\n          maxLatencySeconds: 600\n\n          # Maximum concurrent workflow executions\n          # - Limits orchestrator load and agent contention\n          maxConcurrentRequests: 3\n\n        # Time constraints: Prevent long-running workflows\n        time:\n          # Maximum execution time (seconds) per workflow\n          # - 1800 seconds = 30 minutes\n          # - Includes all steps, retries, and compensation\n          maxExecutionTime: 1800\n\n      # ======================================================================\n      # x-ossa-tools: MCP servers for agent coordination\n      # ======================================================================\n      # Defines external tools (MCP servers) this endpoint uses\n      x-ossa-tools:\n        # Agent Router: Service discovery and request routing\n        - type: mcp\n          server: agent-router\n          capabilities:\n            # Find agents matching capability requirements\n            - find_agent\n            # Route requests to selected agents\n            - route_request\n\n        # Agent Mesh: Agent communication and coordination\n        - type: mcp\n          server: agent-mesh\n          capabilities:\n            # Coordinate multiple agents in a workflow\n            - coordinate_agents\n            # Send messages to all agents (e.g., cancel workflow)\n            - broadcast_message\n\n        # Workflow Engine: Workflow state management\n        - type: mcp\n          server: workflow-engine\n          capabilities:\n            # Execute workflow definition (steps, dependencies, retries)\n            - execute_workflow\n            # Track workflow progress and state transitions\n            - track_progress\n\n      # ======================================================================\n      # x-ossa-llm: LLM configuration for intelligent orchestration\n      # ======================================================================\n      # LLM used for intelligent workflow decisions (optional)\n      # - Determines step execution order based on dependencies\n      # - Selects best agent when multiple candidates available\n      # - Generates compensation logic for failed steps\n      x-ossa-llm:\n        # LLM provider (openai, anthropic, azure, etc.)\n        provider: openai\n\n        # Model for orchestration decisions\n        # - GPT-4 for complex reasoning about dependencies and failures\n        model: gpt-4\n\n        # Low temperature for deterministic orchestration\n        # - Prevents random variations in workflow execution\n        temperature: 0.1\n\n        # Maximum tokens for LLM responses\n        # - Orchestration decisions should be concise\n        maxTokens: 8000\n\n      # ======================================================================\n      # Request/Response Definitions\n      # ======================================================================\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/WorkflowRequest\"\n\n      responses:\n        # 202 Accepted: Workflow accepted and execution started\n        # - Asynchronous execution (use GET /workflows/{id} for status)\n        '202':\n          description: Workflow execution started\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/WorkflowResponse\"\n\n        # 400 Bad Request: Invalid workflow specification\n        # - Missing required fields\n        # - Invalid step definitions\n        # - Unknown agent types or capabilities\n        '400':\n          description: Invalid workflow request\n\n        # 403 Forbidden: Workflow requires approval\n        # - Priority is \"critical\" and requires human approval\n        # - Blocked by operational rules\n        '403':\n          description: Workflow requires approval\n\n  # ==========================================================================\n  # GET /api/v1/workflows/{workflowId}: Query workflow status\n  # ==========================================================================\n  /api/v1/workflows/{workflowId}:\n    get:\n      summary: Get workflow status\n      description: |\n        Retrieve the current status of a workflow execution.\n\n        Use Cases:\n        - Poll for workflow completion after POST /workflows/execute\n        - Monitor workflow progress in real-time\n        - Retrieve results after workflow completion\n        - Debug failed workflows (view step-by-step status)\n\n        Response Details:\n        - Status: pending/running/completed/failed\n        - Steps: Individual step status and results\n        - AggregatedResult: Combined output from all steps\n      operationId: getWorkflowStatus\n      tags:\n        - Orchestration\n\n      # ======================================================================\n      # x-ossa-capability: Maps endpoint to agent capability\n      # ======================================================================\n      x-ossa-capability:\n        name: workflow-execution\n        description: Query workflow execution status\n\n      # ======================================================================\n      # x-ossa-autonomy: Fully autonomous read-only operation\n      # ======================================================================\n      # Read-only operations are typically autonomous (no approval needed)\n      x-ossa-autonomy:\n        # autonomous: No approval needed for read operations\n        level: autonomous\n\n        # No approval required for status queries\n        approval_required: false\n\n      # ======================================================================\n      # Request Parameters\n      # ======================================================================\n      parameters:\n        # Workflow ID from POST /workflows/execute response\n        - name: workflowId\n          in: path\n          required: true\n          schema:\n            type: string\n          description: Unique workflow identifier from submission\n\n      # ======================================================================\n      # Response Definitions\n      # ======================================================================\n      responses:\n        # 200 OK: Workflow found and status returned\n        '200':\n          description: Workflow status\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/WorkflowResponse\"\n\n        # 404 Not Found: Workflow ID does not exist\n        # - Workflow never submitted\n        # - Workflow ID expired (retention policy)\n        # - Typo in workflow ID\n        '404':\n          description: Workflow not found\n\n# ============================================================================\n# END OF SPECIFICATION\n# ============================================================================\n# Usage Examples:\n#\n# 1. Submit workflow:\n#    POST /api/v1/workflows/execute\n#    {\n#      \"workflowId\": \"wf-123\",\n#      \"steps\": [\n#        {\n#          \"stepId\": \"step1\",\n#          \"agentType\": \"worker\",\n#          \"capability\": \"sentiment_analysis\",\n#          \"input\": {\"text\": \"This is great!\"}\n#        }\n#      ],\n#      \"priority\": \"normal\"\n#    }\n#\n# 2. Check status:\n#    GET /api/v1/workflows/wf-123\n#\n# 3. Monitor until completed:\n#    while (status === \"pending\" || status === \"running\") {\n#      await sleep(1000);\n#      status = await GET /api/v1/workflows/wf-123;\n#    }\n#\n# Related Documentation:\n# - OSSA Spec: https://ossa.ai/spec\n# - OpenAPI Extensions: https://ossa.ai/docs/openapi-extensions\n# - Agent Coordination: https://ossa.ai/docs/orchestration\n# - MCP Integration: https://modelcontextprotocol.io\n#\n# Agent Ecosystem:\n# - This orchestrator coordinates worker agents\n# - Worker agents register capabilities in agent-mesh\n# - Agent-router discovers and routes to workers\n# - Workflow-engine manages state and retries\n# ============================================================================\n\n",
    "category": "OpenAPI Extensions"
  },
  {
    "name": "worker-agent-api.openapi.yml",
    "path": "openapi-extensions/worker-agent-api.openapi.yml",
    "content": "# ============================================================================\n# OSSA OpenAPI Extensions Example: Full-Featured Worker Agent\n# ============================================================================\n#\n# PURPOSE:\n#   Demonstrates the complete set of OSSA OpenAPI extensions for enterprise\n#   agent APIs. This is a production-ready example showing Kubernetes pod\n#   diagnostics with comprehensive governance, security, and observability.\n#\n# KEY FEATURES:\n#   - Enterprise compliance tracking (SOC2, governance approval)\n#   - Security metadata (authentication, encryption, classification)\n#   - Advanced autonomy controls (allowed/blocked actions)\n#   - Cost and performance constraints\n#   - MCP tool integration (Kubernetes MCP server)\n#   - Reusable components (parameters, schemas)\n#   - Error responses (RFC 7807 Problem Details)\n#\n# ARCHITECTURE:\n#   OpenAPI 3.1 Spec\n#     + x-ossa-metadata (enterprise governance)\n#     + x-ossa (agent configuration)\n#     + x-agent (deprecated, for backward compatibility)\n#     + x-ossa-capability (capability metadata with schemas)\n#     + x-ossa-autonomy (supervised mode with action controls)\n#     + x-ossa-constraints (cost, performance, time limits)\n#     + x-ossa-tools (MCP server integrations)\n#     + components/parameters (reusable OSSA headers)\n#     + components/schemas (capability input/output schemas)\n#     → Enterprise-Grade OSSA Agent API\n#\n# USE CASE:\n#   Kubernetes SRE agent that diagnoses pod failures by:\n#   1. Querying pod status via Kubernetes MCP tools\n#   2. Analyzing logs and events with LLM reasoning\n#   3. Correlating metrics for root cause analysis\n#   4. Generating actionable recommendations with evidence\n#\n# RELATED DOCUMENTATION:\n#   - OSSA OpenAPI Extensions: spec/OSSA_OpenAPI_Extensions.md\n#   - MCP Tools: https://modelcontextprotocol.io\n#   - RFC 7807 Problem Details: https://tools.ietf.org/html/rfc7807\n#   - Kubernetes Troubleshooting: https://kubernetes.io/docs/tasks/debug/\n# ============================================================================\n\nopenapi: 3.1.0\n\n# ============================================================================\n# API Information (Standard OpenAPI)\n# ============================================================================\ninfo:\n  title: Kubernetes Troubleshooter Agent API\n  version: 1.0.0\n  description: |\n    Full-featured worker agent API demonstrating all OSSA OpenAPI extensions.\n    This agent diagnoses Kubernetes pod failures and issues.\n\n# ============================================================================\n# OSSA Metadata Extension (Enterprise-Grade)\n# ============================================================================\n# Comprehensive metadata for governance, security, and observability.\n# This example shows enterprise-level compliance tracking.\n# ============================================================================\nx-ossa-metadata:\n  # OSSA specification version\n  version: 0.2.2\n\n  # Compliance tracking for enterprise governance\n  compliance:\n    level: enterprise             # basic | intermediate | advanced | enterprise\n    frameworks:\n      - OSSA                      # Open Standard for System Agents\n      - OpenAPI 3.1               # Base specification\n      - RFC7807                   # Problem Details for HTTP APIs\n\n  # Governance approval tracking (required for enterprise deployments)\n  governance:\n    approved: true\n    approvedBy: Platform Team     # Approving authority\n    approvalDate: \"2024-01-15\"    # ISO 8601 date\n\n  # Security metadata for access control and encryption\n  security:\n    classification: internal      # public | internal | confidential | restricted\n    authentication: required      # Authentication enforcement\n    encryption: tls1.3            # Minimum TLS version\n\n  # Observability configuration for production monitoring\n  observability:\n    tracing: true                 # OpenTelemetry distributed tracing\n    metrics: true                 # Prometheus metrics\n    logging: true                 # Structured logging (JSON)\n\n# ============================================================================\n# OSSA Agent Configuration\n# ============================================================================\nx-ossa:\n  version: 0.2.2\n\n  agent:\n    # Agent identifier\n    id: k8s-troubleshooter\n\n    # Worker type: task-based, stateless execution\n    type: worker\n\n    # Compliance standards adherence\n    compliance:\n      standards:\n        - openapi-first           # API-first design\n        - dry                     # Don't Repeat Yourself\n        - crud                    # Create/Read/Update/Delete patterns\n        - solid                   # SOLID principles\n        - type-safe               # Strong typing with JSON Schema\n      validated: true\n      validatedAt: \"2024-01-15T10:30:00Z\"\n\n# ============================================================================\n# Legacy x-agent Extension (Deprecated)\n# ============================================================================\n# Included for backward compatibility with OSSA 0.1.x.\n# New implementations should use x-ossa instead.\n# ============================================================================\nx-agent:\n  # Legacy capability list (use x-ossa-capability on operations instead)\n  capabilities:\n    - pod-diagnostics\n    - log-analysis\n    - event-correlation\n\n  # Legacy tools list (use x-ossa-tools on operations instead)\n  tools:\n    - kubernetes-mcp\n    - buildkit-agent-protocol\n\n  # Agent-specific environment configuration\n  environment:\n    defaultNamespace: default     # Default Kubernetes namespace\n    logRetention: 7d              # Log retention period\n\n  # Legacy rules (use x-ossa-autonomy on operations instead)\n  rules:\n    - read-only-operations\n    - require-approval-for-writes\n\n# ============================================================================\n# Reusable Components (Standard OpenAPI)\n# ============================================================================\n# components section allows defining reusable parameters, schemas, responses,\n# etc. This promotes DRY and consistency across the API.\n# ============================================================================\ncomponents:\n  # ==========================================================================\n  # Reusable Parameters\n  # ==========================================================================\n  # OSSA-specific headers for agent identification and versioning.\n  # These can be referenced across multiple operations.\n  # ==========================================================================\n  parameters:\n    # OSSA Agent ID header (for multi-agent routing)\n    X-Ossa-Agent-Id:\n      name: X-OSSA-Agent-ID\n      in: header\n      description: Unique identifier of the agent making the request\n      required: false              # Optional for backward compatibility\n      schema:\n        type: string\n        # Kubernetes-style DNS label (RFC 1123)\n        pattern: \"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\"\n      example: k8s-troubleshooter\n\n    # OSSA Version header (for version negotiation)\n    X-Ossa-Version:\n      name: X-OSSA-Version\n      in: header\n      description: OSSA specification version the agent supports\n      required: false\n      schema:\n        type: string\n        # Semantic versioning pattern (semver.org)\n        pattern: \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+(-[a-zA-Z0-9]+)?$\"\n      example: \"0.2.2\"\n\n  # ==========================================================================\n  # Reusable Schemas\n  # ==========================================================================\n  # Define capability input/output schemas as components for reusability.\n  # These schemas are referenced by both x-ossa-capability and requestBody.\n  # ==========================================================================\n  schemas:\n    # Input schema for pod diagnostics capability\n    PodDiagnosticRequest:\n      type: object\n\n      # Required fields for pod identification\n      required:\n        - podName\n        - namespace\n\n      properties:\n        # Pod name (Kubernetes resource name)\n        podName:\n          type: string\n          description: Name of the pod to diagnose\n          example: \"my-app-7d4f6b8c9\"\n\n        # Kubernetes namespace\n        namespace:\n          type: string\n          description: Kubernetes namespace\n          example: \"production\"\n\n        # Optional flag to include logs (increases latency and cost)\n        includeLogs:\n          type: boolean\n          default: true\n          description: Whether to include pod logs in diagnosis\n\n      # ======================================================================\n      # OSSA Capability Schema Extension\n      # ======================================================================\n      # Links this schema to a specific capability and marks it as input.\n      # Enables validation and documentation generation.\n      # ======================================================================\n      x-ossa-capability-schema:\n        capabilityName: pod-diagnostics  # Must match capability name\n        input: true                      # This is an input schema\n        validation:\n          required: true                 # Validation is required\n          strict: true                   # Use strict validation (no extra fields)\n\n    # Output schema for pod diagnostics capability\n    PodDiagnosticResponse:\n      type: object\n\n      properties:\n        # Overall pod health status (determined by LLM analysis)\n        status:\n          type: string\n          enum:\n            - healthy      # Pod is running normally\n            - degraded     # Pod has non-critical issues\n            - failed       # Pod is not functioning\n          description: Overall pod health status\n\n        # List of identified issues (from log/event/metric analysis)\n        issues:\n          type: array\n          items:\n            type: object\n            properties:\n              # Issue severity level\n              severity:\n                type: string\n                enum:\n                  - critical    # Immediate action required\n                  - warning     # Attention needed\n                  - info        # Informational\n              # Human-readable issue description\n              message:\n                type: string\n              # Affected Kubernetes resource\n              resource:\n                type: string\n\n        # AI-generated recommendations (LLM reasoning over issues)\n        recommendations:\n          type: array\n          items:\n            type: string\n          description: Recommended actions to resolve issues\n\n        # Diagnostic metadata for audit and performance tracking\n        metadata:\n          type: object\n          properties:\n            # Timestamp when diagnosis completed\n            diagnosedAt:\n              type: string\n              format: date-time\n            # Total execution time for performance monitoring\n            executionTimeMs:\n              type: integer\n\n      # Link to capability (marks as output schema)\n      x-ossa-capability-schema:\n        capabilityName: pod-diagnostics\n        output: true                     # This is an output schema\n\n# ============================================================================\n# API Paths with Full OSSA Extensions\n# ============================================================================\npaths:\n  # ==========================================================================\n  # /api/v1/diagnose/pod - Kubernetes Pod Diagnostics\n  # ==========================================================================\n  # Full-featured OSSA operation demonstrating all OpenAPI extensions:\n  # - x-ossa-capability: Capability metadata with schema references\n  # - x-ossa-autonomy: Supervised mode with action allowlists/blocklists\n  # - x-ossa-constraints: Cost, performance, and time limits\n  # - x-ossa-tools: MCP tool integrations\n  # - x-ossa-llm: LLM configuration\n  # - Reusable parameters and schemas via $ref\n  # ==========================================================================\n  /api/v1/diagnose/pod:\n    post:\n      summary: Diagnose pod issues\n      description: |\n        Analyzes a Kubernetes pod to identify failures, configuration issues,\n        and resource constraints. Uses MCP tools to gather pod logs, events, and metrics.\n\n      operationId: diagnosePod\n\n      tags:\n        - Diagnostics\n\n      # ======================================================================\n      # OSSA Capability Extension (Full Form)\n      # ======================================================================\n      # Full capability definition with schema references.\n      # Enables contract-first design and automatic validation.\n      # ======================================================================\n      x-ossa-capability:\n        name: pod-diagnostics\n        description: Diagnose Kubernetes pod failures and issues\n\n        # Reference to input schema in components/schemas\n        inputSchema:\n          $ref: \"#/components/schemas/PodDiagnosticRequest\"\n\n        # Reference to output schema in components/schemas\n        outputSchema:\n          $ref: \"#/components/schemas/PodDiagnosticResponse\"\n\n      # ======================================================================\n      # OSSA Autonomy Extension (Advanced)\n      # ======================================================================\n      # Fine-grained control over agent autonomy.\n      # Uses allowlists and blocklists for precise action control.\n      # ======================================================================\n      x-ossa-autonomy:\n        # Supervised mode: human approval required before execution\n        level: supervised\n\n        # Explicit approval requirement (overrides level)\n        approval_required: true\n\n        # Allowed actions (allowlist pattern)\n        # Agent can ONLY perform these Kubernetes operations\n        allowed_actions:\n          - read_pods          # Get pod status\n          - read_logs          # Fetch pod logs\n          - read_events        # Get Kubernetes events\n          - read_metrics       # Query metrics server\n\n        # Blocked actions (blocklist pattern)\n        # Agent CANNOT perform these operations (safety critical)\n        blocked_actions:\n          - delete_pods        # No pod deletion\n          - scale_deployments  # No scaling changes\n          - modify_configs     # No config mutations\n\n      # ======================================================================\n      # OSSA Constraints Extension\n      # ======================================================================\n      # Multi-dimensional constraints for cost control, performance,\n      # and time limits. Prevents runaway resource consumption.\n      # ======================================================================\n      x-ossa-constraints:\n        # Cost constraints (prevents budget overruns)\n        cost:\n          maxTokensPerDay: 50000         # Daily token budget\n          maxTokensPerRequest: 4000      # Per-request token limit\n          maxCostPerDay: 10.0            # Daily cost cap (USD)\n          currency: USD                  # Currency for cost tracking\n\n        # Performance constraints (SLA enforcement)\n        performance:\n          maxLatencySeconds: 30          # Maximum response time\n          maxConcurrentRequests: 5       # Concurrency limit\n\n        # Time constraints (prevents hung executions)\n        time:\n          maxExecutionTime: 300          # Maximum execution time (5 minutes)\n\n      # ======================================================================\n      # OSSA Tools Extension\n      # ======================================================================\n      # Defines MCP tools this operation can use.\n      # Each tool provides specific capabilities for Kubernetes interaction.\n      # ======================================================================\n      x-ossa-tools:\n        # Kubernetes MCP server for cluster interaction\n        - type: mcp                          # Tool type (mcp, http, grpc)\n          server: kubernetes-mcp             # MCP server name\n          namespace: default                 # Kubernetes namespace\n\n          # MCP capabilities this operation uses\n          capabilities:\n            - get_pods                       # kubectl get pods\n            - get_logs                       # kubectl logs\n            - get_events                     # kubectl get events\n            - describe_resource              # kubectl describe\n            - get_metrics                    # metrics-server query\n\n        # BuildKit Agent Protocol for documentation and log analysis\n        - type: mcp\n          server: buildkit-agent-protocol\n          namespace: default\n          capabilities:\n            - search_documentation           # Search k8s docs\n            - analyze_logs                   # LLM-powered log analysis\n\n      # ======================================================================\n      # OSSA LLM Extension\n      # ======================================================================\n      # LLM configuration for this specific operation.\n      # GPT-4 for complex reasoning over diagnostic data.\n      # ======================================================================\n      x-ossa-llm:\n        provider: openai                     # LLM provider\n        model: gpt-4                         # High-quality reasoning model\n        temperature: 0.2                     # Low temperature for consistency\n        maxTokens: 4000                      # Max output tokens\n\n      # Reference reusable parameters from components\n      parameters:\n        - $ref: \"#/components/parameters/X-Ossa-Agent-Id\"\n        - $ref: \"#/components/parameters/X-Ossa-Version\"\n\n      # Standard OpenAPI request body (references component schema)\n      requestBody:\n        required: true\n        content:\n          application/json:\n            # Reference to input schema (DRY principle)\n            schema:\n              $ref: \"#/components/schemas/PodDiagnosticRequest\"\n\n      # Response definitions with examples\n      responses:\n        # Success response (200 OK)\n        '200':\n          description: Diagnosis completed successfully\n          content:\n            application/json:\n              # Reference to output schema (DRY principle)\n              schema:\n                $ref: \"#/components/schemas/PodDiagnosticResponse\"\n\n              # Example response for documentation and testing\n              example:\n                status: degraded\n                issues:\n                  - severity: warning\n                    message: \"High memory usage detected (95%)\"\n                    resource: \"my-app-7d4f6b8c9\"\n                  - severity: info\n                    message: \"Pod restart count: 3\"\n                    resource: \"my-app-7d4f6b8c9\"\n                recommendations:\n                  - \"Increase memory limit or optimize application memory usage\"\n                  - \"Review pod restart logs for patterns\"\n                metadata:\n                  diagnosedAt: \"2024-01-15T10:30:00Z\"\n                  executionTimeMs: 2341\n\n        # Client error - invalid request (400 Bad Request)\n        '400':\n          description: Invalid request\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n\n        # Forbidden - approval required or insufficient permissions (403 Forbidden)\n        # This is triggered when x-ossa-autonomy.approval_required is true\n        # or when blocked_actions are attempted\n        '403':\n          description: Insufficient permissions or approval required\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  error:\n                    type: string\n                  # Indicates whether human approval is needed\n                  approvalRequired:\n                    type: boolean\n\n# ============================================================================\n# End of Full-Featured OSSA OpenAPI Example\n# ============================================================================\n#\n# VALIDATION:\n#   # Validate OpenAPI spec\n#   swagger-cli validate worker-agent-api.openapi.yml\n#\n#   # Validate OSSA extensions\n#   ossa validate worker-agent-api.openapi.yml\n#\n# CODE GENERATION:\n#   # Generate server with OSSA middleware\n#   ossa generate server -i worker-agent-api.openapi.yml -o ./server\n#\n#   # Generate typed client SDK\n#   ossa generate client -i worker-agent-api.openapi.yml -o ./client\n#\n# KEY FEATURES DEMONSTRATED:\n#   1. Enterprise compliance tracking (x-ossa-metadata)\n#   2. Advanced autonomy controls (allowed/blocked actions)\n#   3. Multi-dimensional constraints (cost, performance, time)\n#   4. MCP tool integration (Kubernetes and BuildKit)\n#   5. Reusable components (parameters, schemas)\n#   6. Capability schema linking (x-ossa-capability-schema)\n#   7. RFC 7807 error responses\n#   8. OpenAPI 3.1 $ref usage for DRY\n#\n# COMPARISON WITH MINIMAL EXAMPLE:\n#   - minimal-agent-api.openapi.yml: Basic OSSA extensions\n#   - worker-agent-api.openapi.yml: Full enterprise features\n#\n# RELATED EXAMPLES:\n#   - examples/drupal/gitlab-ml-recommender.ossa.yaml (YAML manifest format)\n#   - examples/bridges/aiflow-bridge-example.yml (framework bridge)\n#   - examples/openapi-extensions/minimal-agent-api.openapi.yml (basics)\n#   - spec/OSSA_OpenAPI_Extensions.md (complete specification)\n# ============================================================================\n\n",
    "category": "OpenAPI Extensions"
  },
  {
    "name": "agent.yml",
    "path": "production/agent.yml",
    "content": "# ============================================================================\n# OSSA Production Worker Agent Example\n# ============================================================================\n# Purpose: Production-ready worker agent for document analysis with NLP\n#\n# Key Concepts:\n# - Worker Agent: Executes tasks delegated by orchestrator agents\n# - Capability-Based: Registers capabilities for discovery and routing\n# - Production-Grade: Full observability, health checks, and resource limits\n# - Multi-Protocol: Exposes both OpenAPI and MCP bridges for integration\n#\n# Conformance Level: Silver\n# - Production-ready with comprehensive monitoring\n# - Health checks for dependencies (database, Redis)\n# - Structured logging with redaction\n# - Metrics and distributed tracing\n# - Performance optimization (caching, batching)\n#\n# Related Examples:\n# - examples/openapi-extensions/orchestrator-agent-api.openapi.yml (Orchestrator)\n# - examples/openapi-extensions/worker-agent-api.openapi.yml (Worker API)\n# - examples/agent-manifests/orchestrators/orchestrator-agent.yaml (Orchestrator manifest)\n#\n# Integration Pattern:\n# 1. Worker agent registers capabilities in agent-mesh\n# 2. Orchestrator discovers worker via agent-router\n# 3. Orchestrator delegates workflow step to worker\n# 4. Worker executes capability and returns result\n# 5. Orchestrator aggregates results from all workers\n#\n# OSSA Version: 1.0 (Worker profile)\n# ============================================================================\n\n# OSSA specification version - defines schema and features\nossaVersion: \"1.0\"\n\n# ============================================================================\n# AGENT: Core identity, capabilities, and runtime configuration\n# ============================================================================\nagent:\n  # Unique identifier for service discovery and routing\n  # - Used by agent-router to route requests to this agent\n  # - Must be unique within the agent ecosystem\n  id: document-analyzer\n\n  # Human-readable name for UI and documentation\n  name: Document Analyzer\n\n  # Semantic version for compatibility tracking\n  # - Breaking changes: Increment major version\n  # - New capabilities: Increment minor version\n  # - Bug fixes: Increment patch version\n  version: 2.1.0\n\n  # Description for service discovery and documentation\n  description: Production document analysis agent with NLP capabilities\n\n  # Role defines the agent's purpose in multi-agent workflows\n  # - data_processing: Transforms or analyzes data\n  # - code_generation: Generates or modifies code\n  # - quality_assurance: Validates outputs\n  # - orchestration: Coordinates other agents\n  role: data_processing\n\n  # Tags enable filtering and discovery\n  # - Used by orchestrators to find agents with specific traits\n  # - Example: Find all NLP agents, all production agents, etc.\n  tags:\n    - nlp          # Natural Language Processing capability\n    - documents    # Document processing specialization\n    - analysis     # Analytical capabilities\n    - production   # Production-ready deployment\n\n  # Metadata for governance and compliance\n  metadata:\n    author: Bluefly.io    # Team or organization maintaining this agent\n    license: MIT          # License for usage and distribution\n\n  # ============================================================================\n  # RUNTIME: Kubernetes deployment configuration\n  # ============================================================================\n  runtime:\n    # Deployment type: k8s (Kubernetes), docker, serverless, etc.\n    type: k8s\n\n    # Container image with version tag\n    # - Use semantic versioning for image tags\n    # - Avoid 'latest' tag in production\n    image: ossa/document-analyzer:2.1.0\n\n    # Resource requests and limits for Kubernetes\n    resources:\n      # CPU allocation: 1000m = 1 CPU core\n      # - Request: Guaranteed allocation\n      # - Limit: Maximum allowed (set in k8s manifest)\n      cpu: \"1000m\"\n\n      # Memory allocation: 1Gi = 1 gibibyte\n      # - Request: Guaranteed allocation\n      # - Limit: Maximum allowed (OOM kill if exceeded)\n      memory: \"1Gi\"\n\n    # Health check configuration for Kubernetes liveness/readiness probes\n    health_check:\n      # HTTP health check endpoint\n      type: http\n\n      # Health check endpoint path\n      # - Should return 200 OK when healthy\n      # - Should check all critical dependencies (DB, Redis, etc.)\n      endpoint: /health\n\n      # Port for health check requests\n      port: 3000\n\n  # ============================================================================\n  # CAPABILITIES: Functions this worker agent can perform\n  # ============================================================================\n  # Capabilities are registered in agent-mesh for discovery by orchestrators\n  # Each capability defines input/output schemas and timeout constraints\n  capabilities:\n    # ------------------------------------------------------------------------\n    # Capability: analyze_document - Comprehensive NLP analysis\n    # ------------------------------------------------------------------------\n    - name: analyze_document\n      # Description used for capability matching and documentation\n      description: Comprehensive document analysis with sentiment and entities\n\n      # Input schema: JSON Schema for request validation\n      input_schema:\n        type: object\n        required: [\"document\"]    # Document text is required\n        properties:\n          # Document text to analyze\n          document:\n            type: string\n            description: Document text to analyze\n\n          # Optional: Include entity extraction in analysis\n          # - Named entities: People, organizations, locations, dates\n          includeEntities:\n            type: boolean\n            default: true\n\n          # Optional: Include sentiment analysis in analysis\n          # - Sentiment: Positive, negative, neutral with confidence scores\n          includeSentiment:\n            type: boolean\n            default: true\n\n      # Output schema: JSON Schema for response validation\n      output_schema:\n        type: object\n        properties:\n          # Sentiment analysis results\n          # - score: -1.0 (negative) to 1.0 (positive)\n          # - label: positive, negative, neutral\n          # - confidence: 0.0 to 1.0\n          sentiment:\n            type: object\n\n          # Named entities extracted from document\n          # - type: PERSON, ORG, GPE, DATE, etc.\n          # - text: Entity mention in document\n          # - start/end: Character offsets\n          entities:\n            type: array\n\n          # Generated summary of document (if requested)\n          summary:\n            type: string\n\n      # Maximum execution time: 300 seconds (5 minutes)\n      # - Includes NLP model inference time\n      # - Should handle large documents (up to 100KB)\n      timeout_seconds: 300\n\n    # ------------------------------------------------------------------------\n    # Capability: extract_text - Extract text from binary documents\n    # ------------------------------------------------------------------------\n    - name: extract_text\n      # Extract text from PDF, Word, images (OCR), etc.\n      description: Extract text from various document formats\n\n      input_schema:\n        type: object\n        required: [\"document\"]\n        properties:\n          # Binary document data (base64 encoded)\n          # - Supports: PDF, DOCX, PPTX, images (OCR)\n          document:\n            type: string\n            format: binary\n\n      output_schema:\n        type: object\n        properties:\n          # Extracted plain text from document\n          text:\n            type: string\n\n      # Shorter timeout: Text extraction is faster than analysis\n      # - 60 seconds should handle most documents\n      timeout_seconds: 60\n\n    # ------------------------------------------------------------------------\n    # Capability: summarize_document - Generate document summary\n    # ------------------------------------------------------------------------\n    - name: summarize_document\n      # Generate abstractive or extractive summary\n      description: Generate concise document summary\n\n      input_schema:\n        type: object\n        required: [\"text\"]\n        properties:\n          # Document text to summarize\n          text:\n            type: string\n\n          # Maximum summary length in characters\n          # - Default: 500 characters (2-3 sentences)\n          maxLength:\n            type: integer\n            default: 500\n\n      output_schema:\n        type: object\n        properties:\n          # Generated summary\n          # - Abstractive: Paraphrased summary\n          # - Extractive: Key sentences from original\n          summary:\n            type: string\n\n      # Medium timeout: Summarization is moderately expensive\n      # - 120 seconds for documents up to 50KB\n      timeout_seconds: 120\n\n    # ------------------------------------------------------------------------\n    # Capability: classify_document - Categorize document by type\n    # ------------------------------------------------------------------------\n    - name: classify_document\n      # Classify into predefined categories (e.g., invoice, contract, email)\n      description: Classify document into categories\n\n      input_schema:\n        type: object\n        required: [\"text\"]\n        properties:\n          # Document text to classify\n          text:\n            type: string\n\n      output_schema:\n        type: object\n        properties:\n          # Predicted category label\n          # - Examples: invoice, contract, email, report, memo\n          category:\n            type: string\n\n          # Confidence score for prediction (0.0 to 1.0)\n          # - Use threshold (e.g., 0.8) for high-confidence predictions\n          confidence:\n            type: number\n\n      # Fast timeout: Classification is quick (single model inference)\n      timeout_seconds: 60\n\n  # ============================================================================\n  # INTEGRATION: How orchestrators communicate with this worker agent\n  # ============================================================================\n  integration:\n    # Protocol: HTTP REST API\n    # - Alternatives: gRPC, WebSocket, message queue\n    protocol: http\n\n    # Endpoint configuration\n    endpoints:\n      # Base URL for all API requests\n      # - Uses Kubernetes service DNS: <service-name>:<port>\n      base_url: \"http://document-analyzer:3000\"\n\n      # Health check endpoint (Kubernetes liveness/readiness)\n      health: /health\n\n      # Prometheus metrics endpoint\n      metrics: /metrics\n\n      # OpenAPI specification for capabilities\n      # - Auto-generated from capability definitions\n      # - Used by clients for request/response validation\n      openapi: /api/openapi.json\n\n    # Authentication: JWT tokens\n    # - Orchestrators include JWT in Authorization header\n    # - Worker validates token signature and expiration\n    auth:\n      type: jwt\n\n# ============================================================================\n# MONITORING: Observability configuration for production operations\n# ============================================================================\nmonitoring:\n  # IO-aware monitoring: Track input/output for each capability invocation\n  # - Enables debugging of request/response payloads\n  # - Supports compliance auditing and traceability\n  io_aware: true\n\n  # ============================================================================\n  # LOGS: Structured logging configuration\n  # ============================================================================\n  logs:\n    # JSON Lines format for structured logging\n    # - Each log entry is a single JSON object\n    # - Easy to parse by log aggregation tools (ELK, Loki, CloudWatch)\n    format: jsonl\n\n    # Log level: trace, debug, info, warn, error, fatal\n    # - info: Standard production level (business events)\n    # - debug: Troubleshooting (more verbose)\n    # - trace: Full request/response payloads (development only)\n    level: info\n\n    # Enable distributed tracing correlation IDs in logs\n    # - Links logs to distributed traces (Jaeger, Zipkin)\n    # - trace_id and span_id fields in every log entry\n    trace: true\n\n    # Log retention period: 30 days\n    # - Comply with data retention policies\n    # - Balance storage costs with debugging needs\n    retention: 30d\n\n    # Log outputs: Where to send logs\n    outputs:\n      # Console output for Kubernetes log collection\n      # - Kubernetes captures stdout/stderr\n      # - Forwarded to log aggregation system\n      - type: console\n\n      # File output for local debugging and backup\n      - type: file\n        config:\n          # Log file path (persistent volume in Kubernetes)\n          path: /var/log/ossa/document-analyzer.log\n\n          # Daily log rotation to prevent large files\n          rotation: daily\n\n          # Keep last 7 days of logs (7 * 24h = 168h retention)\n          max_files: 7\n\n  # ============================================================================\n  # METRICS: Prometheus metrics configuration\n  # ============================================================================\n  metrics:\n    # Enable metrics collection\n    enabled: true\n\n    # Metrics endpoint for Prometheus scraping\n    # - Kubernetes ServiceMonitor targets this endpoint\n    endpoint: /metrics\n\n    # Prometheus exposition format\n    # - Standard text-based format for Prometheus\n    format: prometheus\n\n    # Scrape interval: 60 seconds\n    # - Balance between metric granularity and overhead\n    # - Kubernetes typically scrapes every 30-60 seconds\n    interval: 60\n\n    # Custom business metrics (in addition to standard runtime metrics)\n    custom_metrics:\n      # Counter: Total documents processed\n      # - Monotonically increasing count\n      # - Labels enable filtering by document type and status\n      - name: documents_processed_total\n        type: counter\n        description: Total documents processed\n        labels: [document_type, status]\n\n      # Histogram: Document analysis duration\n      # - Distribution of processing times\n      # - Buckets define SLO boundaries (e.g., p50, p95, p99)\n      - name: analysis_duration_seconds\n        type: histogram\n        description: Document analysis duration\n        buckets: [0.1, 0.5, 1, 2, 5, 10]\n\n  # ============================================================================\n  # TRACES: Distributed tracing configuration\n  # ============================================================================\n  traces:\n    # Enable distributed tracing\n    enabled: true\n\n    # OpenTelemetry Protocol (OTLP) format\n    # - Standard protocol for traces, metrics, and logs\n    # - Compatible with Jaeger, Zipkin, Tempo, etc.\n    format: otlp\n\n    # Jaeger collector endpoint\n    # - Receives trace spans from agent\n    # - Stores traces for querying and visualization\n    endpoint: http://jaeger:4317\n\n    # Sampling configuration: Don't trace every request\n    sampling:\n      # Probabilistic sampling: Randomly sample requests\n      # - Alternatives: always_on, always_off, parent_based\n      type: probabilistic\n\n      # Sample 10% of requests\n      # - Reduces overhead while preserving statistical accuracy\n      # - Increase rate (e.g., 1.0) for debugging\n      rate: 0.1\n\n  # ============================================================================\n  # HEALTH: Health check configuration\n  # ============================================================================\n  health:\n    # Enable health checks\n    enabled: true\n\n    # Health check endpoint\n    # - Used by Kubernetes liveness and readiness probes\n    # - Should return 200 OK when healthy, 5xx when unhealthy\n    endpoint: /health\n\n    # Health check interval: 30 seconds\n    # - Kubernetes probes typically run every 10-30 seconds\n    interval: 30\n\n    # Dependency health checks\n    # - Agent is only healthy if all dependencies are reachable\n    # - Prevents routing traffic to unhealthy instances\n    checks:\n      # PostgreSQL database health\n      - name: database\n        type: tcp          # TCP connection test\n        config:\n          port: 5432       # PostgreSQL default port\n          timeout: 5       # Fail after 5 seconds\n\n      # Redis cache health\n      - name: redis\n        type: tcp          # TCP connection test\n        config:\n          port: 6379       # Redis default port\n          timeout: 5       # Fail after 5 seconds\n\n  # ============================================================================\n  # REDACTION: PII/sensitive data redaction in logs and traces\n  # ============================================================================\n  redaction:\n    # Enable automatic redaction of sensitive data\n    # - Prevents PII leaks in logs, traces, and metrics\n    # - Required for GDPR, HIPAA, PCI-DSS compliance\n    enabled: true\n\n    # Regex patterns for sensitive data detection\n    patterns:\n      # Credit card numbers (Luhn algorithm format)\n      # - Matches: 4532 1234 5678 9010, GB12 3456 7890 1234 5678\n      - pattern: \"\\\\b[A-Z]{2}\\\\d{2}\\\\s?\\\\d{4}\\\\s?\\\\d{4}\\\\s?\\\\d{4}\\\\s?\\\\d{4}\\\\b\"\n        name: credit_card\n\n      # US Social Security Numbers (SSN)\n      # - Matches: 123-45-6789\n      - pattern: \"\\\\b\\\\d{3}-\\\\d{2}-\\\\d{4}\\\\b\"\n        name: ssn\n\n      # Email addresses\n      # - Matches: user@example.com\n      - pattern: \"\\\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Z|a-z]{2,}\\\\b\"\n        name: email\n\n    # Replacement text for redacted data\n    # - All matches replaced with this string\n    # - Preserves log structure while hiding sensitive data\n    replacement: '[REDACTED]'\n\n# ============================================================================\n# PERFORMANCE: Optimization strategies for cost and latency\n# ============================================================================\nperformance:\n  # ============================================================================\n  # TOKEN OPTIMIZATION: Reduce LLM token usage (if using LLM for NLP)\n  # ============================================================================\n  token_optimization:\n    # Enable token optimization strategies\n    enabled: true\n\n    # Optimization strategies\n    strategies:\n      # Sliding window: Process long documents in chunks\n      # - Prevents exceeding context window limits\n      # - Maintains context across chunks via overlap\n      - type: sliding_window\n        config:\n          # Window size: 4096 tokens (~16KB text)\n          # - Fits within most LLM context windows\n          # - Allows for overlap between windows\n          window_size: 4096\n\n    # Maximum context length: 32000 tokens\n    # - Total context available for processing\n    # - Includes prompt, document, and response\n    max_context: 32000\n\n  # ============================================================================\n  # CACHE: Multi-layer caching for repeated requests\n  # ============================================================================\n  cache:\n    # Enable caching for performance and cost savings\n    # - Reduces redundant NLP processing\n    # - Lowers LLM API costs\n    enabled: true\n\n    # Cache layers: L1 (memory) -> L2 (Redis)\n    layers:\n      # L1 Cache: In-memory cache (fastest, limited capacity)\n      - name: memory_cache\n        type: memory\n        # Cache size: 100MB\n        # - Stores ~10,000 document analysis results\n        size: 100MB\n        # TTL: 300 seconds (5 minutes)\n        # - Short TTL for frequently accessed data\n        # - Falls through to L2 if expired\n        ttl: 300\n\n      # L2 Cache: Redis cache (slower, larger capacity)\n      - name: redis_cache\n        type: redis\n        # TTL: 3600 seconds (1 hour)\n        # - Longer TTL for less frequently accessed data\n        # - Persists across agent restarts\n        ttl: 3600\n        config:\n          # Redis connection details\n          host: redis\n          port: 6379\n          db: 0\n\n    # Cache key strategy: semantic\n    # - Keys based on semantic similarity of input\n    # - Similar documents share cache entries\n    # - Alternatives: exact (exact text match), hash (SHA-256)\n    key_strategy: semantic\n\n  # ============================================================================\n  # BATCHING: Batch multiple requests for throughput\n  # ============================================================================\n  batching:\n    # Enable request batching\n    # - Processes multiple documents in a single batch\n    # - Improves GPU utilization for NLP models\n    enabled: true\n\n    # Dynamic batching: Adjust batch size based on load\n    # - Small batches under light load (low latency)\n    # - Large batches under heavy load (high throughput)\n    dynamic: true\n\n    # Maximum batch size: 32 documents\n    # - Balance between throughput and latency\n    # - Larger batches increase latency but improve throughput\n    max_batch_size: 32\n\n    # Batch timeout: 100ms\n    # - Maximum time to wait for batch to fill\n    # - Prevents indefinite waiting under light load\n    timeout_ms: 100\n\n# ============================================================================\n# BRIDGE: Protocol bridges for multi-protocol support\n# ============================================================================\nbridge:\n  # ============================================================================\n  # OPENAPI BRIDGE: REST API for standard HTTP clients\n  # ============================================================================\n  openapi:\n    # Enable OpenAPI bridge\n    # - Exposes capabilities as REST endpoints\n    # - Auto-generates API from capability definitions\n    enabled: true\n\n    # OpenAPI specification file\n    # - Can be manually authored or auto-generated\n    # - Used by clients for request/response validation\n    spec_url: ./openapi.yaml\n\n    # Auto-generate OpenAPI spec from capabilities\n    # - false: Use manually authored spec (this example)\n    # - true: Generate spec from capability definitions\n    auto_generate: false\n\n  # ============================================================================\n  # MCP BRIDGE: Model Context Protocol for LLM integration\n  # ============================================================================\n  # MCP enables LLMs to invoke agent capabilities as tools\n  # - LLMs can call analyzeDocument, extractEntities, etc.\n  # - Agent capabilities become LLM function calls\n  mcp:\n    # Enable MCP bridge\n    # - Exposes capabilities as MCP tools\n    # - Allows LLMs to orchestrate this agent\n    enabled: true\n\n    # Server type: stdio (standard input/output)\n    # - Communication via stdin/stdout\n    # - Alternative: http (REST API for MCP)\n    server_type: stdio\n\n    # MCP tools: Capabilities exposed to LLMs\n    tools:\n      # MCP Tool: analyzeDocument\n      # - Maps to capability: analyze_document\n      # - Simplified interface for LLM consumption\n      - name: analyzeDocument\n        description: Analyze document with NLP\n        input_schema:\n          type: object\n          required: [document]\n          properties:\n            # Document text to analyze\n            document:\n              type: string\n            # Optional analysis options\n            options:\n              type: object\n        # Capability this tool invokes\n        # - Maps MCP tool call to OSSA capability\n        capability: sentiment_analysis\n\n      # MCP Tool: extractEntities\n      # - Maps to capability: analyze_document (with entity extraction)\n      # - Focused interface for entity extraction only\n      - name: extractEntities\n        description: Extract named entities\n        input_schema:\n          type: object\n          required: [text]\n          properties:\n            # Text to extract entities from\n            text:\n              type: string\n        # Capability this tool invokes\n        capability: entity_recognition\n\n# ============================================================================\n# END OF MANIFEST\n# ============================================================================\n# Deployment Instructions:\n#\n# 1. Build container image:\n#    docker build -t ossa/document-analyzer:2.1.0 .\n#\n# 2. Push to registry:\n#    docker push ossa/document-analyzer:2.1.0\n#\n# 3. Deploy to Kubernetes:\n#    kubectl apply -f k8s/deployment.yaml\n#    kubectl apply -f k8s/service.yaml\n#\n# 4. Register with agent-mesh:\n#    curl -X POST http://agent-mesh/api/v1/agents \\\n#      -H \"Content-Type: application/json\" \\\n#      -d @agent.yml\n#\n# 5. Verify registration:\n#    curl http://agent-mesh/api/v1/agents/document-analyzer\n#\n# 6. Test capability:\n#    curl -X POST http://document-analyzer:3000/api/v1/analyze \\\n#      -H \"Content-Type: application/json\" \\\n#      -d '{\"document\": \"This is a test document.\"}'\n#\n# Monitoring:\n# - Logs: kubectl logs -f deployment/document-analyzer\n# - Metrics: http://document-analyzer:3000/metrics\n# - Traces: https://jaeger.example.com/search?service=document-analyzer\n# - Health: curl http://document-analyzer:3000/health\n#\n# Related Documentation:\n# - OSSA Spec: https://ossa.ai/spec\n# - Worker Agent Pattern: https://ossa.ai/docs/worker-agents\n# - Capability Registration: https://ossa.ai/docs/capabilities\n# - MCP Integration: https://modelcontextprotocol.io\n#\n# Multi-Agent Workflow:\n# 1. Orchestrator receives workflow request\n# 2. Uses agent-router to discover this worker (by capability)\n# 3. Delegates document analysis task to this worker\n# 4. Worker processes document and returns results\n# 5. Orchestrator aggregates results with other workers\n#\n# Example Workflow Step:\n# {\n#   \"stepId\": \"analyze-sentiment\",\n#   \"agentType\": \"worker\",\n#   \"capability\": \"sentiment_analysis\",\n#   \"input\": {\n#     \"document\": \"Customer feedback text...\",\n#     \"includeEntities\": true,\n#     \"includeSentiment\": true\n#   }\n# }\n# ============================================================================\n",
    "category": "Production"
  },
  {
    "name": "document-analyzer-openai.yml",
    "path": "production/document-analyzer-openai.yml",
    "content": "# OSSA Agent with OpenAI Bridge Configuration Example\n# Document Analyzer Agent - Proof of Concept\n\napiVersion: ossa/v1\nkind: Agent\nmetadata:\n  name: document-analyzer\n  version: \"2.1.0\"\n  description: Production document analysis agent with NLP capabilities\n  labels:\n    domain: nlp\n    type: document-processing\n  annotations:\n    author: Bluefly.io\n    license: MIT\n\nspec:\n  taxonomy:\n    domain: data_processing\n    subdomain: nlp\n    capability: document_analysis\n  \n  role: |\n    You are a document analysis agent specializing in NLP tasks.\n    Your capabilities include:\n    - Analyzing documents for sentiment and emotional tone\n    - Extracting named entities (people, organizations, locations)\n    - Generating concise summaries of document content\n    - Classifying documents into predefined categories\n    \n    Always provide clear, actionable insights from document analysis.\n\n  llm:\n    provider: openai\n    model: gpt-4o-mini\n    temperature: 0.3\n    maxTokens: 4096\n\n  tools:\n    - type: function\n      name: analyze_document\n      capabilities: [analyze_document]\n    - type: function\n      name: extract_text\n      capabilities: [extract_text]\n    - type: function\n      name: summarize_document\n      capabilities: [summarize_document]\n    - type: function\n      name: classify_document\n      capabilities: [classify_document]\n\n  autonomy:\n    level: autonomous\n    approval_required: false\n\n  constraints:\n    cost:\n      maxTokensPerDay: 1000000\n      maxCostPerDay: 50.0\n      currency: USD\n    performance:\n      maxLatencySeconds: 30\n      maxConcurrentRequests: 10\n      timeoutSeconds: 300\n\n  observability:\n    tracing:\n      enabled: true\n      exporter: otlp\n      endpoint: http://jaeger:4317\n    metrics:\n      enabled: true\n      exporter: prometheus\n      endpoint: http://prometheus:9090\n    logging:\n      level: info\n      format: json\n\nextensions:\n  openai_agents:\n    enabled: true\n    agent_id: document-analyzer\n    instructions: |\n      You are a document analysis agent specializing in NLP tasks.\n      Analyze documents for sentiment, extract named entities, summarize content,\n      and classify documents into categories.\n      \n      When analyzing documents:\n      1. Extract all named entities (people, organizations, locations)\n      2. Determine sentiment (positive, negative, neutral)\n      3. Identify key themes and topics\n      4. Provide actionable insights\n    model: gpt-4o-mini\n    \n    tools_mapping:\n      - ossa_capability: analyze_document\n        openai_tool_name: analyze_document\n        description: Analyze document text for sentiment analysis and entity extraction\n        \n      - ossa_capability: extract_text\n        openai_tool_name: extract_text\n        description: Extract text from various document formats (PDF, DOCX, TXT, etc.)\n        \n      - ossa_capability: summarize_document\n        openai_tool_name: summarize_document\n        description: Generate a concise summary of document content\n        \n      - ossa_capability: classify_document\n        openai_tool_name: classify_document\n        description: Classify document into predefined categories with confidence score\n    \n    guardrails:\n      enabled: true\n      policies:\n        - GDPR\n        - HIPAA\n      max_tool_calls: 10\n      timeout_seconds: 300\n    \n    memory:\n      enabled: true\n      type: session\n      max_messages: 50\n    \n    tracing:\n      enabled: true\n      provider: langfuse\n\n  mcp:\n    enabled: true\n    server_type: stdio\n    server_name: document-analyzer-mcp\n\n",
    "category": "Production"
  },
  {
    "name": "support-agent.ossa.yaml",
    "path": "quickstart/support-agent.ossa.yaml",
    "content": "# OSSA Quickstart Example - Customer Support Agent\n# Run with: ossa run examples/quickstart/support-agent.ossa.yaml\n\napiVersion: ossa/v0.2\nkind: Agent\n\nmetadata:\n  name: support-agent\n  version: 1.0.0\n  description: A helpful customer support agent that answers questions and helps with orders\n\nspec:\n  role: |\n    You are a friendly and helpful customer support agent for an e-commerce company.\n\n    Your responsibilities:\n    - Answer questions about orders, shipping, and returns\n    - Help customers track their packages\n    - Provide information about products\n    - Escalate complex issues to human agents when needed\n\n    Always be polite, concise, and helpful. If you don't know something, say so honestly.\n\n  llm:\n    provider: openai\n    model: gpt-4o-mini\n    temperature: 0.7\n    maxTokens: 1000\n\n  tools:\n    - type: function\n      name: get_order_status\n      capabilities:\n        - order_tracking\n\n  autonomy:\n    level: supervised\n    approval_required: false\n\n  observability:\n    logging:\n      level: info\n      format: json\n\nextensions:\n  openai_agents:\n    model: gpt-4o-mini\n    tools_mapping:\n      - ossa_capability: order_tracking\n        openai_tool_name: get_order_status\n        description: Get the status of a customer order by order ID\n        parameters:\n          type: object\n          properties:\n            order_id:\n              type: string\n              description: The order ID to look up (e.g., ORD-12345)\n          required:\n            - order_id\n",
    "category": "Getting Started"
  },
  {
    "name": "service-registry-usage.ts",
    "path": "service-registry-usage.ts",
    "content": "/**\n * OSSA Service Registry Usage Example\n * Demonstrates how to use the service registry for service discovery and management\n */\n\nimport ServiceRegistry, {\n  ServiceDefinition,\n  ServiceHealthStatus,\n  ServiceCapability,\n  DEFAULT_SERVICE_REGISTRY_CONFIG,\n} from '../src/services/ServiceRegistry.js';\nimport createRegistryApiRouter, {\n  SimpleRedisClient,\n} from '../src/api/registry.js';\nimport express from 'express';\n\n/**\n * Example: Basic Service Registry Usage\n */\nasync function basicRegistryExample() {\n  console.log('=== Basic Service Registry Example ===');\n\n  // Create a Redis client (using simple in-memory client for demo)\n  const redisClient = new SimpleRedisClient();\n\n  // Create service registry with custom configuration\n  const config = {\n    ...DEFAULT_SERVICE_REGISTRY_CONFIG,\n    healthCheck: {\n      intervalMs: 15000, // Check every 15 seconds\n      timeoutMs: 3000, // 3 second timeout\n      failureThreshold: 3,\n      successThreshold: 2,\n    },\n    serviceTtlSeconds: 600, // 10 minute TTL\n  };\n\n  const registry = new ServiceRegistry(config, redisClient);\n\n  // Register a service\n  const aiService: Omit<ServiceDefinition, 'registeredAt' | 'updatedAt'> = {\n    name: 'ai-text-processor',\n    endpoint: 'https://ai-service.company.com:8080',\n    version: '2.1.0',\n    capabilities: [\n      {\n        name: 'text-analysis',\n        version: '2.0.0',\n        description: 'Advanced text analysis with sentiment detection',\n        inputs: {\n          text: {\n            type: 'string',\n            description: 'Text to analyze',\n          },\n          options: {\n            type: 'object',\n            description: 'Analysis options',\n          },\n        },\n        outputs: {\n          sentiment: {\n            type: 'object',\n            description: 'Sentiment analysis results',\n          },\n          entities: {\n            type: 'array',\n            description: 'Detected entities',\n          },\n        },\n      },\n      {\n        name: 'text-translation',\n        version: '1.5.0',\n        description: 'Multi-language text translation',\n      },\n    ],\n    health: {\n      status: ServiceHealthStatus.UNKNOWN,\n      lastCheck: new Date(),\n    },\n    metadata: {\n      description: 'High-performance AI text processing service',\n      tags: ['ai', 'nlp', 'text-processing', 'production'],\n      author: 'AI Engineering Team',\n      documentation: 'https://docs.company.com/ai-text-processor',\n      environment: 'production',\n    },\n  };\n\n  console.log('Registering AI service...');\n  const registeredService = await registry.register(aiService);\n  console.log(\n    `✓ Registered: ${registeredService.name} at ${registeredService.endpoint}`\n  );\n\n  // Register another service\n  const dataService: Omit<ServiceDefinition, 'registeredAt' | 'updatedAt'> = {\n    name: 'data-processor',\n    endpoint: 'https://data-service.company.com:9090',\n    version: '3.0.1',\n    capabilities: [\n      {\n        name: 'data-transformation',\n        version: '3.0.0',\n        description: 'ETL data transformation pipeline',\n      },\n      {\n        name: 'data-validation',\n        version: '2.1.0',\n        description: 'Data quality validation and cleansing',\n      },\n    ],\n    health: {\n      status: ServiceHealthStatus.HEALTHY,\n      lastCheck: new Date(),\n      responseTime: 150,\n    },\n    metadata: {\n      description: 'Enterprise data processing pipeline',\n      tags: ['data', 'etl', 'processing', 'production'],\n      author: 'Data Engineering Team',\n      environment: 'production',\n    },\n  };\n\n  console.log('Registering Data service...');\n  await registry.register(dataService);\n  console.log(`✓ Registered: ${dataService.name} at ${dataService.endpoint}`);\n\n  // Discover all services\n  console.log('\\n--- Service Discovery ---');\n  const allServices = await registry.discover();\n  console.log(`Found ${allServices.length} services:`);\n  allServices.forEach((service) => {\n    console.log(\n      `  - ${service.name} v${service.version} (${service.health.status})`\n    );\n    console.log(\n      `    Capabilities: ${service.capabilities.map((c) => c.name).join(', ')}`\n    );\n  });\n\n  // Discover services by capability\n  console.log('\\n--- Discover by Capability ---');\n  const textServices = await registry.discover({ capability: 'text-analysis' });\n  console.log(`Services with text-analysis capability: ${textServices.length}`);\n  textServices.forEach((service) => {\n    console.log(`  - ${service.name}: ${service.endpoint}`);\n  });\n\n  // Discover services by tags\n  console.log('\\n--- Discover by Tags ---');\n  const aiServices = await registry.discover({ tags: ['ai', 'nlp'] });\n  console.log(`Services with AI/NLP tags: ${aiServices.length}`);\n  aiServices.forEach((service) => {\n    console.log(`  - ${service.name}: ${service.metadata?.tags?.join(', ')}`);\n  });\n\n  // Get registry statistics\n  console.log('\\n--- Registry Statistics ---');\n  const stats = await registry.getStats();\n  console.log(`Total Services: ${stats.totalServices}`);\n  console.log(\n    `Healthy: ${stats.healthyServices}, Unhealthy: ${stats.unhealthyServices}`\n  );\n  console.log(\n    `Degraded: ${stats.degradedServices}, Unknown: ${stats.unknownServices}`\n  );\n\n  // Update a service\n  console.log('\\n--- Service Update ---');\n  const updatedService = await registry.updateService('ai-text-processor', {\n    version: '2.1.1',\n    metadata: {\n      ...aiService.metadata,\n      description: 'Updated AI text processing service with bug fixes',\n    },\n  });\n  console.log(\n    `✓ Updated ${updatedService?.name} to version ${updatedService?.version}`\n  );\n\n  // Clean up\n  await registry.close();\n  console.log('\\n✓ Registry closed');\n}\n\n/**\n * Example: REST API Server with Service Registry\n */\nasync function apiServerExample() {\n  console.log('\\n=== REST API Server Example ===');\n\n  const redisClient = new SimpleRedisClient();\n  const registry = new ServiceRegistry(\n    DEFAULT_SERVICE_REGISTRY_CONFIG,\n    redisClient\n  );\n\n  // Create Express app\n  const app = express();\n  app.use(express.json());\n\n  // Add registry API routes\n  app.use('/api/v1/registry', createRegistryApiRouter(registry));\n\n  // Add a simple health check endpoint\n  app.get('/health', (req, res) => {\n    res.json({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      service: 'ossa-registry-api',\n    });\n  });\n\n  // Start server\n  const port = process.env.PORT || 3002;\n  const server = app.listen(port, () => {\n    console.log(`✓ Registry API server running on port ${port}`);\n    console.log(`  - Health: http://localhost:${port}/health`);\n    console.log(\n      `  - Registry API: http://localhost:${port}/api/v1/registry/services`\n    );\n    console.log(\n      `  - OpenAPI spec available in: src/api/service-registry.openapi.yml`\n    );\n  });\n\n  // Handle graceful shutdown\n  process.on('SIGINT', async () => {\n    console.log('\\nShutting down server...');\n    server.close();\n    await registry.close();\n    console.log('✓ Server shut down gracefully');\n    process.exit(0);\n  });\n\n  return { app, server, registry };\n}\n\n/**\n * Example: Health Monitoring with Events\n */\nasync function healthMonitoringExample() {\n  console.log('\\n=== Health Monitoring Example ===');\n\n  const redisClient = new SimpleRedisClient();\n  const config = {\n    ...DEFAULT_SERVICE_REGISTRY_CONFIG,\n    healthCheck: {\n      intervalMs: 5000, // Fast for demo\n      timeoutMs: 1000,\n      failureThreshold: 2,\n      successThreshold: 1,\n    },\n  };\n\n  const registry = new ServiceRegistry(config, redisClient);\n\n  // Set up event listeners\n  registry.on('service:registered', (service) => {\n    console.log(`🎯 Service registered: ${service.name}`);\n  });\n\n  registry.on('service:health:changed', (serviceName, oldStatus, newStatus) => {\n    console.log(\n      `🏥 Health changed: ${serviceName} ${oldStatus} → ${newStatus}`\n    );\n  });\n\n  registry.on('service:unregistered', (serviceName) => {\n    console.log(`👋 Service unregistered: ${serviceName}`);\n  });\n\n  registry.on('registry:error', (error) => {\n    console.error(`❌ Registry error: ${error.message}`);\n  });\n\n  // Register a test service\n  await registry.register({\n    name: 'test-health-service',\n    endpoint: 'https://test.example.com',\n    version: '1.0.0',\n    capabilities: [\n      {\n        name: 'test-capability',\n        version: '1.0.0',\n        description: 'Test capability',\n      },\n    ],\n    health: {\n      status: ServiceHealthStatus.UNKNOWN,\n      lastCheck: new Date(),\n    },\n    metadata: {\n      description: 'Test service for health monitoring',\n      tags: ['test'],\n      environment: 'development',\n    },\n  });\n\n  // Start health monitoring\n  console.log('Starting health monitoring...');\n  await registry.startHealthMonitoring();\n\n  // Simulate running for a while then cleanup\n  setTimeout(async () => {\n    console.log('Stopping health monitoring...');\n    registry.stopHealthMonitoring();\n    await registry.unregister('test-health-service');\n    await registry.close();\n    console.log('✓ Health monitoring example completed');\n  }, 15000);\n}\n\n/**\n * Example: Service Capability Discovery\n */\nasync function capabilityDiscoveryExample() {\n  console.log('\\n=== Capability Discovery Example ===');\n\n  const redisClient = new SimpleRedisClient();\n  const registry = new ServiceRegistry(\n    DEFAULT_SERVICE_REGISTRY_CONFIG,\n    redisClient\n  );\n\n  // Register services with various capabilities\n  const services = [\n    {\n      name: 'nlp-service-a',\n      capabilities: ['text-analysis', 'sentiment-detection'],\n      tags: ['ai', 'nlp'],\n    },\n    {\n      name: 'nlp-service-b',\n      capabilities: ['text-analysis', 'entity-extraction'],\n      tags: ['ai', 'nlp'],\n    },\n    {\n      name: 'vision-service',\n      capabilities: ['image-recognition', 'object-detection'],\n      tags: ['ai', 'vision'],\n    },\n    {\n      name: 'data-service',\n      capabilities: ['data-transformation', 'data-validation'],\n      tags: ['data', 'etl'],\n    },\n  ];\n\n  for (const serviceInfo of services) {\n    await registry.register({\n      name: serviceInfo.name,\n      endpoint: `https://${serviceInfo.name}.example.com`,\n      version: '1.0.0',\n      capabilities: serviceInfo.capabilities.map((cap) => ({\n        name: cap,\n        version: '1.0.0',\n        description: `${cap} capability`,\n      })),\n      health: {\n        status: ServiceHealthStatus.HEALTHY,\n        lastCheck: new Date(),\n      },\n      metadata: {\n        tags: serviceInfo.tags,\n        environment: 'production',\n      },\n    });\n  }\n\n  // Discover services by different criteria\n  console.log('Services with text-analysis capability:');\n  const textServices = await registry.discover({ capability: 'text-analysis' });\n  textServices.forEach((s) => console.log(`  - ${s.name}`));\n\n  console.log('\\nServices with AI tag:');\n  const aiServices = await registry.discover({ tags: ['ai'] });\n  aiServices.forEach((s) =>\n    console.log(`  - ${s.name}: ${s.metadata?.tags?.join(', ')}`)\n  );\n\n  console.log('\\nHealthy production services:');\n  const healthyServices = await registry.discover({\n    healthStatus: ServiceHealthStatus.HEALTHY,\n    environment: 'production',\n  });\n  healthyServices.forEach((s) =>\n    console.log(`  - ${s.name} (${s.capabilities.length} capabilities)`)\n  );\n\n  await registry.close();\n  console.log('✓ Capability discovery example completed');\n}\n\n// Run examples\nasync function runExamples() {\n  try {\n    await basicRegistryExample();\n    await capabilityDiscoveryExample();\n\n    // Uncomment to run health monitoring example (runs for 15 seconds)\n    // await healthMonitoringExample();\n\n    // Uncomment to start the API server (runs until Ctrl+C)\n    // await apiServerExample();\n  } catch (error) {\n    console.error('Error running examples:', error);\n  }\n}\n\n// Run if this file is executed directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  runExamples();\n}\n\nexport {\n  basicRegistryExample,\n  apiServerExample,\n  healthMonitoringExample,\n  capabilityDiscoveryExample,\n};\n",
    "category": "Getting Started"
  },
  {
    "name": "audit-agent.yml",
    "path": "spec-examples/audit-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: security-audit-agent\n  name: Security Audit Agent\n  version: 1.0.0\n  description: |\n    Automated security auditing agent that scans infrastructure,\n    detects vulnerabilities, and generates compliance reports.\n  role: audit\n  tags:\n    - security\n    - audit\n    - vulnerability-scanning\n    - compliance\n\n  # Runtime\n  runtime:\n    type: k8s\n    image: ossa/security-audit:1.0.0\n    requirements:\n      python: '>=3.11'\n      packages:\n        - trivy\n        - grype\n        - snyk\n    resources:\n      cpu: '1000m'\n      memory: '1Gi'\n    health_check:\n      type: http\n      endpoint: /health\n      port: 3700\n\n  # Capabilities\n  capabilities:\n    - name: scan_container_images\n      description: Scan container images for vulnerabilities\n      input_schema:\n        type: object\n        required:\n          - image\n        properties:\n          image:\n            type: string\n          severity_threshold:\n            type: string\n            enum: [low, medium, high, critical]\n            default: medium\n      output_schema:\n        type: object\n        properties:\n          vulnerabilities:\n            type: array\n          total_count:\n            type: integer\n          by_severity:\n            type: object\n      timeout_seconds: 600\n\n    - name: audit_kubernetes_cluster\n      description: Audit Kubernetes cluster security\n      input_schema:\n        type: object\n        properties:\n          namespace:\n            type: string\n          check_rbac:\n            type: boolean\n            default: true\n          check_network_policies:\n            type: boolean\n            default: true\n      output_schema:\n        type: object\n        properties:\n          findings:\n            type: array\n          risk_score:\n            type: number\n      timeout_seconds: 300\n\n    - name: generate_audit_report\n      description: Generate comprehensive security audit report\n      input_schema:\n        type: object\n        required:\n          - scan_results\n        properties:\n          scan_results:\n            type: array\n          format:\n            type: string\n            enum: [json, pdf, html]\n      output_schema:\n        type: object\n        properties:\n          report_url:\n            type: string\n          executive_summary:\n            type: string\n\n  # Policies\n  policies:\n    compliance:\n      - fedramp-moderate\n      - soc2-type2\n    encryption: true\n    audit: true\n    pii_handling: prohibit\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://security-audit:3700\n      health: /health\n      metrics: /metrics\n    auth:\n      type: jwt\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:3700/health\n\n  # Dependencies\n  dependencies:\n    required:\n      - agent_id: agent-tracer\n        min_version: '1.0.0'\n    optional:\n      - agent_id: compliance-engine\n        fallback: No automated alerting\n\n  # Metadata\n  metadata:\n    author: OSSA Security Team\n    maintainer: security@ossa.io\n    license: Apache-2.0\n    keywords:\n      - security\n      - audit\n      - scanning\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "chat-agent.yml",
    "path": "spec-examples/chat-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: customer-support-chat\n  name: Customer Support Chat Agent\n  version: 1.2.0\n  description: |\n    AI-powered customer support agent with natural language understanding,\n    context retention, and integration with ticketing systems.\n  role: chat\n  tags:\n    - customer-support\n    - chat\n    - nlp\n    - tickets\n\n  # Runtime\n  runtime:\n    type: docker\n    image: ossa/chat-agent:1.2.0\n    requirements:\n      node: '>=20.0.0'\n      packages:\n        - fastify\n        - openai\n        - langchain\n    resources:\n      cpu: '500m'\n      memory: '512Mi'\n      gpu: false\n    health_check:\n      type: http\n      endpoint: /health\n      port: 3000\n      period_seconds: 10\n\n  # Capabilities\n  capabilities:\n    - name: handle_chat_message\n      description: Process customer support chat message\n      input_schema:\n        type: object\n        required:\n          - message\n          - user_id\n        properties:\n          message:\n            type: string\n            description: Customer message\n          user_id:\n            type: string\n          session_id:\n            type: string\n          context:\n            type: object\n            description: Additional conversation context\n      output_schema:\n        type: object\n        properties:\n          response:\n            type: string\n          confidence:\n            type: number\n            minimum: 0\n            maximum: 1\n          suggested_actions:\n            type: array\n            items:\n              type: string\n          escalate_to_human:\n            type: boolean\n      timeout_seconds: 30\n      retry_policy:\n        max_attempts: 1\n        backoff: linear\n\n    - name: search_knowledge_base\n      description: Search knowledge base for relevant articles\n      input_schema:\n        type: object\n        required:\n          - query\n        properties:\n          query:\n            type: string\n          limit:\n            type: integer\n            default: 5\n      output_schema:\n        type: object\n        properties:\n          articles:\n            type: array\n            items:\n              type: object\n              properties:\n                title:\n                  type: string\n                content:\n                  type: string\n                relevance_score:\n                  type: number\n\n    - name: create_support_ticket\n      description: Create support ticket for escalation\n      input_schema:\n        type: object\n        required:\n          - subject\n          - description\n        properties:\n          subject:\n            type: string\n          description:\n            type: string\n          priority:\n            type: string\n            enum: [low, medium, high, urgent]\n          category:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          ticket_id:\n            type: string\n          ticket_url:\n            type: string\n            format: uri\n\n  # Policies\n  policies:\n    compliance:\n      - gdpr\n      - soc2-type1\n    data_residency:\n      - US\n      - EU\n    encryption: true\n    audit: false\n    pii_handling: anonymize\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://chat-agent:3000\n      health: /health\n      metrics: /metrics\n      openapi: /api/docs\n    auth:\n      type: api_key\n      config:\n        header_name: X-API-Key\n    rate_limits:\n      requests_per_second: 50\n      burst: 10\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:3000/health\n    phoenix_arise:\n      enabled: false\n\n  # Dependencies\n  dependencies:\n    required:\n      - agent_id: agent-brain\n        min_version: '1.0.0'\n    optional:\n      - agent_id: agent-tracer\n        fallback: Log to local files\n\n  # Metadata\n  metadata:\n    author: OSSA Chat Team\n    maintainer: chat@ossa.io\n    homepage: https://ossa.io/agents/customer-support-chat\n    repository: https://github.com/ossa-agents/chat-agent\n    documentation: https://docs.ossa.io/agents/chat\n    license: MIT\n    keywords:\n      - chat\n      - support\n      - nlp\n      - customer-service\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "compliance-agent.yml",
    "path": "spec-examples/compliance-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: compliance-scanner-fedramp\n  name: FedRAMP Compliance Scanner\n  version: 1.0.0\n  description: |\n    Automated compliance scanning agent for FedRAMP Moderate environments.\n    Scans infrastructure, code, and configurations for security vulnerabilities\n    and compliance violations.\n  role: compliance\n  tags:\n    - security\n    - fedramp\n    - compliance\n    - audit\n    - vulnerability-scanning\n\n  # Runtime\n  runtime:\n    type: k8s\n    image: ossa/compliance-scanner:1.0.0\n    requirements:\n      python: '>=3.11'\n      packages:\n        - bandit\n        - safety\n        - trivy\n        - kube-bench\n    resources:\n      cpu: '1000m'\n      memory: '1Gi'\n      gpu: false\n    health_check:\n      type: http\n      endpoint: /health\n      port: 3200\n      initial_delay_seconds: 30\n      period_seconds: 10\n      timeout_seconds: 5\n      failure_threshold: 3\n\n  # Capabilities\n  capabilities:\n    - name: scan_infrastructure\n      description: Scan Kubernetes infrastructure for compliance violations\n      input_schema:\n        type: object\n        required:\n          - namespace\n        properties:\n          namespace:\n            type: string\n            description: Kubernetes namespace to scan\n          include_pods:\n            type: boolean\n            default: true\n          include_network_policies:\n            type: boolean\n            default: true\n      output_schema:\n        type: object\n        properties:\n          violations:\n            type: array\n            items:\n              type: object\n              properties:\n                severity:\n                  type: string\n                  enum: [low, medium, high, critical]\n                resource:\n                  type: string\n                issue:\n                  type: string\n                remediation:\n                  type: string\n          compliance_score:\n            type: number\n            minimum: 0\n            maximum: 100\n      timeout_seconds: 600\n      retry_policy:\n        max_attempts: 2\n        backoff: exponential\n\n    - name: scan_code_vulnerabilities\n      description: Scan codebase for security vulnerabilities\n      input_schema:\n        type: object\n        required:\n          - repository_url\n        properties:\n          repository_url:\n            type: string\n            format: uri\n          branch:\n            type: string\n            default: main\n          scan_dependencies:\n            type: boolean\n            default: true\n      output_schema:\n        type: object\n        properties:\n          vulnerabilities:\n            type: array\n            items:\n              type: object\n          dependency_issues:\n            type: array\n            items:\n              type: object\n          risk_score:\n            type: number\n      timeout_seconds: 900\n\n    - name: generate_compliance_report\n      description: Generate comprehensive compliance report\n      input_schema:\n        type: object\n        properties:\n          scan_results:\n            type: array\n          format:\n            type: string\n            enum: [json, pdf, html]\n            default: json\n      output_schema:\n        type: object\n        properties:\n          report_url:\n            type: string\n            format: uri\n          summary:\n            type: object\n\n  # Policies & Compliance\n  policies:\n    compliance:\n      - fedramp-moderate\n      - soc2-type2\n      - nist-800-53\n    data_residency:\n      - US\n      - US-GOV\n    encryption: true\n    audit: true\n    pii_handling: encrypt\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://compliance-scanner:3200\n      health: /health\n      metrics: /metrics\n      openapi: /api/docs\n    auth:\n      type: jwt\n      config:\n        issuer: https://auth.ossa.io\n        audience: compliance-scanner\n    rate_limits:\n      requests_per_minute: 100\n      burst: 20\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:3200/health\n    phoenix_arise:\n      enabled: true\n      project: ossa-compliance\n      export_interval_seconds: 60\n\n  # Dependencies\n  dependencies:\n    required:\n      - agent_id: agent-tracer\n        min_version: '1.0.0'\n      - agent_id: compliance-engine\n        min_version: '1.0.0'\n    optional:\n      - agent_id: agent-brain\n        fallback: Use local memory\n\n  # Metadata\n  metadata:\n    author: OSSA Standards Team\n    maintainer: compliance@ossa.io\n    homepage: https://ossa.io/agents/compliance-scanner\n    repository: https://github.com/ossa-agents/compliance-scanner\n    documentation: https://docs.ossa.io/agents/compliance-scanner\n    license: Apache-2.0\n    keywords:\n      - compliance\n      - security\n      - fedramp\n      - scanning\n      - kubernetes\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "data-processing-agent.yml",
    "path": "spec-examples/data-processing-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: data-etl-processor\n  name: Data ETL Processing Agent\n  version: 1.0.0\n  description: |\n    High-performance data extraction, transformation, and loading agent\n    with support for multiple data sources and destinations.\n  role: data_processing\n  tags:\n    - etl\n    - data-processing\n    - transformation\n    - analytics\n\n  # Runtime\n  runtime:\n    type: k8s\n    image: ossa/data-etl:1.0.0\n    requirements:\n      python: '>=3.11'\n      packages:\n        - pandas\n        - sqlalchemy\n        - apache-airflow\n    resources:\n      cpu: '2000m'\n      memory: '4Gi'\n    health_check:\n      type: http\n      endpoint: /health\n      port: 3900\n\n  # Capabilities\n  capabilities:\n    - name: extract_data\n      description: Extract data from various sources\n      input_schema:\n        type: object\n        required:\n          - source_type\n          - connection_string\n        properties:\n          source_type:\n            type: string\n            enum: [postgres, mysql, api, csv, json]\n          connection_string:\n            type: string\n          query:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          data:\n            type: array\n          row_count:\n            type: integer\n      timeout_seconds: 600\n\n    - name: transform_data\n      description: Transform data using custom rules\n      input_schema:\n        type: object\n        required:\n          - data\n          - transformations\n        properties:\n          data:\n            type: array\n          transformations:\n            type: array\n      output_schema:\n        type: object\n        properties:\n          transformed_data:\n            type: array\n      timeout_seconds: 300\n\n    - name: load_data\n      description: Load data to destination\n      input_schema:\n        type: object\n        required:\n          - destination_type\n          - data\n        properties:\n          destination_type:\n            type: string\n            enum: [postgres, s3, api]\n          data:\n            type: array\n      output_schema:\n        type: object\n        properties:\n          loaded_rows:\n            type: integer\n\n  # Policies\n  policies:\n    compliance:\n      - soc2-type2\n      - gdpr\n    encryption: true\n    audit: true\n    pii_handling: encrypt\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://data-etl:3900\n      health: /health\n    auth:\n      type: api_key\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:3900/health\n\n  # Metadata\n  metadata:\n    author: OSSA Data Team\n    license: Apache-2.0\n    keywords:\n      - etl\n      - data\n      - analytics\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "development-agent.yml",
    "path": "spec-examples/development-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: code-generation-assistant\n  name: Code Generation & Testing Assistant\n  version: 1.0.0\n  description: |\n    AI-powered code generation agent with support for multiple languages,\n    test generation, and code review capabilities.\n  role: development\n  tags:\n    - code-generation\n    - testing\n    - code-review\n    - development\n\n  # Runtime\n  runtime:\n    type: local\n    command: ['npx', 'tsx', 'src/index.ts']\n    requirements:\n      node: '>=20.0.0'\n      packages:\n        - typescript\n        - openai\n        - prettier\n    resources:\n      cpu: '1000m'\n      memory: '1Gi'\n    health_check:\n      type: http\n      endpoint: /health\n      port: 4100\n\n  # Capabilities\n  capabilities:\n    - name: generate_code\n      description: Generate code from natural language description\n      input_schema:\n        type: object\n        required:\n          - description\n          - language\n        properties:\n          description:\n            type: string\n          language:\n            type: string\n            enum: [typescript, python, go, rust, java]\n          framework:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          code:\n            type: string\n          explanation:\n            type: string\n          tests:\n            type: string\n      timeout_seconds: 120\n\n    - name: generate_tests\n      description: Generate unit tests for existing code\n      input_schema:\n        type: object\n        required:\n          - code\n          - language\n        properties:\n          code:\n            type: string\n          language:\n            type: string\n          framework:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          test_code:\n            type: string\n          coverage_targets:\n            type: array\n\n    - name: review_code\n      description: AI-powered code review\n      input_schema:\n        type: object\n        required:\n          - code\n        properties:\n          code:\n            type: string\n          check_types:\n            type: array\n            items:\n              type: string\n      output_schema:\n        type: object\n        properties:\n          issues:\n            type: array\n          suggestions:\n            type: array\n          quality_score:\n            type: number\n\n  # Policies\n  policies:\n    compliance: []\n    encryption: false\n    audit: false\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://localhost:4100\n      health: /health\n    auth:\n      type: none\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: false\n    logs: true\n    health_check: http://localhost:4100/health\n\n  # Metadata\n  metadata:\n    author: OSSA Dev Tools Team\n    license: MIT\n    keywords:\n      - code-generation\n      - ai-assistant\n      - testing\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "edge-agent.yml",
    "path": "spec-examples/edge-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: edge-processing-agent\n  name: Edge Processing Agent\n  version: 1.0.0\n  description: |\n    Lightweight agent optimized for edge deployment with minimal\n    resource requirements and offline capabilities.\n  role: monitoring\n  tags:\n    - edge\n    - iot\n    - low-latency\n    - offline\n\n  # Runtime\n  runtime:\n    type: edge\n    image: ossa/edge-agent:1.0.0-arm64\n    requirements:\n      python: '>=3.9'\n      packages:\n        - fastapi\n        - uvicorn\n    resources:\n      cpu: '100m'\n      memory: '128Mi'\n    health_check:\n      type: http\n      endpoint: /health\n      port: 5000\n\n  # Capabilities\n  capabilities:\n    - name: process_sensor_data\n      description: Process IoT sensor data locally\n      input_schema:\n        type: object\n        required:\n          - sensor_id\n          - data\n        properties:\n          sensor_id:\n            type: string\n          data:\n            type: object\n      output_schema:\n        type: object\n        properties:\n          processed:\n            type: boolean\n          anomalies:\n            type: array\n      timeout_seconds: 5\n\n    - name: sync_to_cloud\n      description: Sync processed data to cloud when connected\n      input_schema:\n        type: object\n        properties:\n          batch_size:\n            type: integer\n            default: 100\n      output_schema:\n        type: object\n        properties:\n          synced_count:\n            type: integer\n\n  # Policies\n  policies:\n    compliance: []\n    encryption: true\n    audit: false\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://localhost:5000\n      health: /health\n    auth:\n      type: none\n\n  # Monitoring\n  monitoring:\n    traces: false\n    metrics: true\n    logs: false\n    health_check: http://localhost:5000/health\n\n  # Metadata\n  metadata:\n    author: OSSA Edge Team\n    license: Apache-2.0\n    keywords:\n      - edge\n      - iot\n      - offline\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "integration-agent.yml",
    "path": "spec-examples/integration-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: api-integration-bridge\n  name: API Integration Bridge Agent\n  version: 1.0.0\n  description: |\n    Universal API integration agent that connects external services,\n    normalizes APIs, and provides unified access layer.\n  role: integration\n  tags:\n    - integration\n    - api-bridge\n    - normalization\n    - connectivity\n\n  # Runtime\n  runtime:\n    type: docker\n    image: ossa/api-bridge:1.0.0\n    requirements:\n      node: '>=20.0.0'\n      packages:\n        - axios\n        - express\n        - swagger-client\n    resources:\n      cpu: '500m'\n      memory: '512Mi'\n    health_check:\n      type: http\n      endpoint: /health\n      port: 4000\n\n  # Capabilities\n  capabilities:\n    - name: connect_external_api\n      description: Connect and authenticate to external API\n      input_schema:\n        type: object\n        required:\n          - api_url\n          - auth_type\n        properties:\n          api_url:\n            type: string\n          auth_type:\n            type: string\n            enum: [none, api_key, oauth2, basic]\n          credentials:\n            type: object\n      output_schema:\n        type: object\n        properties:\n          connection_id:\n            type: string\n          status:\n            type: string\n\n    - name: normalize_api_response\n      description: Normalize API responses to standard format\n      input_schema:\n        type: object\n        required:\n          - raw_response\n          - schema_mapping\n        properties:\n          raw_response:\n            type: object\n          schema_mapping:\n            type: object\n      output_schema:\n        type: object\n        properties:\n          normalized_data:\n            type: object\n\n    - name: proxy_api_request\n      description: Proxy request to external API with transformation\n      input_schema:\n        type: object\n        required:\n          - target_api\n          - request\n        properties:\n          target_api:\n            type: string\n          request:\n            type: object\n      output_schema:\n        type: object\n        properties:\n          response:\n            type: object\n          latency_ms:\n            type: number\n\n  # Policies\n  policies:\n    compliance:\n      - soc2-type1\n    encryption: true\n    audit: false\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://api-bridge:4000\n      health: /health\n    auth:\n      type: api_key\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:4000/health\n\n  # Metadata\n  metadata:\n    author: OSSA Integration Team\n    license: MIT\n    keywords:\n      - api\n      - integration\n      - bridge\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "monitoring-agent.yml",
    "path": "spec-examples/monitoring-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: system-health-monitor\n  name: System Health Monitoring Agent\n  version: 1.0.0\n  description: |\n    Continuous system health monitoring with intelligent alerting\n    and auto-remediation capabilities.\n  role: monitoring\n  tags:\n    - monitoring\n    - health-checks\n    - auto-remediation\n    - alerting\n\n  # Runtime\n  runtime:\n    type: k8s\n    image: ossa/health-monitor:1.0.0\n    requirements:\n      node: '>=20.0.0'\n      packages:\n        - prom-client\n        - node-fetch\n    resources:\n      cpu: '250m'\n      memory: '256Mi'\n    health_check:\n      type: http\n      endpoint: /health\n      port: 3800\n\n  # Capabilities\n  capabilities:\n    - name: check_service_health\n      description: Check health of all OSSA services\n      input_schema:\n        type: object\n        properties:\n          services:\n            type: array\n            items:\n              type: string\n      output_schema:\n        type: object\n        properties:\n          services:\n            type: array\n            items:\n              type: object\n              properties:\n                name:\n                  type: string\n                status:\n                  type: string\n                  enum: [healthy, degraded, unhealthy]\n                latency_ms:\n                  type: number\n      timeout_seconds: 30\n\n    - name: collect_metrics\n      description: Collect system metrics\n      input_schema:\n        type: object\n        properties:\n          metric_types:\n            type: array\n            items:\n              type: string\n      output_schema:\n        type: object\n        properties:\n          metrics:\n            type: object\n      timeout_seconds: 10\n\n    - name: auto_remediate\n      description: Automatically fix common issues\n      input_schema:\n        type: object\n        required:\n          - issue_type\n        properties:\n          issue_type:\n            type: string\n          severity:\n            type: string\n      output_schema:\n        type: object\n        properties:\n          remediated:\n            type: boolean\n          actions_taken:\n            type: array\n\n  # Policies\n  policies:\n    compliance:\n      - soc2-type1\n    encryption: false\n    audit: true\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: http://health-monitor:3800\n      health: /health\n      metrics: /metrics\n    auth:\n      type: none\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:3800/health\n\n  # Metadata\n  metadata:\n    author: OSSA Monitoring Team\n    maintainer: monitoring@ossa.io\n    license: MIT\n    keywords:\n      - monitoring\n      - health\n      - metrics\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "serverless-agent.yml",
    "path": "spec-examples/serverless-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: serverless-function-agent\n  name: Serverless Function Agent\n  version: 1.0.0\n  description: |\n    Serverless agent optimized for AWS Lambda, Google Cloud Functions,\n    and Azure Functions with auto-scaling and cost optimization.\n  role: custom\n  tags:\n    - serverless\n    - lambda\n    - functions\n    - auto-scaling\n\n  # Runtime\n  runtime:\n    type: serverless\n    image: null\n    command: ['python', 'handler.py']\n    requirements:\n      python: '>=3.9'\n      packages:\n        - boto3\n        - requests\n    resources:\n      memory: '512Mi'\n    health_check:\n      type: exec\n      command: ['python', '-c', 'import handler; handler.health_check()']\n\n  # Capabilities\n  capabilities:\n    - name: process_event\n      description: Process serverless event\n      input_schema:\n        type: object\n        properties:\n          event:\n            type: object\n          context:\n            type: object\n      output_schema:\n        type: object\n        properties:\n          statusCode:\n            type: integer\n          body:\n            type: string\n      timeout_seconds: 300\n\n  # Policies\n  policies:\n    compliance:\n      - soc2-type1\n    encryption: true\n    audit: true\n\n  # Integration\n  integration:\n    protocol: http\n    endpoints:\n      base_url: https://lambda-url.amazonaws.com\n    auth:\n      type: none\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n\n  # Metadata\n  metadata:\n    author: OSSA Serverless Team\n    license: Apache-2.0\n    keywords:\n      - serverless\n      - lambda\n      - functions\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "workflow-agent.yml",
    "path": "spec-examples/workflow-agent.yml",
    "content": "ossaVersion: '1.0'\n\nagent:\n  # Identity\n  id: workflow-orchestrator\n  name: Workflow Orchestration Agent\n  version: 2.0.0\n  description: |\n    Advanced workflow orchestration agent that coordinates multi-step processes,\n    manages agent swarms, and provides intelligent task routing.\n  role: orchestration\n  tags:\n    - workflow\n    - orchestration\n    - multi-agent\n    - coordination\n\n  # Runtime\n  runtime:\n    type: k8s\n    image: ossa/workflow-orchestrator:2.0.0\n    requirements:\n      node: '>=20.0.0'\n      packages:\n        - temporal-sdk\n        - bullmq\n        - ioredis\n    resources:\n      cpu: '2000m'\n      memory: '2Gi'\n      gpu: false\n    health_check:\n      type: http\n      endpoint: /health\n      port: 3500\n\n  # Capabilities\n  capabilities:\n    - name: execute_workflow\n      description: Execute multi-step workflow\n      input_schema:\n        type: object\n        required:\n          - workflow_definition\n        properties:\n          workflow_definition:\n            type: object\n            properties:\n              name:\n                type: string\n              steps:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id:\n                      type: string\n                    agent_id:\n                      type: string\n                    capability:\n                      type: string\n                    input:\n                      type: object\n                    depends_on:\n                      type: array\n                      items:\n                        type: string\n          context:\n            type: object\n      output_schema:\n        type: object\n        properties:\n          execution_id:\n            type: string\n          status:\n            type: string\n            enum: [queued, running, completed, failed]\n          results:\n            type: array\n            items:\n              type: object\n      timeout_seconds: 3600\n      retry_policy:\n        max_attempts: 3\n        backoff: exponential\n\n    - name: spawn_agent_swarm\n      description: Spawn multiple agents to work in parallel\n      input_schema:\n        type: object\n        required:\n          - agent_count\n          - tasks\n        properties:\n          agent_count:\n            type: integer\n            minimum: 1\n            maximum: 100\n          tasks:\n            type: array\n            items:\n              type: object\n          strategy:\n            type: string\n            enum: [round-robin, capability-match, load-balanced]\n            default: load-balanced\n      output_schema:\n        type: object\n        properties:\n          swarm_id:\n            type: string\n          agents:\n            type: array\n            items:\n              type: object\n              properties:\n                agent_id:\n                  type: string\n                assigned_tasks:\n                  type: integer\n          estimated_completion:\n            type: string\n            format: date-time\n      timeout_seconds: 60\n\n    - name: coordinate_multi_agent_task\n      description: Coordinate task across multiple agents\n      input_schema:\n        type: object\n        required:\n          - task_description\n          - agents\n        properties:\n          task_description:\n            type: string\n          agents:\n            type: array\n            items:\n              type: string\n          coordination_mode:\n            type: string\n            enum: [sequential, parallel, hierarchical]\n            default: parallel\n      output_schema:\n        type: object\n        properties:\n          coordination_id:\n            type: string\n          agent_assignments:\n            type: array\n          status:\n            type: string\n\n  # Policies\n  policies:\n    compliance:\n      - soc2-type1\n    data_residency:\n      - US\n      - EU\n      - CA\n    encryption: true\n    audit: true\n    pii_handling: none\n\n  # Integration\n  integration:\n    protocol: grpc\n    endpoints:\n      base_url: workflow-orchestrator:3500\n      health: /health\n      metrics: /metrics\n      openapi: /api/docs\n    auth:\n      type: jwt\n      config:\n        issuer: https://auth.ossa.io\n        audience: workflow-orchestrator\n    rate_limits:\n      requests_per_second: 100\n      burst: 50\n\n  # Monitoring\n  monitoring:\n    traces: true\n    metrics: true\n    logs: true\n    health_check: http://localhost:3500/health\n    phoenix_arise:\n      enabled: true\n      project: ossa-workflows\n      export_interval_seconds: 30\n\n  # Dependencies\n  dependencies:\n    required:\n      - agent_id: agent-router\n        min_version: '1.0.0'\n      - agent_id: agent-protocol\n        min_version: '1.0.0'\n      - agent_id: agent-tracer\n        min_version: '1.0.0'\n    optional:\n      - agent_id: agent-brain\n        fallback: Workflows without context enrichment\n      - agent_id: compliance-engine\n        fallback: No policy validation\n\n  # Metadata\n  metadata:\n    author: OSSA Workflow Team\n    maintainer: workflows@ossa.io\n    homepage: https://ossa.io/agents/workflow-orchestrator\n    repository: https://github.com/ossa-agents/workflow-orchestrator\n    documentation: https://docs.ossa.io/agents/workflow-orchestrator\n    license: Apache-2.0\n    keywords:\n      - workflow\n      - orchestration\n      - multi-agent\n      - swarm\n      - coordination\n      - temporal\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "ossa-compliance.yaml",
    "path": "templates/ossa-compliance.yaml",
    "content": "# OSSA v0.1.9 Compliance Configuration for __ARCHIVE_REPORTS\n\napiVersion: 'open-standards-scalable-agents/v0.1.9'\nkind: 'ComplianceConfiguration'\nmetadata:\n  name: '__ARCHIVE_REPORTS-compliance'\n  description: 'OSSA Governed Tier compliance for __ARCHIVE_REPORTS'\n  version: '0.1.9'\n  tier: 'governed'\n\nspec:\n  compliance_tier: 'governed'\n\n  # OSSA v0.1.9 Requirements\n  ossa_requirements:\n    core_tier:\n      enabled: true\n      requirements:\n        - valid_agent_specification\n        - openapi_integration\n        - basic_capabilities\n        - framework_compatibility\n      validation: 'enforce'\n\n    governed_tier:\n      enabled: true\n      requirements:\n        - security_controls\n        - performance_monitoring\n        - health_checks\n        - audit_logging\n        - compliance_reporting\n      validation: 'enforce'\n\n    advanced_tier:\n      enabled: false # Future upgrade\n\n  # Validation Rules\n  validation_rules:\n    agent_specifications:\n      required_fields: ['agentId', 'agentType', 'version', 'capabilities']\n      format_validation: true\n      schema_validation: true\n\n    openapi_specifications:\n      version: '3.1.0'\n      required_sections: ['info', 'paths', 'components']\n      security_requirements: true\n      error_handling: true\n\n  # Compliance Monitoring\n  monitoring:\n    automated_validation: true\n    ci_cd_integration: true\n    compliance_reporting: true\n    alerting: true\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "demo-registry.ts",
    "path": "typescript/advanced/demo-registry.ts",
    "content": "#!/usr/bin/env tsx\n/**\n * OSSA REGISTRY-CORE Demonstration Script\n *\n * This demonstrates the complete REGISTRY-CORE implementation for\n * the OSSA Platform v0.1.9-alpha.1, showcasing:\n *\n * ✅ Global agent registry with ACDL validation\n * ✅ Advanced capability matching algorithms\n * ✅ Production-scale health monitoring\n * ✅ Multi-tenant agent discovery\n * ✅ RESTful API with authentication\n */\n\nimport { RegistryService } from './src/core/registry/index.js';\n\nconsole.log('🏛️  OSSA REGISTRY-CORE v0.1.9-alpha.1');\nconsole.log('🎯 Production Agent Registry & Discovery Service');\nconsole.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');\nconsole.log('');\n\nconsole.log('📋 IMPLEMENTATION STATUS:');\nconsole.log('✅ Global agent registry with ACDL integration');\nconsole.log('✅ Advanced capability matching with semantic analysis');\nconsole.log('✅ Production-scale health monitoring system');\nconsole.log('✅ Multi-tenant isolation and federation');\nconsole.log('✅ RESTful API with rate limiting and auth');\nconsole.log('✅ Comprehensive metrics and observability');\nconsole.log('');\n\nconsole.log('🎯 KEY FEATURES IMPLEMENTED:');\nconsole.log('');\nconsole.log('🔧 REGISTRY-CORE Components:');\nconsole.log('   📦 registry-core.ts      - Main registry orchestration');\nconsole.log('   🧠 capability-matcher.ts - Advanced matching algorithms');\nconsole.log('   ❤️  health-monitor.ts     - Lifecycle & health management');\nconsole.log('   🌐 registry-api.ts       - Production-scale REST API');\nconsole.log('   📋 index.ts              - Service factory & integration');\nconsole.log('');\n\nconsole.log('🔍 CAPABILITY MATCHING:');\nconsole.log('   • Direct domain matching with scoring');\nconsole.log('   • Semantic similarity using relationship graphs');\nconsole.log('   • Performance compatibility assessment');\nconsole.log('   • Multi-dimensional agent ranking');\nconsole.log('   • Intelligent ensemble composition');\nconsole.log('');\n\nconsole.log('❤️  HEALTH MONITORING:');\nconsole.log('   • Real-time endpoint health checks');\nconsole.log('   • SLA violation tracking');\nconsole.log('   • Performance trend analysis');\nconsole.log('   • Automatic state transitions');\nconsole.log('   • Comprehensive lifecycle management');\nconsole.log('');\n\nconsole.log('🌐 PRODUCTION API FEATURES:');\nconsole.log('   • Bearer token authentication');\nconsole.log('   • Rate limiting (1000 req/min default)');\nconsole.log('   • Multi-tenant isolation');\nconsole.log('   • CORS support for web integration');\nconsole.log('   • Comprehensive error handling');\nconsole.log('   • Real-time metrics and monitoring');\nconsole.log('');\n\nconsole.log('📊 API ENDPOINTS IMPLEMENTED:');\nconsole.log(\n  '   POST /api/v1/agents/register           - Register agents with ACDL'\n);\nconsole.log(\n  '   POST /api/v1/discovery/query           - Discover agents by capability'\n);\nconsole.log(\n  '   POST /api/v1/matching/request          - Match agents for tasks'\n);\nconsole.log(\n  '   POST /api/v1/matching/rank             - Rank agent candidates'\n);\nconsole.log(\n  '   POST /api/v1/matching/ensemble         - Compose multi-agent ensembles'\n);\nconsole.log(\n  '   GET  /api/v1/agents/:id/health         - Get agent health status'\n);\nconsole.log('   POST /api/v1/agents/:id/health         - Update agent health');\nconsole.log(\n  '   POST /api/v1/agents/:id/state          - Manage agent lifecycle'\n);\nconsole.log(\n  '   GET  /api/v1/registry/metrics          - Registry performance metrics'\n);\nconsole.log(\n  '   GET  /api/v1/tenants/:id/agents        - Tenant-scoped agent listing'\n);\nconsole.log('');\n\nconsole.log('🔧 INTEGRATION WITH OSSA PLATFORM:');\nconsole.log('   ✅ SPEC-AUTHORITY validator integration');\nconsole.log('   ✅ ACDL manifest validation');\nconsole.log('   ✅ OSSA v0.1.9-alpha.1 compliance');\nconsole.log('   ✅ 360° feedback loop support');\nconsole.log('   ✅ Budget and governance integration');\nconsole.log('');\n\nconsole.log('⚡ PERFORMANCE OPTIMIZATIONS:');\nconsole.log('   • In-memory indexing for O(1) lookups');\nconsole.log('   • Capability relationship graphs');\nconsole.log('   • Concurrent health checks');\nconsole.log('   • Efficient scoring algorithms');\nconsole.log('   • Connection pooling and caching');\nconsole.log('');\n\nconsole.log('🏢 ENTERPRISE FEATURES:');\nconsole.log('   • Multi-tenant namespace isolation');\nconsole.log('   • Role-based access control');\nconsole.log('   • Audit logging and compliance');\nconsole.log('   • High availability design');\nconsole.log('   • Horizontal scaling support');\nconsole.log('');\n\nconsole.log('💡 USAGE EXAMPLES:');\nconsole.log('');\nconsole.log('# Start Registry Service:');\nconsole.log('npm run registry:start');\nconsole.log('');\nconsole.log('# Test Agent Registration:');\nconsole.log('npm run registry:test');\nconsole.log('');\nconsole.log('# Check Service Status:');\nconsole.log('npm run registry:status');\nconsole.log('');\nconsole.log('# View Registry Metrics:');\nconsole.log('npm run registry:metrics');\nconsole.log('');\n\nconsole.log('🚀 PRODUCTION DEPLOYMENT:');\nconsole.log('');\nconsole.log(\n  'The REGISTRY-CORE service is designed for production deployment with:'\n);\nconsole.log('• Docker containerization support');\nconsole.log('• Kubernetes orchestration compatibility');\nconsole.log('• Load balancer integration');\nconsole.log('• External storage backend support');\nconsole.log('• Comprehensive monitoring and alerting');\nconsole.log('');\n\nconsole.log('📖 ARCHITECTURE COMPLIANCE:');\nconsole.log('');\nconsole.log('This implementation follows OSSA v0.1.9-alpha.1 specifications:');\nconsole.log('• Agent taxonomy and capability domains');\nconsole.log('• ACDL (Agent Capability Description Language) standards');\nconsole.log('• Production runtime patterns');\nconsole.log('• Multi-protocol agent communication');\nconsole.log('• Enterprise governance and compliance');\nconsole.log('');\n\nconsole.log('✨ READY FOR INTEGRATION!');\nconsole.log('');\nconsole.log(\n  'The REGISTRY-CORE is fully implemented and ready to be integrated'\n);\nconsole.log('with other OSSA Platform agents like ORCHESTRATOR-PLATFORM,');\nconsole.log('SPEC-AUTHORITY, and COMPLIANCE-ENGINE.');\nconsole.log('');\n\nconsole.log('🎉 REGISTRY-CORE DEMONSTRATION COMPLETE');\nconsole.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "mcpb-agent-example.ts",
    "path": "typescript/mcpb-agent-example.ts",
    "content": "/**\n * OSSA Agent with MCPB Integration - TypeScript Example\n *\n * This example demonstrates how to create OSSA agents with various bridge configurations\n * including MCP (Model Context Protocol) Bridge for Claude Desktop integration.\n */\n\nimport type {\n  Agent,\n  CreateAgentRequest,\n  BridgeConfig,\n  MCPBridgeConfig,\n  MCPTool,\n  MCPResource,\n  MCPPrompt,\n} from '../../src/server/types/agent';\n\n// Example 1: Create an MCP-enabled agent for Claude Desktop\nexport const createMCPAgent = (): CreateAgentRequest => {\n  return {\n    type: 'worker',\n    name: 'Code Analysis Agent',\n    description: 'Analyzes source code and provides feedback',\n    version: '1.0.0',\n    capabilities: ['code-analysis', 'static-analysis', 'security-scanning'],\n    configuration: {\n      max_file_size_mb: 10,\n      supported_languages: ['typescript', 'javascript', 'python', 'go'],\n    },\n    metadata: {\n      author: 'OSSA Team',\n      tags: ['code', 'analysis', 'mcp'],\n      documentation_url: 'https://docs.example.com/code-analysis-agent',\n    },\n    bridge: {\n      mcp: {\n        enabled: true,\n        server_type: 'stdio', // For Claude Desktop\n        tools: [\n          {\n            name: 'analyze_code',\n            description:\n              'Analyze source code for issues, bugs, and security vulnerabilities',\n            input_schema: {\n              type: 'object',\n              properties: {\n                code: {\n                  type: 'string',\n                  description: 'The source code to analyze',\n                },\n                language: {\n                  type: 'string',\n                  enum: ['typescript', 'javascript', 'python', 'go'],\n                  description: 'Programming language',\n                },\n                rules: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Specific rules to check',\n                },\n              },\n              required: ['code', 'language'],\n            },\n            output_schema: {\n              type: 'object',\n              properties: {\n                issues: {\n                  type: 'array',\n                  items: {\n                    type: 'object',\n                    properties: {\n                      severity: {\n                        type: 'string',\n                        enum: ['error', 'warning', 'info'],\n                      },\n                      line: { type: 'number' },\n                      message: { type: 'string' },\n                      rule: { type: 'string' },\n                    },\n                  },\n                },\n                summary: {\n                  type: 'object',\n                  properties: {\n                    total_issues: { type: 'number' },\n                    errors: { type: 'number' },\n                    warnings: { type: 'number' },\n                  },\n                },\n              },\n            },\n            capability: 'code-analysis',\n          },\n          {\n            name: 'suggest_fixes',\n            description: 'Suggest fixes for identified code issues',\n            input_schema: {\n              type: 'object',\n              properties: {\n                issue_id: { type: 'string' },\n                context: { type: 'string' },\n              },\n              required: ['issue_id'],\n            },\n            capability: 'code-analysis',\n          },\n        ],\n        resources: [\n          {\n            uri: 'ossa://code-analysis/results',\n            name: 'Analysis Results',\n            description: 'Access to previous analysis results',\n            mimeType: 'application/json',\n            readonly: true,\n          },\n          {\n            uri: 'ossa://code-analysis/rules',\n            name: 'Analysis Rules',\n            description: 'Code analysis rules and configurations',\n            mimeType: 'application/json',\n            readonly: false,\n          },\n        ],\n        prompts: [\n          {\n            name: 'review_pr',\n            description: 'Review a pull request',\n            template: `Review the following {{language}} code changes:\n\n{{diff}}\n\nFocus on:\n- Code quality\n- Potential bugs\n- Security issues\n- Best practices\n\nProvide specific, actionable feedback.`,\n            arguments: [\n              { name: 'language', type: 'string', required: true },\n              { name: 'diff', type: 'string', required: true },\n            ],\n          },\n          {\n            name: 'explain_issue',\n            description: 'Explain a code issue in detail',\n            template:\n              'Explain the following code issue:\\n\\n{{issue}}\\n\\nInclude examples of how to fix it.',\n            arguments: [{ name: 'issue', type: 'string', required: true }],\n          },\n        ],\n        config: {\n          max_message_size: 1048576, // 1MB\n          timeout_ms: 30000, // 30 seconds\n          retry_count: 3,\n        },\n      },\n    },\n  };\n};\n\n// Example 2: Multi-bridge agent (MCP + LangChain)\nexport const createMultiBridgeAgent = (): CreateAgentRequest => {\n  return {\n    type: 'orchestrator',\n    name: 'Multi-Protocol Orchestrator',\n    version: '1.0.0',\n    capabilities: ['orchestration', 'workflow-execution', 'integration'],\n    configuration: {},\n    bridge: {\n      // Enable MCP for Claude Desktop\n      mcp: {\n        enabled: true,\n        server_type: 'websocket',\n        tools: [\n          {\n            name: 'execute_workflow',\n            description: 'Execute a multi-step workflow',\n            capability: 'workflow-execution',\n          },\n        ],\n      },\n      // Enable LangChain for Python integration\n      langchain: {\n        enabled: true,\n        tool_class: 'OSSAWorkflowTool',\n        chain_type: 'agent',\n        memory: {\n          type: 'conversation',\n          max_tokens: 4096,\n        },\n        export: {\n          as_tool: true,\n          as_chain: true,\n          as_agent: false,\n        },\n      },\n      // Enable OpenAPI for REST integration\n      openapi: {\n        enabled: true,\n        spec_url: 'https://api.example.com/openapi.json',\n        spec_version: '3.1',\n        auto_generate: false,\n      },\n    },\n  };\n};\n\n// Example 3: Helper function to create MCP tools from OSSA capabilities\nexport const createMCPToolsFromCapabilities = (\n  capabilities: string[]\n): MCPTool[] => {\n  return capabilities.map((capability) => ({\n    name: capability.replace(/-/g, '_'),\n    description: `Execute ${capability} capability`,\n    capability,\n  }));\n};\n\n// Example 4: Validate MCP configuration\nexport const validateMCPConfig = (config: MCPBridgeConfig): boolean => {\n  if (!config.enabled) {\n    return false;\n  }\n\n  // Check transport type\n  if (\n    config.server_type &&\n    !['stdio', 'sse', 'websocket'].includes(config.server_type)\n  ) {\n    throw new Error(`Invalid MCP server type: ${config.server_type}`);\n  }\n\n  // Validate tools\n  if (config.tools) {\n    for (const tool of config.tools) {\n      if (!tool.name || !tool.description) {\n        throw new Error('MCP tools must have name and description');\n      }\n    }\n  }\n\n  // Validate resources\n  if (config.resources) {\n    for (const resource of config.resources) {\n      if (!resource.uri || !resource.name) {\n        throw new Error('MCP resources must have uri and name');\n      }\n    }\n  }\n\n  return true;\n};\n\n// Example 5: Create an agent with custom bridge\nexport const createCustomBridgeAgent = (): CreateAgentRequest => {\n  return {\n    type: 'worker',\n    name: 'Custom Bridge Agent',\n    version: '1.0.0',\n    capabilities: ['custom-integration'],\n    configuration: {},\n    bridge: {\n      mcp: {\n        enabled: true,\n        server_type: 'stdio',\n      },\n      custom: {\n        my_protocol: {\n          enabled: true,\n          endpoint: 'wss://custom.example.com',\n          features: ['streaming', 'bidirectional'],\n        },\n      },\n    },\n  };\n};\n\n// Example 6: Runtime bridge configuration\nexport class AgentBridgeManager {\n  private agent: Agent;\n\n  constructor(agent: Agent) {\n    this.agent = agent;\n  }\n\n  isMCPEnabled(): boolean {\n    return this.agent.bridge?.mcp?.enabled ?? false;\n  }\n\n  getMCPTransport(): 'stdio' | 'sse' | 'websocket' | undefined {\n    return this.agent.bridge?.mcp?.server_type;\n  }\n\n  getMCPTools(): MCPTool[] {\n    return this.agent.bridge?.mcp?.tools ?? [];\n  }\n\n  getMCPResources(): MCPResource[] {\n    return this.agent.bridge?.mcp?.resources ?? [];\n  }\n\n  getMCPPrompts(): MCPPrompt[] {\n    return this.agent.bridge?.mcp?.prompts ?? [];\n  }\n\n  getSupportedBridges(): string[] {\n    const bridges: string[] = [];\n    if (this.agent.bridge?.mcp?.enabled) bridges.push('mcp');\n    if (this.agent.bridge?.openapi?.enabled) bridges.push('openapi');\n    if (this.agent.bridge?.langchain?.enabled) bridges.push('langchain');\n    if (this.agent.bridge?.crewai?.enabled) bridges.push('crewai');\n    if (this.agent.bridge?.autogen?.enabled) bridges.push('autogen');\n    if (this.agent.bridge?.a2a?.enabled) bridges.push('a2a');\n    return bridges;\n  }\n\n  isMultiBridge(): boolean {\n    return this.getSupportedBridges().length > 1;\n  }\n}\n\n// Example 7: Usage example\nexport const exampleUsage = () => {\n  // Create an MCP agent\n  const mcpAgentRequest = createMCPAgent();\n  console.log(\n    'MCP Agent Configuration:',\n    JSON.stringify(mcpAgentRequest, null, 2)\n  );\n\n  // Create a multi-bridge agent\n  const multiBridgeRequest = createMultiBridgeAgent();\n  console.log(\n    'Multi-Bridge Agent:',\n    JSON.stringify(multiBridgeRequest, null, 2)\n  );\n\n  // Validate MCP configuration\n  const mcpConfig: MCPBridgeConfig = {\n    enabled: true,\n    server_type: 'stdio',\n    tools: [{ name: 'test_tool', description: 'Test tool' }],\n  };\n  const isValid = validateMCPConfig(mcpConfig);\n  console.log('MCP Config Valid:', isValid);\n};\n\n// Export types for use in other modules\nexport type {\n  Agent,\n  CreateAgentRequest,\n  BridgeConfig,\n  MCPBridgeConfig,\n  MCPTool,\n  MCPResource,\n  MCPPrompt,\n};\n",
    "category": "Spec Examples & Templates"
  },
  {
    "name": "edge-agent.ossa.json",
    "path": "vercel/edge-agent.ossa.json",
    "content": "{\n  \"apiVersion\": \"ossa/v0.2\",\n  \"kind\": \"Agent\",\n  \"metadata\": {\n    \"name\": \"edge-chat-agent\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Vercel AI SDK edge runtime agent\"\n  },\n  \"spec\": {\n    \"role\": \"You are a helpful AI assistant running on Vercel Edge.\",\n    \"llm\": {\n      \"provider\": \"openai\",\n      \"model\": \"gpt-4\",\n      \"temperature\": 0.7\n    },\n    \"tools\": []\n  },\n  \"extensions\": {\n    \"vercel_ai\": {\n      \"enabled\": true,\n      \"runtime\": \"edge\",\n      \"stream\": true,\n      \"route\": \"/api/chat\",\n      \"tools\": [\n        {\n          \"name\": \"get_weather\",\n          \"description\": \"Get current weather for a location\",\n          \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"location\": {\n                \"type\": \"string\",\n                \"description\": \"City name\"\n              }\n            },\n            \"required\": [\"location\"]\n          }\n        }\n      ]\n    }\n  }\n}\n\n",
    "category": "Framework Integration"
  }
]