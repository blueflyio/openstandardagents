FROM node:20-alpine

# Install system dependencies
RUN apk add --no-cache \
    wget \
    curl \
    bash \
    git \
    openssl \
    ca-certificates

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install root dependencies
RUN npm install || true

# Copy source code
COPY . .

# Install and build the CLI package
WORKDIR /app/src/cli
RUN npm install && npm run build

# Return to app root
WORKDIR /app

# Create security agent startup script
RUN cat > /app/start-security-agent.sh << 'EOF'
#!/bin/bash
echo "ðŸ”’ Starting OSSA Security Agent v0.1.8..."

# Start the security agent service
node -e "
const express = require('express');
const crypto = require('crypto');
const fs = require('fs');

const app = express();
app.use(express.json());

// Security state
const auditLogs = [];
const securityEvents = [];
const encryptionKeys = new Map();
const accessTokens = new Map();

// Health endpoint
app.get('/health', (req, res) => {
  res.json({
    service: 'security-agent',
    status: 'healthy',
    version: '0.1.8',
    agent_type: 'security',
    active_sessions: accessTokens.size,
    audit_log_entries: auditLogs.length,
    security_events: securityEvents.length,
    timestamp: new Date().toISOString()
  });
});

// Agent capabilities endpoint
app.get('/capabilities', (req, res) => {
  res.json({
    agent_type: 'security',
    capabilities: [
      'authentication',
      'authorization',
      'encryption',
      'audit_logging',
      'compliance_checking',
      'threat_detection',
      'access_control'
    ],
    security_features: [
      'JWT_tokens',
      'AES_256_encryption',
      'RSA_key_generation',
      'audit_trails',
      'role_based_access'
    ],
    compliance_standards: ['SOC2', 'GDPR', 'HIPAA', 'PCI-DSS'],
    endpoints: {
      authenticate: '/auth',
      encrypt: '/encrypt',
      decrypt: '/decrypt',
      audit: '/audit',
      compliance: '/compliance'
    }
  });
});

// Authentication endpoint
app.post('/auth', async (req, res) => {
  try {
    const { username, password, agent_id } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({ error: 'username and password required' });
    }
    
    // Mock authentication (in production, verify against secure store)
    const isValid = password === 'ossa-secure-' + username;
    
    if (!isValid) {
      // Log failed attempt
      auditLogs.push({
        timestamp: new Date().toISOString(),
        event: 'authentication_failed',
        username,
        agent_id,
        ip: req.ip,
        severity: 'warning'
      });
      
      return res.status(401).json({ error: 'Authentication failed' });
    }
    
    // Generate access token
    const tokenId = 'token-' + Date.now();
    const token = crypto.randomBytes(32).toString('hex');
    
    accessTokens.set(tokenId, {
      token,
      username,
      agent_id,
      created_at: new Date().toISOString(),
      expires_at: new Date(Date.now() + 3600000).toISOString(), // 1 hour
      permissions: ['read', 'write', 'execute']
    });
    
    // Log successful authentication
    auditLogs.push({
      timestamp: new Date().toISOString(),
      event: 'authentication_success',
      username,
      agent_id,
      token_id: tokenId,
      ip: req.ip,
      severity: 'info'
    });
    
    res.json({
      status: 'authenticated',
      token_id: tokenId,
      access_token: token,
      expires_in: 3600,
      permissions: ['read', 'write', 'execute'],
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Token validation middleware
const validateToken = (req, res, next) => {
  const authHeader = req.header('Authorization');
  const token = authHeader && authHeader.startsWith('Bearer ') ? 
    authHeader.substring(7) : null;
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  // Find token in storage
  const tokenData = Array.from(accessTokens.values()).find(t => t.token === token);
  
  if (!tokenData || new Date() > new Date(tokenData.expires_at)) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
  
  req.tokenData = tokenData;
  next();
};

// Encrypt data endpoint
app.post('/encrypt', validateToken, async (req, res) => {
  try {
    const { data, algorithm } = req.body;
    
    if (!data) {
      return res.status(400).json({ error: 'data required' });
    }
    
    const encryptionAlgorithm = algorithm || 'aes-256-gcm';
    const key = crypto.randomBytes(32);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipher(encryptionAlgorithm, key);
    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const keyId = 'key-' + Date.now();
    encryptionKeys.set(keyId, {
      key: key.toString('hex'),
      iv: iv.toString('hex'),
      algorithm: encryptionAlgorithm,
      created_at: new Date().toISOString(),
      created_by: req.tokenData.username
    });
    
    // Log encryption event
    auditLogs.push({
      timestamp: new Date().toISOString(),
      event: 'data_encrypted',
      key_id: keyId,
      algorithm: encryptionAlgorithm,
      user: req.tokenData.username,
      severity: 'info'
    });
    
    res.json({
      status: 'encrypted',
      key_id: keyId,
      encrypted_data: encrypted,
      algorithm: encryptionAlgorithm,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Decrypt data endpoint
app.post('/decrypt', validateToken, async (req, res) => {
  try {
    const { encrypted_data, key_id } = req.body;
    
    if (!encrypted_data || !key_id) {
      return res.status(400).json({ error: 'encrypted_data and key_id required' });
    }
    
    const keyData = encryptionKeys.get(key_id);
    if (!keyData) {
      return res.status(404).json({ error: 'Encryption key not found' });
    }
    
    const key = Buffer.from(keyData.key, 'hex');
    const decipher = crypto.createDecipher(keyData.algorithm, key);
    
    let decrypted = decipher.update(encrypted_data, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    // Log decryption event
    auditLogs.push({
      timestamp: new Date().toISOString(),
      event: 'data_decrypted',
      key_id,
      user: req.tokenData.username,
      severity: 'info'
    });
    
    res.json({
      status: 'decrypted',
      data: JSON.parse(decrypted),
      key_id,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Audit log endpoint
app.get('/audit', validateToken, (req, res) => {
  try {
    const { event_type, severity, limit } = req.query;
    
    let filteredLogs = auditLogs;
    
    if (event_type) {
      filteredLogs = filteredLogs.filter(log => log.event === event_type);
    }
    
    if (severity) {
      filteredLogs = filteredLogs.filter(log => log.severity === severity);
    }
    
    const limitNum = parseInt(limit) || 100;
    filteredLogs = filteredLogs.slice(-limitNum);
    
    res.json({
      audit_logs: filteredLogs,
      total: filteredLogs.length,
      filters: { event_type, severity, limit: limitNum },
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Compliance check endpoint
app.post('/compliance', validateToken, async (req, res) => {
  try {
    const { standard, scope } = req.body;
    
    if (!standard) {
      return res.status(400).json({ error: 'standard required' });
    }
    
    // Mock compliance check
    const complianceResult = {
      standard,
      scope: scope || 'full',
      status: 'compliant',
      score: Math.floor(Math.random() * 20) + 80, // 80-100%
      checks_performed: [
        { name: 'Data Encryption', status: 'pass', severity: 'high' },
        { name: 'Access Controls', status: 'pass', severity: 'high' },
        { name: 'Audit Logging', status: 'pass', severity: 'medium' },
        { name: 'User Authentication', status: 'pass', severity: 'high' }
      ],
      recommendations: [],
      checked_at: new Date().toISOString(),
      valid_until: new Date(Date.now() + 86400000).toISOString() // 24 hours
    };
    
    // Log compliance check
    auditLogs.push({
      timestamp: new Date().toISOString(),
      event: 'compliance_check',
      standard,
      score: complianceResult.score,
      user: req.tokenData.username,
      severity: 'info'
    });
    
    res.json({
      status: 'compliance_checked',
      result: complianceResult,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Security dashboard
app.get('/dashboard', validateToken, (req, res) => {
  const recentEvents = auditLogs.slice(-10);
  const eventCounts = {};
  
  auditLogs.forEach(log => {
    eventCounts[log.event] = (eventCounts[log.event] || 0) + 1;
  });
  
  res.json({
    security_overview: {
      active_sessions: accessTokens.size,
      total_audit_events: auditLogs.length,
      encryption_keys_managed: encryptionKeys.size,
      recent_events: recentEvents.length
    },
    event_summary: eventCounts,
    security_status: 'secure',
    last_compliance_check: new Date().toISOString(),
    timestamp: new Date().toISOString()
  });
});

// Cleanup expired tokens periodically
setInterval(() => {
  const now = new Date();
  for (const [tokenId, tokenData] of accessTokens) {
    if (now > new Date(tokenData.expires_at)) {
      accessTokens.delete(tokenId);
      
      auditLogs.push({
        timestamp: new Date().toISOString(),
        event: 'token_expired',
        token_id: tokenId,
        username: tokenData.username,
        severity: 'info'
      });
    }
  }
}, 300000); // Every 5 minutes

const port = process.env.SERVICE_PORT || 3009;
app.listen(port, '0.0.0.0', () => {
  console.log('âœ… Security Agent running on port ' + port);
});
"

EOF

# Make startup script executable
RUN chmod +x /app/start-security-agent.sh

# Create security directories
RUN mkdir -p /app/security-data /app/audit-logs

# Expose port
EXPOSE 3009

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:3009/health || exit 1

# Start security agent service
CMD ["/app/start-security-agent.sh"]