# Enhanced Golden CI Workflow with Agent Orchestration & Buildkit Commands
# Version: 0.1.9 - Full Tool Utilization Edition
#
# ‚ö†Ô∏è NOTE: This is an ADVANCED EXAMPLE template showing full capabilities
# For production use, use template.yml which is the official component template
# This file demonstrates how to leverage all available tools:
# - buildkit (agent-buildkit) for agent orchestration
# - ops for deployment management
# - OSSA CLI for compliance validation
#
# To use this template instead of the basic one:
# include:
#   - local: .gitlab/components/workflow/golden/enhanced-template.yml

workflow:
  rules:
    # Development branch - primary work branch
    - if: '$CI_COMMIT_BRANCH == "development"'
      variables:
        PIPELINE_TYPE: "development"
        ENABLE_AGENTS: "true"
        ORCHESTRATION_MODE: "full"
        
    # Feature branches - auto-flow to development
    - if: '$CI_COMMIT_BRANCH =~ /^feature\/.*$/'
      variables:
        PIPELINE_TYPE: "feature"
        AUTO_MERGE_TO_DEV: "true"
        TAG_TYPE: "pre-release"
        
    # Bug fix branches  
    - if: '$CI_COMMIT_BRANCH =~ /^bug\/.*$/'
      variables:
        PIPELINE_TYPE: "bugfix"
        PRIORITY: "high"
        AUTO_MERGE_TO_DEV: "true"
        
    # Hotfix branches - direct to main
    - if: '$CI_COMMIT_BRANCH =~ /^hotfix\/.*$/'
      variables:
        PIPELINE_TYPE: "hotfix"
        PRIORITY: "critical"
        TARGET_BRANCH: "main"
        
    # Release branches
    - if: '$CI_COMMIT_BRANCH =~ /^release\/v\d+\.\d+\.\d+$/'
      variables:
        PIPELINE_TYPE: "release"
        ENABLE_FULL_VALIDATION: "true"
        
    # Main branch - production only
    - if: '$CI_COMMIT_BRANCH == "main"'
      variables:
        PIPELINE_TYPE: "production"
        MANUAL_RELEASE_REQUIRED: "true"

stages:
  - orchestrate      # Agent orchestration & planning
  - validate         # Branch & compliance validation
  - build           # Build artifacts
  - test            # Comprehensive testing
  - security        # Security scanning
  - quality         # Quality gates
  - integrate       # Integration & merge
  - release         # Release management
  - deploy          # Deployment
  - cleanup         # Branch & resource cleanup

variables:
  # Tool Configuration
  BUILDKIT_CLI: "buildkit"  # Short form of agent-buildkit
  AGENT_BUILDKIT_CLI: "agent-buildkit"  # Full form
  OPS_CLI: "ops"
  OSSA_CLI: "node /Users/flux423/Sites/LLM/OSSA/dist/cli/index.js"
  
  # Agent Configuration
  MAX_AGENTS: "5"
  AGENT_TIMEOUT: "300"
  
  # Branch Limits
  MAX_FEATURE_BRANCHES: "5"
  MAX_BUG_BRANCHES: "3"
  BRANCH_AGE_LIMIT: "30d"
  
  # Version Detection Priority
  VERSION_SOURCES: "package.json,composer.json,pyproject.toml,.version"

# ============================================
# STAGE 1: ORCHESTRATION - Agent Coordination
# ============================================

orchestrate:agents:
  stage: orchestrate
  image: node:20-alpine
  before_script:
    - apk add --no-cache git jq curl bash
    - npm install -g @bluefly/agent-build-kit@latest 2>/dev/null || true
  script:
    - |
      echo "ü§ñ Orchestrating agents for pipeline type: $PIPELINE_TYPE"
      
      # Detect project type and requirements
      PROJECT_TYPE="unknown"
      if [ -f "package.json" ]; then
        PROJECT_TYPE="nodejs"
      elif [ -f "composer.json" ]; then
        PROJECT_TYPE="drupal"
      elif [ -f "pyproject.toml" ]; then
        PROJECT_TYPE="python"
      fi
      
      echo "PROJECT_TYPE=$PROJECT_TYPE" >> orchestration.env
      
      # Spawn appropriate agents based on pipeline type
      case "$PIPELINE_TYPE" in
        "feature")
          echo "Spawning feature development agents..."
          $BUILDKIT_CLI agents spawn tdd-enforcer --task "Validate TDD compliance"
          $BUILDKIT_CLI agents spawn api-first-architect --task "Check API specifications"
          $BUILDKIT_CLI agents spawn typescript-specialist --task "TypeScript validation"
          ;;
        "bugfix")
          echo "Spawning bug fix agents..."
          $BUILDKIT_CLI agents spawn test-automation-engineer --task "Create regression tests"
          $BUILDKIT_CLI agents spawn code-quality-critic --task "Review fix quality"
          ;;
        "release")
          echo "Spawning release agents..."
          $BUILDKIT_CLI agents spawn ossa-compliance-validator --task "Validate OSSA compliance"
          $BUILDKIT_CLI agents spawn security-audit-specialist --task "Security audit"
          $BUILDKIT_CLI agents spawn documentation-curator --task "Update documentation"
          ;;
        "production")
          echo "Spawning production agents..."
          $BUILDKIT_CLI agents spawn performance-optimizer --task "Performance validation"
          $BUILDKIT_CLI agents spawn monitoring-observability-engineer --task "Setup monitoring"
          ;;
      esac
      
      # Use OSSA orchestrator for complex workflows
      if [ "$ORCHESTRATION_MODE" = "full" ]; then
        echo "Launching OSSA orchestrator for comprehensive coordination..."
        $OSSA_CLI orchestrator spawn --workflow "$PIPELINE_TYPE" || true
      fi
      
      echo "‚úÖ Agent orchestration complete"
  artifacts:
    reports:
      dotenv: orchestration.env
    paths:
      - orchestration.env
  rules:
    - when: always

# ============================================
# STAGE 2: VALIDATION - Branch & Compliance
# ============================================

validate:branch:
  stage: validate
  image: node:20-alpine
  needs: ["orchestrate:agents"]
  before_script:
    - apk add --no-cache git jq
    - npm install -g @bluefly/agent-build-kit@latest 2>/dev/null || true
  script:
    - |
      echo "üåø Validating branch strategy..."
      
      # Use buildkit branch management
      $AGENT_BUILDKIT_CLI branch validate --current "$CI_COMMIT_BRANCH" || true
      
      # Count active branches by type
      FEATURE_COUNT=$(git ls-remote --heads origin 'refs/heads/feature/*' | wc -l)
      BUG_COUNT=$(git ls-remote --heads origin 'refs/heads/bug/*' | wc -l)
      
      echo "Active branches: $FEATURE_COUNT features, $BUG_COUNT bugs"
      
      # Enforce branch limits
      if [ "$FEATURE_COUNT" -gt "$MAX_FEATURE_BRANCHES" ]; then
        echo "‚ö†Ô∏è Too many feature branches ($FEATURE_COUNT > $MAX_FEATURE_BRANCHES)"
        echo "Running cleanup agent..."
        $BUILDKIT_CLI agents spawn git-branch-management-specialist \
          --task "Cleanup stale feature branches older than $BRANCH_AGE_LIMIT"
      fi
      
      # Validate branch naming
      case "$CI_COMMIT_BRANCH" in
        feature/*|bug/*|hotfix/*|chore/*|docs/*|test/*|perf/*|ci/*)
          echo "‚úÖ Valid branch name pattern"
          ;;
        development|main)
          echo "‚úÖ Protected branch"
          ;;
        *)
          echo "‚ùå Invalid branch name: $CI_COMMIT_BRANCH"
          exit 1
          ;;
      esac
  rules:
    - if: '$CI_COMMIT_BRANCH != "main"'

validate:version:
  stage: validate
  image: node:20-alpine
  needs: ["orchestrate:agents"]
  script:
    - |
      echo "üì¶ Auto-detecting version..."
      
      # Use buildkit version detection
      VERSION=$($AGENT_BUILDKIT_CLI version detect --sources "$VERSION_SOURCES" 2>/dev/null || echo "0.0.1")
      
      # Fallback to manual detection
      if [ "$VERSION" = "0.0.1" ]; then
        for source in package.json composer.json pyproject.toml; do
          if [ -f "$source" ]; then
            case "$source" in
              package.json)
                VERSION=$(node -p "require('./package.json').version" 2>/dev/null || true)
                ;;
              composer.json)
                VERSION=$(jq -r .version composer.json 2>/dev/null || true)
                ;;
              pyproject.toml)
                VERSION=$(grep -Po '^version\s*=\s*"\K[^"]*' pyproject.toml 2>/dev/null || true)
                ;;
            esac
            [ -n "$VERSION" ] && break
          fi
        done
      fi
      
      echo "PROJECT_VERSION=$VERSION" >> version.env
      echo "‚úÖ Version detected: $VERSION"
  artifacts:
    reports:
      dotenv: version.env

validate:ossa:
  stage: validate
  image: node:20-alpine
  needs: ["validate:version"]
  script:
    - |
      echo "üîç Validating OSSA compliance..."
      
      # Run OSSA compliance check
      $OSSA_CLI compliance validate --version "$OSSA_VERSION" || true
      
      # Check for required OSSA files
      REQUIRED_FILES=".agents/registry.yml specs/openapi/openapi.yml"
      for file in $REQUIRED_FILES; do
        if [ ! -f "$file" ]; then
          echo "‚ö†Ô∏è Missing OSSA required file: $file"
        fi
      done
      
      # Validate agent definitions
      if [ -d ".agents" ]; then
        $BUILDKIT_CLI agents validate --directory .agents || true
      fi
      
      echo "‚úÖ OSSA validation complete"
  rules:
    - if: '$ENABLE_OSSA_VALIDATION == "true"'

# ============================================
# STAGE 3: BUILD - Artifact Generation
# ============================================

build:project:
  stage: build
  image: node:20-alpine
  needs: ["validate:version"]
  script:
    - |
      echo "üî® Building project..."
      
      # Use ops for build orchestration
      $OPS_CLI build --type "$PROJECT_TYPE" --version "$PROJECT_VERSION" || true
      
      # Fallback to standard build commands
      case "$PROJECT_TYPE" in
        nodejs)
          npm ci
          npm run build
          ;;
        drupal)
          composer install --no-dev
          ;;
        python)
          pip install -e .
          ;;
      esac
      
      echo "‚úÖ Build complete"
  artifacts:
    paths:
      - dist/
      - build/
    expire_in: 1 week

# ============================================
# STAGE 4: TEST - Comprehensive Testing
# ============================================

test:tdd:
  stage: test
  image: node:20-alpine
  needs: ["build:project"]
  script:
    - |
      echo "üß™ Running TDD validation..."
      
      # Use buildkit TDD enforcer
      $BUILDKIT_CLI agents execute tdd-enforcer --validate || true
      
      # Run tests
      case "$PROJECT_TYPE" in
        nodejs)
          npm test
          npm run test:coverage || true
          ;;
        drupal)
          ./vendor/bin/phpunit
          ;;
        python)
          pytest
          ;;
      esac
      
      echo "‚úÖ TDD validation complete"

test:integration:
  stage: test
  image: node:20-alpine
  needs: ["build:project"]
  script:
    - |
      echo "üîó Running integration tests..."
      
      # Test agent integration
      $BUILDKIT_CLI agents test --integration || true
      
      # Test cross-platform integration
      if [ "$PROJECT_TYPE" = "nodejs" ]; then
        npm run test:integration || true
      fi
      
      echo "‚úÖ Integration tests complete"
  rules:
    - if: '$ENABLE_COMPREHENSIVE_TESTING == "true"'

# ============================================
# STAGE 5: SECURITY - Scanning & Audit
# ============================================

security:scan:
  stage: security
  image: node:20-alpine
  needs: ["test:tdd"]
  script:
    - |
      echo "üîí Running security scans..."
      
      # Use ops security scanning
      $OPS_CLI security scan --comprehensive || true
      
      # Run OSSA security audit
      $OSSA_CLI security audit || true
      
      # Agent-based security validation
      $BUILDKIT_CLI agents spawn security-audit-specialist \
        --task "Comprehensive security audit" || true
      
      echo "‚úÖ Security scanning complete"
  rules:
    - if: '$ENABLE_SECURITY_SCANNING == "true"'

# ============================================
# STAGE 6: QUALITY - Gates & Metrics
# ============================================

quality:gates:
  stage: quality
  image: node:20-alpine
  needs: ["test:tdd", "security:scan"]
  script:
    - |
      echo "üìä Checking quality gates..."
      
      # Use buildkit quality checks
      $AGENT_BUILDKIT_CLI quality check --threshold "$QUALITY_GATE_THRESHOLD" || true
      
      # Run code quality critic agent
      $BUILDKIT_CLI agents spawn code-quality-critic \
        --task "Review code quality and suggest improvements" || true
      
      # Check coverage
      if [ -f "coverage/coverage-summary.json" ]; then
        COVERAGE=$(jq -r '.total.lines.pct' coverage/coverage-summary.json)
        echo "Test coverage: $COVERAGE%"
        
        if [ "${COVERAGE%.*}" -lt "$TEST_COVERAGE_THRESHOLD" ]; then
          echo "‚ùå Coverage below threshold ($COVERAGE% < $TEST_COVERAGE_THRESHOLD%)"
          exit 1
        fi
      fi
      
      echo "‚úÖ Quality gates passed"

# ============================================
# STAGE 7: INTEGRATE - Merge & Sync
# ============================================

integrate:feature:
  stage: integrate
  image: node:20-alpine
  needs: ["quality:gates"]
  before_script:
    - apk add --no-cache git
    - git config user.email "ci@bluefly.io"
    - git config user.name "CI Bot"
  script:
    - |
      echo "üîÄ Auto-merging to development..."
      
      # Use buildkit merge command
      $AGENT_BUILDKIT_CLI git merge-to-development \
        --branch "$CI_COMMIT_BRANCH" \
        --strategy "no-ff" || true
      
      # Fallback to manual merge
      git fetch origin development:development
      git checkout development
      git merge --no-ff "$CI_COMMIT_BRANCH" \
        -m "Auto-merge: $CI_COMMIT_BRANCH ‚Üí development"
      
      # Try to push (may fail due to permissions)
      git push origin development || echo "‚ö†Ô∏è Push failed - manual merge required"
      
      echo "‚úÖ Feature integration complete"
  rules:
    - if: '$AUTO_MERGE_TO_DEV == "true" && $PIPELINE_TYPE == "feature"'
      when: on_success

integrate:sync:
  stage: integrate
  image: node:20-alpine
  needs: ["integrate:feature"]
  script:
    - |
      echo "üîÑ Synchronizing across projects..."
      
      # Use ops for cross-project sync
      $OPS_CLI sync --source "$CI_PROJECT_PATH" \
               --targets "agent_buildkit,common_npm/*" || true
      
      # Trigger dependent pipelines
      if [ "$PIPELINE_TYPE" = "development" ]; then
        echo "Triggering dependent project pipelines..."
        curl -X POST \
          -F token="$CI_JOB_TOKEN" \
          -F ref=development \
          -F "variables[UPSTREAM_PROJECT]=$CI_PROJECT_PATH" \
          "https://$CI_SERVER_HOST/api/v4/projects/$AGENT_BUILDKIT_PROJECT_ID/trigger/pipeline" || true
      fi
      
      echo "‚úÖ Cross-project sync complete"
  rules:
    - if: '$PIPELINE_TYPE == "development"'

# ============================================
# STAGE 8: RELEASE - Version & Tag Management
# ============================================

release:tag:
  stage: release
  image: node:20-alpine
  needs: ["quality:gates"]
  before_script:
    - apk add --no-cache git
  script:
    - |
      echo "üè∑Ô∏è Creating release tag..."
      
      # Determine tag based on pipeline type
      case "$PIPELINE_TYPE" in
        feature)
          TAG="v$PROJECT_VERSION-feature.$(echo $CI_COMMIT_BRANCH | sed 's/feature\///')+sha.$CI_COMMIT_SHORT_SHA"
          ;;
        bugfix)
          TAG="v$PROJECT_VERSION-bug.$(echo $CI_COMMIT_BRANCH | sed 's/bug\///')+sha.$CI_COMMIT_SHORT_SHA"
          ;;
        release)
          TAG="v$PROJECT_VERSION-rc.$(date +%Y%m%d)"
          ;;
        production)
          TAG="v$PROJECT_VERSION"
          ;;
        *)
          TAG="v$PROJECT_VERSION-dev.$(date +%Y%m%d)"
          ;;
      esac
      
      echo "Creating tag: $TAG"
      
      # Use buildkit tagging
      $AGENT_BUILDKIT_CLI git tag --name "$TAG" \
                       --message "Automated tag from $CI_COMMIT_BRANCH" || true
      
      # Fallback to git
      git tag -a "$TAG" -m "Pipeline: $CI_PIPELINE_ID" || true
      git push origin "$TAG" || echo "‚ö†Ô∏è Tag push failed"
      
      echo "RELEASE_TAG=$TAG" >> release.env
      echo "‚úÖ Tag created: $TAG"
  artifacts:
    reports:
      dotenv: release.env

release:changelog:
  stage: release
  image: node:20-alpine
  needs: ["release:tag"]
  script:
    - |
      echo "üìù Generating changelog..."
      
      # Use ops for changelog generation
      $OPS_CLI changelog generate --since "last-tag" \
                            --format "markdown" \
                            --output "CHANGELOG.md" || true
      
      # Use documentation curator agent
      $BUILDKIT_CLI agents spawn documentation-curator \
        --task "Update changelog and release notes" || true
      
      echo "‚úÖ Changelog generated"
  artifacts:
    paths:
      - CHANGELOG.md
  rules:
    - if: '$ENABLE_CHANGELOG == "true"'

release:production:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs: ["release:tag", "release:changelog"]
  script:
    - |
      echo "üöÄ Creating production release..."
      
      # This is the ONLY manual step
      echo "‚ö†Ô∏è Manual approval required for production release"
  release:
    tag_name: '$RELEASE_TAG'
    name: 'Release $RELEASE_TAG'
    description: |
      ## Release $RELEASE_TAG
      
      ### Changes
      See CHANGELOG.md for details
      
      ### Deployment
      - Production URL: $PRODUCTION_URL
      - Version: $PROJECT_VERSION
      
      ### Usage
      ```yaml
      include:
        - component: gitlab.bluefly.io/llm/gitlab_components/workflow/golden@$PROJECT_VERSION
      ```
  when: manual
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# ============================================
# STAGE 9: DEPLOY - Environment Deployment
# ============================================

deploy:staging:
  stage: deploy
  image: node:20-alpine
  needs: ["release:tag"]
  script:
    - |
      echo "üöÄ Deploying to staging..."
      
      # Use ops deployment
      $OPS_CLI deploy --environment "staging" \
                 --version "$PROJECT_VERSION" \
                 --strategy "$DEPLOYMENT_STRATEGY" || true
      
      # Health check
      if [ "$ENABLE_HEALTH_CHECKS" = "true" ]; then
        $OPS_CLI health check --url "$STAGING_URL" || true
      fi
      
      echo "‚úÖ Staging deployment complete"
  environment:
    name: staging
    url: $STAGING_URL
  rules:
    - if: '$DEPLOY_TO_STAGING == "auto"'
      when: on_success
    - if: '$DEPLOY_TO_STAGING == "manual"'
      when: manual

deploy:production:
  stage: deploy
  image: node:20-alpine
  needs: ["release:production"]
  script:
    - |
      echo "üöÄ Deploying to production..."
      
      # Use monitoring agent for deployment
      $BUILDKIT_CLI agents spawn monitoring-observability-engineer \
        --task "Monitor production deployment" || true
      
      # Deploy using ops
      $OPS_CLI deploy --environment "production" \
                 --version "$PROJECT_VERSION" \
                 --strategy "$DEPLOYMENT_STRATEGY" || true
      
      # Post-deployment validation
      $BUILDKIT_CLI agents spawn performance-optimizer \
        --task "Validate production performance" || true
      
      echo "‚úÖ Production deployment complete"
  environment:
    name: production
    url: $PRODUCTION_URL
  when: manual
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# ============================================
# STAGE 10: CLEANUP - Branch & Resource Management
# ============================================

cleanup:branches:
  stage: cleanup
  image: node:20-alpine
  before_script:
    - apk add --no-cache git jq
    - npm install -g @bluefly/agent-build-kit@latest 2>/dev/null || true
  script:
    - |
      echo "üßπ Cleaning up branches..."
      
      # Use git-branch-management-specialist agent
      $BUILDKIT_CLI agents spawn git-branch-management-specialist \
        --task "Clean up merged and stale branches" || true
      
      # Use buildkit branch cleanup
      $AGENT_BUILDKIT_CLI branch cleanup --age "$BRANCH_AGE_LIMIT" \
                              --keep-recent 5 \
                              --dry-run false || true
      
      # Manual cleanup for old branches
      for branch in $(git ls-remote --heads origin | grep -E 'refs/heads/(feature|bug|chore)/' | awk '{print $2}' | sed 's|refs/heads/||'); do
        LAST_COMMIT=$(git log -1 --format=%ct origin/$branch 2>/dev/null || echo 0)
        CURRENT_TIME=$(date +%s)
        AGE_DAYS=$(( ($CURRENT_TIME - $LAST_COMMIT) / 86400 ))
        
        if [ "$AGE_DAYS" -gt 30 ]; then
          echo "Removing stale branch: $branch (${AGE_DAYS} days old)"
          git push origin --delete "$branch" || echo "‚ö†Ô∏è Could not delete $branch"
        fi
      done
      
      echo "‚úÖ Branch cleanup complete"
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: always
  allow_failure: true

cleanup:artifacts:
  stage: cleanup
  image: node:20-alpine
  script:
    - |
      echo "üßπ Cleaning up old artifacts..."
      
      # Use ops for artifact cleanup
      $OPS_CLI cleanup artifacts --older-than "7d" || true
      
      # Clean up old Docker images if applicable
      if [ "$PROJECT_TYPE" = "docker" ]; then
        $OPS_CLI cleanup docker --keep-recent 5 || true
      fi
      
      echo "‚úÖ Artifact cleanup complete"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
  allow_failure: true

# ============================================
# REPORTING - Final Summary
# ============================================

.report:summary:
  stage: .post
  image: alpine:latest
  script:
    - |
      echo "üìä Pipeline Summary Report"
      echo "=========================="
      echo "Pipeline: $CI_PIPELINE_ID"
      echo "Branch: $CI_COMMIT_BRANCH"
      echo "Type: $PIPELINE_TYPE"
      echo "Version: $PROJECT_VERSION"
      echo "Tag: $RELEASE_TAG"
      echo ""
      echo "Agents Spawned:"
      $BUILDKIT_CLI agents list --status all || true
      echo ""
      echo "Quality Metrics:"
      echo "- Test Coverage: ${TEST_COVERAGE}%"
      echo "- Security Score: ${SECURITY_SCORE}/100"
      echo "- Quality Gate: ${QUALITY_GATE_SCORE}/100"
      echo ""
      echo "‚úÖ Pipeline complete"
  when: always
  allow_failure: true