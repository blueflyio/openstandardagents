# Multi-Project Release Pipeline Component
# Orchestrates releases across multiple OSSA agent projects in dependency order
# Part of Epic #3: Autonomous Release System - Phase 1 Issue #2

spec:
  inputs:
    # Agent discovery
    manifest_pattern:
      type: string
      description: Glob pattern for agent manifests (e.g., '.agents/**/*.ossa.yaml')
      default: '.agents/**/*.ossa.yaml'

    manifest_files:
      type: array
      description: Explicit list of manifest files (alternative to pattern)
      default: []

    # Release configuration
    release_type:
      type: string
      description: Type of release (major, minor, patch, auto)
      default: 'auto'
      enum: ['major', 'minor', 'patch', 'auto']

    dry_run:
      type: boolean
      description: Simulate release without actually deploying
      default: false

    # Deployment options
    parallel_batches:
      type: boolean
      description: Deploy agents in parallel within each batch
      default: true

    batch_delay:
      type: number
      description: Delay in seconds between batches
      default: 30

    fail_fast:
      type: boolean
      description: Stop all releases on first failure
      default: true

    # Rollback configuration
    enable_rollback:
      type: boolean
      description: Enable automatic rollback on failure
      default: true

    rollback_strategy:
      type: string
      description: Rollback strategy (immediate, batch, none)
      default: 'batch'
      enum: ['immediate', 'batch', 'none']

    # GitLab Project API settings
    gitlab_token:
      type: string
      description: GitLab API token for triggering child pipelines
      default: '$CI_JOB_TOKEN'

    # Notification settings
    notify_on_failure:
      type: boolean
      description: Send notifications on release failures
      default: true

    notification_channel:
      type: string
      description: Slack/Teams webhook URL for notifications
      default: ''

    # Timeout settings
    pipeline_timeout:
      type: number
      description: Maximum time in minutes for entire release
      default: 120

    batch_timeout:
      type: number
      description: Maximum time in minutes for single batch
      default: 30

---
# ============================================================================
# STAGE 1: CALCULATE DEPLOYMENT ORDER
# ============================================================================
multi-release:calculate-order:
  stage: .pre
  image: node:20-alpine
  variables:
    MANIFEST_PATTERN: $[[ inputs.manifest_pattern ]]
    DRY_RUN: $[[ inputs.dry_run ]]
  before_script:
    - apk add --no-cache jq bash
    - npm install -g @bluefly/openstandardagents@latest
    - ossa --version
  script:
    - |
      #!/bin/bash
      set -e

      echo "[CHECK] Multi-Project Release Orchestration"
      echo "======================================"
      echo ""
      echo "Configuration:"
      echo "  Manifest Pattern: ${MANIFEST_PATTERN}"
      echo "  Release Type: $[[ inputs.release_type ]]"
      echo "  Dry Run: ${DRY_RUN}"
      echo "  Parallel Batches: $[[ inputs.parallel_batches ]]"
      echo "  Fail Fast: $[[ inputs.fail_fast ]]"
      echo ""

      # Discover agent manifests
      if [ "$[[ inputs.manifest_files | length ]]" -gt 0 ]; then
        echo "[LIST] Using explicit manifest list..."
        MANIFESTS='$[[ inputs.manifest_files | join(" ") ]]'
      else
        echo "[CHECK] Discovering manifests using pattern: ${MANIFEST_PATTERN}"

        # Use find to get manifest files
        MANIFESTS=$(find . -path "./node_modules" -prune -o -path "${MANIFEST_PATTERN}" -print 2>/dev/null || true)

        if [ -z "$MANIFESTS" ]; then
          echo "[WARN]  No manifests found matching pattern: ${MANIFEST_PATTERN}"
          exit 1
        fi
      fi

      MANIFEST_COUNT=$(echo "$MANIFESTS" | wc -l | tr -d ' ')
      echo "[PKG] Found ${MANIFEST_COUNT} agent manifests"
      echo ""

      # Calculate deployment order using ossa dependencies
      echo "[SYNC] Calculating deployment order..."
      ossa dependencies deploy-order "${MANIFEST_PATTERN}" --format json > deployment-order.json

      if [ ! -f deployment-order.json ] || [ ! -s deployment-order.json ]; then
        echo "[FAIL] Failed to calculate deployment order"
        exit 1
      fi

      # Display deployment order
      echo ""
      echo "[PASS] Deployment Order Calculated:"
      echo ""

      TOTAL_BATCHES=$(jq -r '.total_batches' deployment-order.json)
      echo "Total Batches: ${TOTAL_BATCHES}"
      echo ""

      # Display each batch
      jq -c '.batches[]' deployment-order.json | while read -r batch; do
        BATCH_ID=$(echo "$batch" | jq -r '.batch_id')
        PARALLEL=$(echo "$batch" | jq -r '.parallel')
        AGENTS=$(echo "$batch" | jq -r '.agents | join(", ")')

        echo "Batch ${BATCH_ID}:"
        if [ "$PARALLEL" = "true" ]; then
          echo "  ⚡ Parallel deployment enabled"
        fi
        echo "  Agents: ${AGENTS}"
        echo ""
      done

      # Save for next stage
      cat deployment-order.json

      # Generate child pipeline configuration
      echo "[NOTE] Generating child pipeline configurations..."

      cat > child-pipelines.yml << 'EOF'
      # Generated Child Pipeline Configuration
      # This file orchestrates multi-project releases

      stages:
        - validate
        - release
        - verify
        - rollback

      variables:
        RELEASE_TYPE: "$[[ inputs.release_type ]]"
        DRY_RUN: "$[[ inputs.dry_run ]]"
        FAIL_FAST: "$[[ inputs.fail_fast ]]"

      EOF

      # Generate batch jobs
      BATCH_INDEX=1
      jq -c '.batches[]' deployment-order.json | while read -r batch; do
        BATCH_ID=$(echo "$batch" | jq -r '.batch_id')
        PARALLEL=$(echo "$batch" | jq -r '.parallel')
        AGENTS=$(echo "$batch" | jq -r '.agents[]')

        echo "# Batch ${BATCH_ID}" >> child-pipelines.yml

        for agent in $AGENTS; do
          cat >> child-pipelines.yml << BATCH_EOF

      release:batch-${BATCH_ID}:${agent}:
        stage: release
        trigger:
          project: \${CI_PROJECT_PATH}
          strategy: depend
        variables:
          AGENT_NAME: "${agent}"
          BATCH_ID: "${BATCH_ID}"
          RELEASE_TYPE: "\${RELEASE_TYPE}"
        needs:
      BATCH_EOF

          # Add dependencies on previous batch
          if [ $BATCH_ID -gt 1 ]; then
            PREV_BATCH=$((BATCH_ID - 1))
            echo "    - job: release:batch-${PREV_BATCH}:*" >> child-pipelines.yml
            echo "      optional: false" >> child-pipelines.yml
          fi

          if [ "$[[ inputs.fail_fast ]]" = "true" ]; then
            echo "  allow_failure: false" >> child-pipelines.yml
          else
            echo "  allow_failure: true" >> child-pipelines.yml
          fi

          echo "" >> child-pipelines.yml
        done

        BATCH_INDEX=$((BATCH_INDEX + 1))
      done

      echo "[PASS] Child pipeline configuration generated"

  artifacts:
    reports:
      dotenv: deployment-order.env
    paths:
      - deployment-order.json
      - child-pipelines.yml
    expire_in: 1 hour

  rules:
    - if: $CI_PIPELINE_SOURCE == "parent_pipeline"
      when: never
    - when: always

# ============================================================================
# STAGE 2: TRIGGER BATCH RELEASES
# ============================================================================
multi-release:execute-batches:
  stage: deploy
  image: alpine:latest
  needs:
    - multi-release:calculate-order
  variables:
    GITLAB_TOKEN: $[[ inputs.gitlab_token ]]
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      #!/bin/bash
      set -e

      echo "[RUN] Executing Multi-Project Release"
      echo "==================================="
      echo ""

      if [ ! -f deployment-order.json ]; then
        echo "[FAIL] Deployment order not found"
        exit 1
      fi

      TOTAL_BATCHES=$(jq -r '.total_batches' deployment-order.json)
      RELEASE_STATUS="success"
      FAILED_AGENTS=()
      RELEASED_AGENTS=()

      # Track release state
      mkdir -p .release-state
      echo '{"batches": []}' > .release-state/release-log.json

      # Execute each batch
      for BATCH_NUM in $(seq 1 $TOTAL_BATCHES); do
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Batch ${BATCH_NUM}/${TOTAL_BATCHES}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""

        # Get batch info
        BATCH=$(jq -c ".batches[] | select(.batch_id == ${BATCH_NUM})" deployment-order.json)
        AGENTS=$(echo "$BATCH" | jq -r '.agents[]')
        PARALLEL=$(echo "$BATCH" | jq -r '.parallel')

        BATCH_START=$(date +%s)
        BATCH_PIDS=()
        BATCH_FAILED=false

        # Release agents in batch
        for agent in $AGENTS; do
          echo "[PKG] Releasing: ${agent}"

          if [ "$[[ inputs.dry_run ]]" = "true" ]; then
            echo "   [DRY RUN] Would trigger release for ${agent}"
            RELEASED_AGENTS+=("${agent}")
            continue
          fi

          # Trigger agent release pipeline
          PIPELINE_ID=$(curl -sS --request POST \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
            --form "ref=main" \
            --form "variables[AGENT_NAME]=${agent}" \
            --form "variables[BATCH_ID]=${BATCH_NUM}" \
            --form "variables[RELEASE_TYPE]=$[[ inputs.release_type ]]" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipeline" \
            | jq -r '.id // empty')

          if [ -z "$PIPELINE_ID" ]; then
            echo "   [FAIL] Failed to trigger pipeline for ${agent}"
            FAILED_AGENTS+=("${agent}")
            BATCH_FAILED=true

            if [ "$[[ inputs.fail_fast ]]" = "true" ]; then
              RELEASE_STATUS="failed"
              break 2
            fi
            continue
          fi

          echo "   ✓ Pipeline triggered: ${PIPELINE_ID}"

          # Wait for pipeline if not parallel
          if [ "$PARALLEL" = "false" ] || [ "$[[ inputs.parallel_batches ]]" = "false" ]; then
            echo "   ⏳ Waiting for pipeline to complete..."

            # Poll pipeline status
            TIMEOUT=$[[ inputs.batch_timeout ]]
            ELAPSED=0

            while [ $ELAPSED -lt $((TIMEOUT * 60)) ]; do
              STATUS=$(curl -sS --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
                "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${PIPELINE_ID}" \
                | jq -r '.status')

              if [ "$STATUS" = "success" ]; then
                echo "   [PASS] Release completed: ${agent}"
                RELEASED_AGENTS+=("${agent}")
                break
              elif [ "$STATUS" = "failed" ] || [ "$STATUS" = "canceled" ]; then
                echo "   [FAIL] Release failed: ${agent} (status: ${STATUS})"
                FAILED_AGENTS+=("${agent}")
                BATCH_FAILED=true

                if [ "$[[ inputs.fail_fast ]]" = "true" ]; then
                  RELEASE_STATUS="failed"
                  break 3
                fi
                break
              fi

              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done

            if [ $ELAPSED -ge $((TIMEOUT * 60)) ]; then
              echo "   [TIME]  Timeout: ${agent}"
              FAILED_AGENTS+=("${agent}")
              BATCH_FAILED=true
            fi
          else
            BATCH_PIDS+=("${PIPELINE_ID}:${agent}")
          fi
        done

        # Wait for parallel pipelines if enabled
        if [ "$PARALLEL" = "true" ] && [ "$[[ inputs.parallel_batches ]]" = "true" ]; then
          echo ""
          echo "⏳ Waiting for parallel batch to complete..."

          for pid_agent in "${BATCH_PIDS[@]}"; do
            PIPELINE_ID="${pid_agent%%:*}"
            agent="${pid_agent##*:}"

            # Wait for pipeline
            TIMEOUT=$[[ inputs.batch_timeout ]]
            ELAPSED=0

            while [ $ELAPSED -lt $((TIMEOUT * 60)) ]; do
              STATUS=$(curl -sS --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
                "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines/${PIPELINE_ID}" \
                | jq -r '.status')

              if [ "$STATUS" = "success" ]; then
                echo "   [PASS] ${agent}"
                RELEASED_AGENTS+=("${agent}")
                break
              elif [ "$STATUS" = "failed" ] || [ "$STATUS" = "canceled" ]; then
                echo "   [FAIL] ${agent} (status: ${STATUS})"
                FAILED_AGENTS+=("${agent}")
                BATCH_FAILED=true
                break
              fi

              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
          done
        fi

        # Log batch completion
        BATCH_END=$(date +%s)
        BATCH_DURATION=$((BATCH_END - BATCH_START))

        jq --arg batch "$BATCH_NUM" \
           --arg duration "$BATCH_DURATION" \
           --arg status "$([ "$BATCH_FAILED" = "true" ] && echo 'failed' || echo 'success')" \
           '.batches += [{batch: $batch, duration: $duration, status: $status}]' \
           .release-state/release-log.json > .release-state/release-log.json.tmp
        mv .release-state/release-log.json.tmp .release-state/release-log.json

        # Inter-batch delay
        if [ $BATCH_NUM -lt $TOTAL_BATCHES ] && [ "$BATCH_FAILED" = "false" ]; then
          echo ""
          echo "[PAUSE]  Waiting $[[ inputs.batch_delay ]]s before next batch..."
          sleep $[[ inputs.batch_delay ]]
        fi

        # Check if we should stop
        if [ "$BATCH_FAILED" = "true" ] && [ "$[[ inputs.fail_fast ]]" = "true" ]; then
          RELEASE_STATUS="failed"
          break
        fi
      done

      # Release summary
      echo ""
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo "Release Summary"
      echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      echo ""
      echo "Total Agents: $(jq -r '.total_agents' deployment-order.json)"
      echo "Released: ${#RELEASED_AGENTS[@]}"
      echo "Failed: ${#FAILED_AGENTS[@]}"
      echo ""

      if [ ${#FAILED_AGENTS[@]} -gt 0 ]; then
        echo "Failed Agents:"
        printf '  - %s\n' "${FAILED_AGENTS[@]}"
        echo ""
      fi

      # Save state
      echo "RELEASE_STATUS=${RELEASE_STATUS}" >> release.env
      echo "RELEASED_COUNT=${#RELEASED_AGENTS[@]}" >> release.env
      echo "FAILED_COUNT=${#FAILED_AGENTS[@]}" >> release.env

      # Trigger rollback if needed
      if [ "${RELEASE_STATUS}" = "failed" ] && [ "$[[ inputs.enable_rollback ]]" = "true" ]; then
        echo "[SYNC] Initiating rollback..."
        echo "TRIGGER_ROLLBACK=true" >> release.env
      fi

      # Send notification
      if [ "${RELEASE_STATUS}" = "failed" ] && [ "$[[ inputs.notify_on_failure ]]" = "true" ] && [ -n "$[[ inputs.notification_channel ]]" ]; then
        NOTIFICATION_MSG="Multi-Project Release Failed\nReleased: ${#RELEASED_AGENTS[@]}\nFailed: ${#FAILED_AGENTS[@]}"

        curl -X POST "$[[ inputs.notification_channel ]]" \
          -H "Content-Type: application/json" \
          -d "{\"text\":\"${NOTIFICATION_MSG}\"}" || true
      fi

      # Exit with appropriate code
      if [ "${RELEASE_STATUS}" = "failed" ]; then
        echo "[FAIL] Multi-project release failed"
        exit 1
      else
        echo "[PASS] Multi-project release completed successfully"
        exit 0
      fi

  artifacts:
    reports:
      dotenv: release.env
    paths:
      - .release-state/
    expire_in: 1 week

  timeout: $[[ inputs.pipeline_timeout ]]m

  rules:
    - if: $CI_PIPELINE_SOURCE == "parent_pipeline"
      when: never
    - when: on_success

# ============================================================================
# STAGE 3: ROLLBACK ON FAILURE
# ============================================================================
multi-release:rollback:
  stage: .post
  image: alpine:latest
  needs:
    - multi-release:calculate-order
    - multi-release:execute-batches
  variables:
    GITLAB_TOKEN: $[[ inputs.gitlab_token ]]
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      #!/bin/bash
      set -e

      if [ "${TRIGGER_ROLLBACK}" != "true" ]; then
        echo "[INFO]  No rollback needed"
        exit 0
      fi

      echo "[SYNC] Multi-Project Rollback"
      echo "========================="
      echo ""
      echo "Rollback Strategy: $[[ inputs.rollback_strategy ]]"
      echo ""

      if [ ! -f deployment-order.json ] || [ ! -f .release-state/release-log.json ]; then
        echo "[FAIL] Missing release state files"
        exit 1
      fi

      # Read successful releases
      COMPLETED_BATCHES=$(jq -r '.batches[] | select(.status == "success") | .batch' .release-state/release-log.json)

      case "$[[ inputs.rollback_strategy ]]" in
        immediate)
          echo "⚡ Immediate rollback: reverting all successful releases"

          # Revert in reverse order
          for BATCH_NUM in $(echo "$COMPLETED_BATCHES" | tac); do
            AGENTS=$(jq -r ".batches[] | select(.batch_id == ${BATCH_NUM}) | .agents[]" deployment-order.json)

            for agent in $AGENTS; do
              echo "  ⏪ Rolling back: ${agent}"

              # Trigger rollback pipeline
              curl -sS --request POST \
                --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
                --form "ref=main" \
                --form "variables[AGENT_NAME]=${agent}" \
                --form "variables[ACTION]=rollback" \
                "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipeline" > /dev/null
            done
          done
          ;;

        batch)
          echo "[PKG] Batch rollback: reverting last successful batch only"

          LAST_BATCH=$(echo "$COMPLETED_BATCHES" | tail -1)
          AGENTS=$(jq -r ".batches[] | select(.batch_id == ${LAST_BATCH}) | .agents[]" deployment-order.json)

          for agent in $AGENTS; do
            echo "  ⏪ Rolling back: ${agent}"

            curl -sS --request POST \
              --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
              --form "ref=main" \
              --form "variables[AGENT_NAME]=${agent}" \
              --form "variables[ACTION]=rollback" \
              "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipeline" > /dev/null
          done
          ;;

        none)
          echo "[BLOCK] Rollback disabled"
          ;;
      esac

      echo ""
      echo "[PASS] Rollback initiated"

  rules:
    - if: $CI_PIPELINE_SOURCE == "parent_pipeline"
      when: never
    - if: $TRIGGER_ROLLBACK == "true"
      when: on_failure
  allow_failure: true
