# Webhook-Triggered Agent Pipeline
# Handles GitLab webhook events and routes to appropriate agents

variables:
  AGENT_RUNTIME: node:20-alpine
  WEBHOOK_VALIDATION_TIMEOUT: 30

# =============================================================================
# WEBHOOK VALIDATION
# =============================================================================

webhook:validate:
  stage: .pre
  image: alpine:latest
  script:
    - |
      echo "[VALIDATE] Validating Webhook Event"
      echo "Event: ${WEBHOOK_EVENT_TYPE}"
      echo "Object: ${WEBHOOK_OBJECT_KIND}"
      
      # Validate webhook secret
      if [ -z "$WEBHOOK_SECRET" ]; then
        echo "[ERROR] WEBHOOK_SECRET not configured"
        exit 1
      fi
      
      # Validate event type
      if [ -z "$WEBHOOK_EVENT_TYPE" ]; then
        echo "[ERROR] No webhook event type"
        exit 1
      fi
      
      # Parse event data
      echo "$WEBHOOK_PAYLOAD" > event.json
      
      # Extract key fields
      EVENT_TYPE=$(echo "$WEBHOOK_PAYLOAD" | jq -r '.object_kind // "unknown"')
      EVENT_ACTION=$(echo "$WEBHOOK_PAYLOAD" | jq -r '.object_attributes.action // "unknown"')
      
      echo "Parsed Event Type: $EVENT_TYPE"
      echo "Parsed Action: $EVENT_ACTION"
      
      # Save to artifacts
      cat > webhook-event.env << EOF
      WEBHOOK_EVENT_TYPE=${EVENT_TYPE}
      WEBHOOK_EVENT_ACTION=${EVENT_ACTION}
      WEBHOOK_VALIDATED=true
      EOF
      
      echo "[OK] Webhook validated"
  artifacts:
    reports:
      dotenv: webhook-event.env
    paths:
      - event.json
      - webhook-event.env
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger"
      when: always
  allow_failure: false

# =============================================================================
# AGENT ROUTER
# =============================================================================

agent:router:
  stage: .pre
  image: ${AGENT_RUNTIME}
  dependencies:
    - webhook:validate
  script:
    - |
      echo "[ROUTE] Routing Event to Agent"
      
      # Determine which agent to trigger
      case "$WEBHOOK_EVENT_TYPE" in
        "merge_request")
          echo "AGENT_TARGET=mr-manager" >> agent-routing.env
          echo "AGENT_MANIFEST=.gitlab/agents/mr-manager/manifest.ossa.yaml" >> agent-routing.env
          echo "→ Routing to MR Manager Agent"
          ;;
        "issue")
          echo "AGENT_TARGET=issue-triage" >> agent-routing.env
          echo "AGENT_MANIFEST=.gitlab/agents/issue-triage/manifest.ossa.yaml" >> agent-routing.env
          echo "→ Routing to Issue Triage Agent"
          ;;
        "note")
          # Check if note is on MR or Issue
          NOTE_TYPE=$(cat event.json | jq -r '.merge_request // .issue | if . then "found" else "none" end')
          if [ "$NOTE_TYPE" = "found" ]; then
            echo "AGENT_TARGET=mr-manager" >> agent-routing.env
            echo "AGENT_MANIFEST=.gitlab/agents/mr-manager/manifest.ossa.yaml" >> agent-routing.env
            echo "→ Routing to MR Manager Agent (note on MR)"
          else
            echo "AGENT_TARGET=issue-triage" >> agent-routing.env
            echo "AGENT_MANIFEST=.gitlab/agents/issue-triage/manifest.ossa.yaml" >> agent-routing.env
            echo "→ Routing to Issue Triage Agent (note on issue)"
          fi
          ;;
        *)
          echo "[WARN]  Unknown event type: $WEBHOOK_EVENT_TYPE"
          echo "AGENT_TARGET=none" >> agent-routing.env
          exit 0
          ;;
      esac
      
      echo "[OK] Routing complete"
  artifacts:
    reports:
      dotenv: agent-routing.env
    paths:
      - agent-routing.env
    expire_in: 1 hour
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger" && $WEBHOOK_VALIDATED == "true"
      when: always
  allow_failure: false

# =============================================================================
# AGENT EXECUTORS
# =============================================================================

agent:issue-triage:
  stage: build
  image: ${AGENT_RUNTIME}
  dependencies:
    - webhook:validate
    - agent:router
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      echo "[AGENT] Issue Triage Agent"
      echo "===================="
      
      # Load manifest
      if [ ! -f ".gitlab/agents/issue-triage/manifest.ossa.yaml" ]; then
        echo "[ERROR] Agent manifest not found"
        exit 1
      fi
      
      # Extract issue data
      ISSUE_IID=$(cat event.json | jq -r '.object_attributes.iid // ""')
      ISSUE_TITLE=$(cat event.json | jq -r '.object_attributes.title // ""')
      ISSUE_DESCRIPTION=$(cat event.json | jq -r '.object_attributes.description // ""')
      
      echo "Issue #${ISSUE_IID}: ${ISSUE_TITLE}"
      
      # Task 1: Validate issue template
      echo ""
      echo "Task: Validate Issue Template"
      if echo "$ISSUE_DESCRIPTION" | grep -qi "expected behavior"; then
        echo "[OK] Has expected behavior section"
        VALIDATION_PASSED=true
      else
        echo "[WARN]  Missing expected behavior section"
        VALIDATION_PASSED=false
      fi
      
      # Task 2: Classify issue type
      echo ""
      echo "Task: Classify Issue Type"
      if echo "$ISSUE_TITLE $ISSUE_DESCRIPTION" | grep -qiE "bug|error|broken|crash|fail"; then
        ISSUE_TYPE="bug"
        LABELS="type::bug,priority::high"
      elif echo "$ISSUE_TITLE $ISSUE_DESCRIPTION" | grep -qiE "feature|enhancement|add|new"; then
        ISSUE_TYPE="feature"
        LABELS="type::feature,priority::medium"
      elif echo "$ISSUE_TITLE $ISSUE_DESCRIPTION" | grep -qiE "docs|documentation|readme"; then
        ISSUE_TYPE="documentation"
        LABELS="type::documentation,priority::low"
      else
        ISSUE_TYPE="question"
        LABELS="type::question,priority::low"
      fi
      echo "Classified as: $ISSUE_TYPE"
      
      # Task 3: Apply labels
      echo ""
      echo "Task: Apply Labels"
      if [ -n "$GITLAB_TOKEN" ]; then
        IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
        for label in "${LABEL_ARRAY[@]}"; do
          curl -sS --request POST \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues/${ISSUE_IID}/labels" \
            --data "labels[]=${label}" > /dev/null
          echo "  + ${label}"
        done
      fi
      
      # Task 4: Add comment
      echo ""
      echo "Task: Post Triage Report"
      VALIDATION_MSG="Passed"
      if [ "$VALIDATION_PASSED" != "true" ]; then
        VALIDATION_MSG="Incomplete template"
      fi
      cat > comment.md << 'COMMENT_EOF'
## Issue Triage Report

Type: ISSUE_TYPE_PLACEHOLDER
Labels Applied: LABELS_PLACEHOLDER
Validation: VALIDATION_PLACEHOLDER

This issue has been automatically triaged by the Issue Triage Agent.
COMMENT_EOF
      sed -i "s/ISSUE_TYPE_PLACEHOLDER/${ISSUE_TYPE}/g" comment.md
      sed -i "s/LABELS_PLACEHOLDER/${LABELS}/g" comment.md
      sed -i "s/VALIDATION_PLACEHOLDER/${VALIDATION_MSG}/g" comment.md
      COMMENT=$(cat comment.md)
      
      if [ -n "$GITLAB_TOKEN" ]; then
        curl -sS --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/issues/${ISSUE_IID}/notes" \
          --data "{\"body\": $(echo "$COMMENT" | jq -Rs .)}" > /dev/null
        echo "[OK] Comment posted"
      fi
      
      echo ""
      echo "[OK] Issue triage complete"
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger" && $AGENT_TARGET == "issue-triage"
      when: always
  allow_failure: true

agent:mr-manager:
  stage: build
  image: ${AGENT_RUNTIME}
  dependencies:
    - webhook:validate
    - agent:router
  before_script:
    - apk add --no-cache curl jq bash
  script:
    - |
      echo "[AGENT] MR Manager Agent"
      echo "==================="
      
      # Load manifest
      if [ ! -f ".gitlab/agents/mr-manager/manifest.ossa.yaml" ]; then
        echo "[ERROR] Agent manifest not found"
        exit 1
      fi
      
      # Extract MR data
      MR_IID=$(cat event.json | jq -r '.object_attributes.iid // ""')
      MR_TITLE=$(cat event.json | jq -r '.object_attributes.title // ""')
      MR_STATE=$(cat event.json | jq -r '.object_attributes.state // ""')
      MR_TARGET=$(cat event.json | jq -r '.object_attributes.target_branch // ""')
      
      echo "MR !${MR_IID}: ${MR_TITLE}"
      echo "Target: ${MR_TARGET}"
      
      # Task 1: Validate conventional commit title
      echo ""
      echo "Task: Validate MR Title"
      if echo "$MR_TITLE" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|chore|ci)(\(.+\))?:"; then
        echo "[OK] Conventional commit format"
        TITLE_VALID=true
      else
        echo "[WARN]  Not conventional commit format"
        TITLE_VALID=false
      fi
      
      # Task 2: Auto-label based on title
      echo ""
      echo "Task: Apply Automatic Labels"
      if echo "$MR_TITLE" | grep -qE "^feat:"; then
        LABELS="type::feature,semver::minor"
      elif echo "$MR_TITLE" | grep -qE "^fix:"; then
        LABELS="type::bug,semver::patch"
      elif echo "$MR_TITLE" | grep -qE "^docs:"; then
        LABELS="type::documentation"
      elif echo "$MR_TITLE" | grep -qE "^chore:"; then
        LABELS="type::maintenance"
      else
        LABELS=""
      fi
      
      if [ -n "$LABELS" ] && [ -n "$GITLAB_TOKEN" ]; then
        IFS=',' read -ra LABEL_ARRAY <<< "$LABELS"
        for label in "${LABEL_ARRAY[@]}"; do
          curl -sS --request POST \
            --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
            "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${MR_IID}/labels" \
            --data "labels[]=${label}" > /dev/null
          echo "  + ${label}"
        done
      fi
      
      # Task 3: Check pipeline status
      echo ""
      echo "Task: Check Pipeline Status"
      if [ -n "$GITLAB_TOKEN" ]; then
        PIPELINE_STATUS=$(curl -sS --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${MR_IID}" | \
          jq -r '.head_pipeline.status // "none"')
        echo "Pipeline: $PIPELINE_STATUS"
      fi
      
      # Task 4: Add comment
      echo ""
      echo "Task: Post MR Report"
      TITLE_MSG="Valid"
      if [ "$TITLE_VALID" != "true" ]; then
        TITLE_MSG="Use conventional commit format"
      fi
      cat > comment.md << 'COMMENT_EOF'
## MR Manager Report

Title Validation: TITLE_PLACEHOLDER
Labels Applied: LABELS_PLACEHOLDER
Pipeline: PIPELINE_PLACEHOLDER

This MR has been automatically processed by the MR Manager Agent.
COMMENT_EOF
      sed -i "s/TITLE_PLACEHOLDER/${TITLE_MSG}/g" comment.md
      sed -i "s/LABELS_PLACEHOLDER/${LABELS:-none}/g" comment.md
      sed -i "s/PIPELINE_PLACEHOLDER/${PIPELINE_STATUS:-unknown}/g" comment.md
      COMMENT=$(cat comment.md)
      
      if [ -n "$GITLAB_TOKEN" ]; then
        curl -sS --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_TOKEN}" \
          --header "Content-Type: application/json" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${MR_IID}/notes" \
          --data "{\"body\": $(echo "$COMMENT" | jq -Rs .)}" > /dev/null
        echo "[OK] Comment posted"
      fi
      
      echo ""
      echo "[OK] MR management complete"
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger" && $AGENT_TARGET == "mr-manager"
      when: always
  allow_failure: true

# =============================================================================
# REPORTING
# =============================================================================

agent:report:
  stage: .post
  image: alpine:latest
  dependencies:
    - webhook:validate
    - agent:router
  script:
    - |
      echo "[REPORT] Agent Execution Report"
      echo "========================="
      echo ""
      echo "Event Type: ${WEBHOOK_EVENT_TYPE}"
      echo "Agent: ${AGENT_TARGET}"
      echo "Status: Complete"
      echo ""
      echo "[OK] Webhook pipeline finished"
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger"
      when: always
  allow_failure: true
