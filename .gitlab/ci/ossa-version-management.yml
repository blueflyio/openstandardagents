# OSSA Version Management - Dynamic Version Injection
# NO HARDCODED VERSIONS IN MANIFESTS
# Version detection from Git tags, milestones, and branches
# Injected at deploy time via envsubst
#
# Professional-grade implementation following GitLab best practices:
# - Uses existing version-detect stage
# - Strict shell scripting (set -euo pipefail)
# - Restricted envsubst (only specific variables)
# - Renders to separate directory (doesn't overwrite source)
# - Pinned image versions (no latest)
# - Conditional execution (only when manifests exist)

detect-ossa-version:
  stage: version-detect
  image: node:22-alpine
  needs:
    - job: detect:version
      optional: true
      artifacts: true
    - job: version:sync:placeholders
      optional: true
      artifacts: true
  before_script:
    - apk add --no-cache bash git findutils
  script:
    - bash .gitlab/scripts/detect-ossa-version.sh
  artifacts:
    reports:
      dotenv: ossa-version.env
    paths:
      - ossa-version.env
    expire_in: 1 day
  rules:
    - exists:
        - .gitlab/agents/**/*.ossa.yaml
    - when: always

validate-and-inject-version:
  stage: validate
  image: node:22-alpine
  needs:
    - job: detect-ossa-version
      optional: true
      artifacts: true
    - job: version:sync:placeholders
      optional: true
      artifacts: true
  before_script:
    - apk add --no-cache bash gettext findutils
    - |
      # Sync version if package.json has placeholder (needed for CLI to load)
      if [ -f "package.json" ] && grep -q '"version": "{{VERSION}}"' package.json; then
        echo "package.json has {{VERSION}} placeholder, syncing version..."
        # Try to get version from build.env if available
        if [ -f "build.env" ]; then
          set -a
          source build.env
          set +a
          if [ -n "${VERSION:-}" ]; then
            echo "Syncing version ${VERSION} to package.json..."
            node -e "const fs = require('fs'); const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8')); pkg.version = '${VERSION}'; fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');"
          else
            # Fallback: use latest spec directory
            LATEST_SPEC=$(find spec -maxdepth 1 -type d -name "v*" -print | sort -V | tail -1 || true)
            if [ -n "$LATEST_SPEC" ]; then
              VERSION=$(basename "$LATEST_SPEC" | sed 's/^v//')
              echo "Using version from spec directory: ${VERSION}"
              node -e "const fs = require('fs'); const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8')); pkg.version = '${VERSION}'; fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');"
            fi
          fi
        fi
      fi
    - npm ci
    - npm run build
  script:
    - |
      set -euo pipefail
      
      # Detect version if not set from detect-ossa-version job
      if [ -z "${OSSA_VERSION:-}" ]; then
        echo "OSSA_VERSION not set from detect-ossa-version, detecting from package.json..."
        if [ -f "package.json" ]; then
          PACKAGE_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
          if [ -n "$PACKAGE_VERSION" ] && [ "$PACKAGE_VERSION" != "{{VERSION}}" ]; then
            OSSA_VERSION="$PACKAGE_VERSION"
            echo "Using version from package.json: $OSSA_VERSION"
          fi
        fi
        
        # Fallback: detect from spec directories
        if [ -z "${OSSA_VERSION:-}" ] && [ -d "spec" ]; then
          LATEST_SPEC=$(find spec -maxdepth 1 -type d -name "v*" -print | sort -V | tail -1 || true)
          if [ -n "$LATEST_SPEC" ]; then
            OSSA_VERSION=$(basename "$LATEST_SPEC" | sed 's/^v//')
            echo "Using latest spec directory: v$OSSA_VERSION"
          fi
        fi
      fi
      
      # Validate version format (must be X.Y.Z)
      if [ -z "${OSSA_VERSION:-}" ]; then
        echo "ERROR: Could not determine OSSA version" >&2
        echo "Tried: detect-ossa-version job, package.json, spec/ directories" >&2
        exit 1
      fi
      
      # Ensure version is in X.Y.Z format (remove 'v' prefix if present)
      OSSA_VERSION="${OSSA_VERSION#v}"
      
      # Validate format
      if ! echo "$OSSA_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+'; then
        echo "ERROR: Invalid version format: $OSSA_VERSION (expected X.Y.Z)" >&2
        exit 1
      fi
      
      echo "Using OSSA_VERSION: $OSSA_VERSION"
      export OSSA_VERSION

      SRC_DIR=".gitlab/agents"
      OUT_DIR=".gitlab/agents_rendered"
      rm -rf "$OUT_DIR"
      mkdir -p "$OUT_DIR"

      count="$(find "$SRC_DIR" -type f -name "*.ossa.yaml" | wc -l | tr -d " ")"
      echo "Found $count OSSA manifests"

      find "$SRC_DIR" -type f -name "*.ossa.yaml" -print0 | while IFS= read -r -d "" manifest; do
        rel="${manifest#${SRC_DIR}/}"
        out="${OUT_DIR}/${rel}"
        mkdir -p "$(dirname "$out")"
        envsubst '$OSSA_VERSION $CI_COMMIT_SHA' < "$manifest" > "$out"
      done

      find "$OUT_DIR" -type f -name "*.ossa.yaml" -exec npx ossa validate {} --schema "$OSSA_VERSION" \;
  artifacts:
    paths:
      - .gitlab/agents_rendered/
    expire_in: 1 day
  rules:
    - exists:
        - .gitlab/agents/**/*.ossa.yaml
    - when: never

deploy-agents-with-version:
  stage: deploy
  image: bitnami/kubectl:1.31
  needs: [validate-and-inject-version]
  script:
    - |
      set -euo pipefail
      DIR=".gitlab/agents_rendered"
      find "$DIR" -type f -name "*.ossa.yaml" -print0 | while IFS= read -r -d "" f; do
        kubectl apply -f "$f" --dry-run=client
      done
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_TAG'
      when: on_success
  environment:
    name: production
    kubernetes:
      namespace: ossa-agents
