# Milestone-Driven Workflow Enforcement
# Ensures proper branching strategy and milestone assignment

# Validate branch targeting rules
validate:branch-target:
  stage: validate
  image: alpine:latest
  allow_failure: true
  script:
    - |
      #!/bin/sh
      set -e

      echo "[TARGET] BRANCH TARGET VALIDATION"
      echo "==========================="
      echo ""
      echo "Source: ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
      echo "Target: ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}"
      echo ""

      # Feature/bugfix/chore branches can target release/* or main
      case "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" in
        feature/*|bugfix/*|chore/*|fix/*|docs/*|refactor/*|test/*|feat/*|hotfix/*)
          case "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" in
            release/*|main)
              echo "[PASS] Feature branch correctly targets ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}"
              ;;
            *)
              echo "[FAIL] ERROR: Feature branches must target 'release/*' or 'main'"
              echo ""
              echo "Your branch: ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
              echo "Targeting:   ${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}"
              echo ""
              echo "Please retarget this MR to a release branch or main"
              exit 1
              ;;
          esac
          ;;
        release/*)
          if [ "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" != "main" ]; then
            echo "[FAIL] ERROR: Release branches must target 'main'"
            exit 1
          fi
          echo "[PASS] Release branch targeting main"
          ;;
        *)
          echo "[INFO] Non-standard branch naming - manual review required"
          ;;
      esac
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: false

# Validate milestone assignment for release-related MRs
validate:milestone-assignment:
  stage: validate
  image: alpine:latest
  allow_failure: true
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      #!/bin/sh
      set -e

      echo "[LIST] MILESTONE VALIDATION"
      echo "======================="
      echo ""

      # Get MR details - try GITLAB_PUSH_TOKEN first (can see group milestones), then CI_JOB_TOKEN
      if [ -n "${GITLAB_PUSH_TOKEN:-}" ]; then
        MR_DATA=$(curl -sS --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}" 2>/dev/null || echo "{}")
      else
        MR_DATA=$(curl -sS --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}" 2>/dev/null || echo "{}")
      fi

      # Validate JSON response
      if ! echo "$MR_DATA" | jq empty 2>/dev/null; then
        echo "[WARN] WARNING: Could not fetch MR details from API"
        echo "Response: $MR_DATA"
        echo "Skipping milestone validation..."
        exit 0
      fi

      MILESTONE=$(echo "$MR_DATA" | jq -r '.milestone.title // empty' 2>/dev/null || echo "")
      MILESTONE_ID=$(echo "$MR_DATA" | jq -r '.milestone.id // empty' 2>/dev/null || echo "")

      # If no milestone from MR API (CI_JOB_TOKEN can't see group milestones), check group milestones directly
      if [ -z "$MILESTONE" ] || [ "$MILESTONE" = "null" ] || [ "$MILESTONE" = "" ]; then
        echo "[INFO] Checking group milestones (CI_JOB_TOKEN has limited scope)..."
        
        # Get project namespace to find group ID dynamically
        if [ -n "${GITLAB_PUSH_TOKEN:-}" ]; then
          PROJECT_DATA=$(curl -sS --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}" 2>/dev/null || echo "{}")
        else
          PROJECT_DATA=$(curl -sS --header "JOB-TOKEN: ${CI_JOB_TOKEN}" "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}" 2>/dev/null || echo "{}")
        fi
        
        NAMESPACE_ID=$(echo "$PROJECT_DATA" | jq -r '.namespace.id // empty' 2>/dev/null || echo "")
        
        # Fallback to hardcoded group ID if namespace lookup fails
        if [ -z "$NAMESPACE_ID" ] || [ "$NAMESPACE_ID" = "null" ]; then
          NAMESPACE_ID="87749026"
        fi
        
        # Try with better token if available for group milestone access
        if [ -n "${GITLAB_PUSH_TOKEN:-}" ]; then
          TOKEN_HEADER="PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}"
        elif [ -n "${GITLAB_TOKEN:-}" ]; then
          TOKEN_HEADER="PRIVATE-TOKEN: ${GITLAB_TOKEN}"
        else
          TOKEN_HEADER="JOB-TOKEN: ${CI_JOB_TOKEN}"
        fi
        
        # Get all group milestones to find the one assigned to MR
        GROUP_MILESTONES=$(curl -sS --header "${TOKEN_HEADER}" "${CI_API_V4_URL}/groups/${NAMESPACE_ID}/milestones?per_page=100" 2>/dev/null || echo "[]")
        
        # If we have a milestone_id from MR, try to match it against group milestones
        if [ -n "$MILESTONE_ID" ] && [ "$MILESTONE_ID" != "null" ] && [ "$MILESTONE_ID" != "" ]; then
          MILESTONE=$(echo "$GROUP_MILESTONES" | jq -r ".[] | select(.id == ${MILESTONE_ID}) | .title" 2>/dev/null || echo "")
          if [ -n "$MILESTONE" ] && [ "$MILESTONE" != "null" ]; then
            echo "[PASS] Found group milestone assigned to MR: ${MILESTONE}"
          fi
        fi
        
        # Also check milestone_id field directly (different API response format)
        if [ -z "$MILESTONE" ] || [ "$MILESTONE" = "null" ] || [ "$MILESTONE" = "" ]; then
          MR_MILESTONE_ID=$(echo "$MR_DATA" | jq -r '.milestone_id // empty' 2>/dev/null || echo "")
          if [ -n "$MR_MILESTONE_ID" ] && [ "$MR_MILESTONE_ID" != "null" ] && [ "$MR_MILESTONE_ID" != "" ]; then
            MILESTONE=$(echo "$GROUP_MILESTONES" | jq -r ".[] | select(.id == ${MR_MILESTONE_ID}) | .title" 2>/dev/null || echo "")
            if [ -n "$MILESTONE" ] && [ "$MILESTONE" != "null" ]; then
              echo "[PASS] Found group milestone by milestone_id: ${MILESTONE}"
            fi
          fi
        fi
      fi
      LABELS=$(echo "$MR_DATA" | jq -r 'if .labels then (.labels | join(", ")) else "" end' 2>/dev/null || echo "")

      echo "MR: !${CI_MERGE_REQUEST_IID}"
      echo "Milestone: ${MILESTONE:-not assigned}"
      echo "Labels: ${LABELS:-none}"
      echo ""

      # Always allow if we can't verify (CI_JOB_TOKEN limitation with group milestones)
      if [ -z "$MILESTONE" ] || [ "$MILESTONE" = "null" ] || [ "$MILESTONE" = "" ]; then
        echo "[WARN] WARNING: Cannot verify milestone assignment"
        echo "   CI_JOB_TOKEN has limited scope for group milestones"
        echo "   If milestone is assigned, GITLAB_PUSH_TOKEN is required for verification"
        echo "[PASS] Allowing merge (milestone validation may be inaccurate without proper token)"
      else
        echo "[PASS] Milestone assigned: ${MILESTONE}"
      fi

      # Check if targeting main - must come from release/* or hotfix/*
      if [ "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" = "main" ]; then
        case "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" in
          release/*|hotfix/*)
            if [ -z "$MILESTONE" ]; then
              echo "[WARN] Cannot verify milestone - CI_JOB_TOKEN has limited scope"
              echo "   Release version determined from branch name"
            fi
            echo "[PASS] Release/hotfix MR to main from ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
            ;;
          *)
            echo ""
            echo "[FAIL] ERROR: Only 'release/*' or 'hotfix/*' branches can merge to 'main'"
            echo ""
            echo "Workflow:"
            echo "  1. feature/* → release/* ([PASS] allowed)"
            echo "  2. release/* → main ([PASS] allowed)"
            echo "  3. hotfix/* → main ([PASS] allowed for urgent fixes)"
            echo "  4. ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} → main ([FAIL] blocked)"
            exit 1
            ;;
        esac
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: false

# Auto-label MRs based on branch naming
auto:label-mr:
  stage: .pre
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      #!/bin/sh

      echo "[TAG] AUTO-LABELING MR"
      echo "==================="

      # Determine label from branch name
      case "$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME" in
        feature/*)
          LABEL="type::feature"
          ;;
        bugfix/*|fix/*)
          LABEL="type::bug"
          ;;
        chore/*)
          LABEL="type::chore"
          ;;
        docs/*)
          LABEL="type::docs"
          ;;
        refactor/*)
          LABEL="type::refactor"
          ;;
        test/*)
          LABEL="type::test"
          ;;
        release/*)
          LABEL="type::release"
          ;;
        hotfix/*)
          LABEL="type::hotfix"
          ;;
        *)
          echo "[INFO] No auto-label for branch pattern"
          exit 0
          ;;
      esac

      echo "Branch: ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}"
      echo "Label: ${LABEL}"

      # Add label to MR (requires token with API access)
      if [ -n "$GITLAB_PUSH_TOKEN" ]; then
        curl -sS --request PUT \
          --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
          --data "add_labels=${LABEL}" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}" > /dev/null

        echo "[PASS] Added label: ${LABEL}"
      else
        echo "[INFO] GITLAB_PUSH_TOKEN not set - skipping auto-label"
      fi
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: true
