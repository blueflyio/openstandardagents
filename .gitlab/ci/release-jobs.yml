# ============================================================================
# STAGE 5 - DEPLOY (Removed - Website moved to openstandardagents.org)
# ============================================================================
# Website deployment is now handled by the openstandardagents.org repository.
# This repo (openstandardagents) is the spec/CLI npm package only.

# ============================================================================
# STAGE 6 - RELEASE (NPM - Milestone-Gated)
# ============================================================================

# AUTOMATED CHANGELOG GENERATION (git-cliff)
# Runs on every merge to release branches - generates Keep a Changelog format
changelog:generate:
  stage: release
  image: alpine:latest
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0  # Full history needed for changelog generation
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl bash
    # Install git-cliff
    - curl -sS --max-time 30 -fL https://github.com/orhun/git-cliff/releases/download/v2.7.0/git-cliff-2.7.0-x86_64-unknown-linux-musl.tar.gz | tar xz
    - mv git-cliff-*/git-cliff /usr/local/bin/
    - chmod +x /usr/local/bin/git-cliff
    - git config --global user.email "ci@openstandardagents.org"
    - git config --global user.name "OSSA CI Bot"
  script:
    - |
      echo "Generating changelog with git-cliff..."
      echo "Branch: $CI_COMMIT_BRANCH"
      echo "Commit: $CI_COMMIT_SHA"

      # Generate changelog
      git cliff --output CHANGELOG.md

      # Check if changelog changed
      if git diff --quiet CHANGELOG.md 2>/dev/null; then
        echo "No changelog updates needed"
        exit 0
      fi

      echo "Changelog updated:"
      head -100 CHANGELOG.md

      # Commit locally (but don't push to protected branch)
      git add CHANGELOG.md
      git commit -m "chore(release): update changelog [skip ci]"

      echo "Changelog generated and committed locally"
      echo "Note: Not pushing to protected branch - changelog saved as artifact"
  artifacts:
    paths:
      - CHANGELOG.md
    expire_in: 1 week
  rules:
    # Run on merges to release branches
    - if: $CI_COMMIT_BRANCH =~ /^release\/v[0-9]+\.[0-9]+\.x$/
      when: on_success
    # Run on merges to main
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
  allow_failure: true  # Don't block pipeline if changelog fails

# GENERATE CHANGELOG from milestone issues (legacy - for release notes)
release:changelog:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 10 minutes
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git curl jq bash
    - npm ci --legacy-peer-deps
    - npm install -g tsx
    - test -f build.env && . build.env || echo "No build.env found (using defaults)"
  script:
    - |
      #!/bin/bash
      set -euo pipefail
      echo "CHANGELOG GENERATION"
      echo "======================="

      if [ "$MILESTONE_READY" != "true" ]; then
        echo "WARNING: No release-ready milestone - skipping"
        exit 0
      fi

      echo "Milestone: ${MILESTONE_TITLE}"
      echo "Version: v${RELEASE_VERSION}"
      echo "Milestone ID: ${MILESTONE_ID}"
      echo ""

      # Generate changelog from milestone issues
      MILESTONE_ID=${MILESTONE_ID} \
      RELEASE_VERSION=${RELEASE_VERSION} \
      CHANGELOG_OUTPUT="RELEASE_NOTES.md" \
      tsx .gitlab/release-automation/scripts/generate-changelog.ts

      # Also create version-specific changelog
      VERSION_CHANGELOG="spec/v${RELEASE_VERSION}/CHANGELOG.md"
      mkdir -p "spec/v${RELEASE_VERSION}"
      cp RELEASE_NOTES.md "$VERSION_CHANGELOG"

      echo ""
      echo "Changelog generated successfully"
      cat RELEASE_NOTES.md
  artifacts:
    paths:
      - RELEASE_NOTES.md
      - spec/v*/CHANGELOG.md
      - changelog.env
    reports:
      dotenv: changelog.env
    expire_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $MILESTONE_READY == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  needs:
    - job: detect:version
      optional: true
      artifacts: true
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true
  allow_failure: false

# PRE-RELEASE VALIDATION - Critical checks before any release
release:validate:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 10 minutes
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git jq bash curl
    - npm ci --legacy-peer-deps
  script:
    - |
      #!/bin/bash
      set -euo pipefail
      echo "ðŸ”’ PRE-RELEASE VALIDATION"
      echo "========================="
      echo ""

      ERRORS=0
      WARNINGS=0

      # Set defaults for milestone variables (in case detect:milestone-and-tags didn't run)
      MILESTONE_READY="${MILESTONE_READY:-false}"
      MILESTONE_TITLE="${MILESTONE_TITLE:-}"
      MILESTONE_ID="${MILESTONE_ID:-}"
      ISSUE_COUNT="${ISSUE_COUNT:-0}"
      OPEN_ISSUE_COUNT="${OPEN_ISSUE_COUNT:-0}"
      RELEASE_VERSION="${RELEASE_VERSION:-}"

      # 0. MILESTONE GATE CHECK
      echo "ðŸ“‹ 0. Milestone Gate"
      RANGE_MILESTONE="${RANGE_MILESTONE:-false}"
      if [ "${MILESTONE_READY}" != "true" ]; then
        echo "RELEASE BLOCKED: no matching active milestone"
        ERRORS=$((ERRORS + 1))
      else
        echo "   Milestone ready: ${MILESTONE_TITLE}"
        echo "   Total issues: ${ISSUE_COUNT:-0}"
        echo "   Open issues: ${OPEN_ISSUE_COUNT:-0}"
        if [ "${RANGE_MILESTONE}" = "true" ]; then
          echo "   Range milestone in use; open issues are informational."
        else
          echo "   Exact milestone in use."
        fi
      fi
      echo ""

      # 1. VERSION CONSISTENCY CHECK
      echo "ðŸ“‹ 1. Version Consistency"
      # Use .version.json as single source of truth (package.json uses {{VERSION}} placeholder)
      VERSION=$(jq -r '.current' .version.json)
      echo "  Release version: v${VERSION}"

      # Check schema exists for this version
      SCHEMA_PATH=$(jq -r '.spec_path + "/" + .schema_file' .version.json)
      if [ ! -f "$SCHEMA_PATH" ]; then
        echo "ERROR: Schema not found: ${SCHEMA_PATH}"
        ERRORS=$((ERRORS + 1))
      else
        echo "   Schema exists: ${SCHEMA_PATH}"
      fi

      # Check README version badge matches
      if grep -q "v${VERSION}" README.md; then
        echo "   README version badge matches"
      else
        echo "WARNING: README may not reference v${VERSION}"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 2. SCHEMA VALIDATION
      echo ""
      echo "ðŸ“‹ 2. Schema Validation"

      # Check schema is valid JSON
      if jq empty "$SCHEMA_PATH" 2>/dev/null; then
        echo "   Schema is valid JSON"
      else
        echo "ERROR: Schema is not valid JSON"
        ERRORS=$((ERRORS + 1))
      fi

      # Check schema has required fields
      SCHEMA_VERSION=$(jq -r '.properties.apiVersion.const // .properties.apiVersion.enum[0] // ""' "$SCHEMA_PATH" 2>/dev/null || echo "")
      if [ -n "$SCHEMA_VERSION" ]; then
        echo "   Schema apiVersion: ${SCHEMA_VERSION}"
      else
        echo "WARNING: Could not detect apiVersion in schema"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 3. EXAMPLES VALIDATION
      echo ""
      echo "ðŸ“‹ 3. Examples Validation"

      EXAMPLE_COUNT=0
      EXAMPLE_WARNINGS=0
      for example in examples/**/*.ossa.yaml examples/**/*.ossa.json; do
        [ ! -f "$example" ] && continue
        EXAMPLE_COUNT=$((EXAMPLE_COUNT + 1))

        # Check apiVersion has valid format (ossa/vX.Y.Z)
        # Examples can have older versions for backwards compatibility demos
        EXAMPLE_API=$(grep -oE "ossa/v[0-9]+\.[0-9]+\.[0-9]+" "$example" 2>/dev/null | head -1 || true)
        if [ -n "$EXAMPLE_API" ]; then
          echo "   ${example} (${EXAMPLE_API})"
        else
          echo "WARNING: ${example} missing valid apiVersion format"
          EXAMPLE_WARNINGS=$((EXAMPLE_WARNINGS + 1))
        fi
      done

      echo "   Validated ${EXAMPLE_COUNT} examples"
      if [ $EXAMPLE_WARNINGS -gt 0 ]; then
        echo "  WARNING: ${EXAMPLE_WARNINGS} examples have invalid apiVersion format"
        WARNINGS=$((WARNINGS + EXAMPLE_WARNINGS))
      fi

      # 4. BUILD ARTIFACTS CHECK
      echo ""
      echo "ðŸ“‹ 4. Build Artifacts"

      if [ -f "dist/cli/index.js" ]; then
        echo "   CLI built: dist/cli/index.js"
      else
        echo "ERROR: CLI not built"
        ERRORS=$((ERRORS + 1))
      fi

      if [ -d "dist/lib" ]; then
        echo "   Library built: dist/lib/"
      else
        echo "WARNING: dist/lib/ not found"
        WARNINGS=$((WARNINGS + 1))
      fi

      # 5. PACKAGE.JSON EXPORTS CHECK
      echo ""
      echo "ðŸ“‹ 5. Package Exports"

      SCHEMA_EXPORT=$(node -p "require('./package.json').exports?.['./schema'] || ''" 2>/dev/null || echo "")
      EXPECTED_EXPORT="./spec/v${VERSION}/ossa-${VERSION}.schema.json"
      PLACEHOLDER_EXPORT='./spec/v{{VERSION}}/ossa-{{VERSION}}.schema.json'

      if [ "$SCHEMA_EXPORT" = "$EXPECTED_EXPORT" ]; then
        echo "   Schema export correct: ${SCHEMA_EXPORT}"
      elif [ "$SCHEMA_EXPORT" = "$PLACEHOLDER_EXPORT" ]; then
        echo "   Schema export uses {{VERSION}} placeholder (valid)"
      elif [ -z "$SCHEMA_EXPORT" ]; then
        echo "WARNING: No ./schema export defined"
        WARNINGS=$((WARNINGS + 1))
      else
        echo "ERROR: Schema export mismatch"
        echo "     Expected: ${EXPECTED_EXPORT} or ${PLACEHOLDER_EXPORT}"
        echo "     Got: ${SCHEMA_EXPORT}"
        ERRORS=$((ERRORS + 1))
      fi

      # 6. TEST RUN
      echo ""
      echo "ðŸ“‹ 6. Test Suite"

      if npm run test 2>&1; then
        echo "   All tests passed"
      else
        echo "ERROR: Tests failed"
        ERRORS=$((ERRORS + 1))
      fi

      # 7. TYPECHECK
      echo ""
      echo "ðŸ“‹ 7. TypeScript Validation"

      if npm run typecheck 2>&1; then
        echo "   TypeScript compilation clean"
      else
        echo "ERROR: TypeScript errors"
        ERRORS=$((ERRORS + 1))
      fi

      # 8. NO HARDCODED VERSIONS IN SCRIPTS
      echo ""
      echo "ðŸ“‹ 8. Script Version Check"

      if node -e "const pkg = require('./package.json'); const scripts = JSON.stringify(pkg.scripts || {}); if (scripts.match(/spec\/v0\.[0-9]/)) { process.exit(1); }" 2>/dev/null; then
        echo "   No hardcoded versions in scripts"
      else
        echo "ERROR: Hardcoded versions found in package.json scripts"
        ERRORS=$((ERRORS + 1))
      fi

      # SUMMARY
      echo ""
      echo "========================================"
      echo "ðŸ“Š VALIDATION SUMMARY"
      echo "========================================"
      echo "  Errors: ${ERRORS}"
      echo "  Warnings: ${WARNINGS}"
      echo ""

      if [ $ERRORS -gt 0 ]; then
        echo "ERROR: RELEASE BLOCKED: ${ERRORS} error(s) must be fixed"
        echo ""
        echo "Fix the errors above before releasing."
        exit 1
      fi

      if [ $WARNINGS -gt 0 ]; then
        echo "WARNING: RELEASE APPROVED WITH WARNINGS: ${WARNINGS} warning(s)"
      else
        echo "RELEASE APPROVED: All checks passed"
      fi
  artifacts:
    reports:
      dotenv: validation-report.env
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  needs:
    - build:dist
    - test:unit
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:preview:
  stage: release
  image: node:${NODE_VERSION}-alpine
  dependencies:
    - build:dist
  before_script:
    - apk add --no-cache curl jq
    - apk add --no-cache git
    - npm ci --legacy-peer-deps
  script:
    - |
      echo "ðŸ” Release Preview (Dry-Run)"
      echo "============================"
      
      if [ "$ENABLE_RELEASE" = "true" ]; then
        echo "ENABLE_RELEASE: ${ENABLE_RELEASE} (releases enabled)"
      else
        echo "WARNING: ENABLE_RELEASE: ${ENABLE_RELEASE:-not set} (releases disabled)"
      fi
      
      if [ -n "$RELEASE_VERSION" ]; then
        echo "ðŸ“¦ Detected from closed milestone:"
        echo "  Milestone: ${MILESTONE_TITLE}"
        echo "  Version: v${RELEASE_VERSION}"
        echo "  Ready: ${MILESTONE_READY:-false}"
      fi

      CURRENT_VERSION=$(jq -r '.current' .version.json)
      echo "ðŸ“„ Current release version: v${CURRENT_VERSION}"
      
      if [ "$ENABLE_RELEASE" = "true" ] && [ "$MILESTONE_READY" = "true" ]; then
        echo "Release will proceed automatically"
      else
        echo "WARNING: Release blocked (see conditions above)"
      fi
      
      npx semantic-release --dry-run || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: always
  allow_failure: true
  needs:
    - build:dist
    - job: detect:milestone-and-tags
      optional: true
      artifacts: true

release:audit:
  stage: release
  image: node:${NODE_VERSION}-alpine
  script:
    - npm ci --legacy-peer-deps
    - npm run build
    - npm pack --dry-run | tee audit-pack-dry-run.txt
    - 'PKG="$(npm pack 2>/dev/null | tail -1)" && echo "Package file: $PKG"'
    - 'test -f "$PKG" || { echo "ERROR: Package file not found"; exit 1; }'
    - sha256sum "$PKG" | tee audit-sha256.txt
    - tar -tzf "$PKG" | head -200 | tee audit-tar-list-head.txt
  artifacts:
    paths:
      - "*.tgz"
      - "audit-pack-dry-run.txt"
      - "audit-sha256.txt"
      - "audit-tar-list-head.txt"
    expire_in: 1 day
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
      when: on_success
    - if: '$CI_COMMIT_BRANCH =~ /^release\/v\d+\.\d+\.x$/ && $ENABLE_RELEASE == "true"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"'
      when: on_success
  # No dependencies needed - this job builds from source (npm run build)
  # Removing build:dist dependency resolves circular dependency concern

release:npm:
  stage: release
  image: node:${NODE_VERSION}-alpine
  timeout: 15 minutes
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure
  before_script:
    - apk add --no-cache curl jq git bash
    - npm ci --legacy-peer-deps
    - npm install -g tsx
  script:
    - RELEASE_ACTION=npm tsx .gitlab/release-automation/scripts/release-buttons.ts
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true" && $MILESTONE_READY == "true"
      when: on_success
    - if: $CI_COMMIT_BRANCH == "main" && $ENABLE_RELEASE == "true"
      when: manual
  needs:
    - job: release:validate
      optional: true
    - job: release:changelog
      optional: true
      artifacts: true
create-patch-version:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config --global user.email "ci@bluefly.io"
    - git config --global user.name "GitLab CI"
    - |
      # Token priority: CI_DEPLOY_OSSA (group) > GITLAB_PUSH_TOKEN > CI_JOB_TOKEN
      echo "Checking available tokens..."
      echo "CI_DEPLOY_OSSA set: ${CI_DEPLOY_OSSA:+yes}"
      echo "GITLAB_PUSH_TOKEN set: ${GITLAB_PUSH_TOKEN:+yes}"

      if [ -n "${CI_DEPLOY_OSSA:-}" ]; then
        echo "Using CI_DEPLOY_OSSA"
        echo "Token prefix: ${CI_DEPLOY_OSSA:0:5}..."
        if echo "${CI_DEPLOY_OSSA}" | grep -q "^gldt-"; then
          echo "Deploy token - using username:token"
          REMOTE_URL="https://${DEPLOY_TOKEN_USERNAME:-gitlab+deploy-token-10466652}:${CI_DEPLOY_OSSA}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
        else
          echo "PAT - using oauth2:token"
          REMOTE_URL="https://oauth2:${CI_DEPLOY_OSSA}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
        fi
      elif [ -n "${GITLAB_PUSH_TOKEN:-}" ]; then
        echo "Using GITLAB_PUSH_TOKEN"
        echo "Token prefix: ${GITLAB_PUSH_TOKEN:0:5}..."
        if [[ "${GITLAB_PUSH_TOKEN:0:5}" == "gldt-" ]]; then
          echo "Deploy token format detected"
          REMOTE_URL="https://${DEPLOY_TOKEN_USERNAME:-gitlab+deploy-token-10466652}:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
        else
          echo "PAT format detected"
          REMOTE_URL="https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
        fi
      elif [ -n "${CI_JOB_TOKEN:-}" ]; then
        echo "Using CI_JOB_TOKEN (fallback - limited permissions)"
        REMOTE_URL="https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      else
        echo "ERROR: No authentication token available"
        exit 1
      fi
      echo "Setting git remote with token..."
      git remote set-url origin "$REMOTE_URL"
      # Test the connection
      if git ls-remote --heads origin 2>&1 | head -5; then
        echo "Authentication successful"
      else
        echo "WARNING: Could not list remote heads, but continuing..."
      fi
    - git fetch --unshallow --tags || git fetch --tags || true
  script:
    - |
      set -e
      echo "=============================================="
      echo "  DEV TAG CREATION"
      echo "=============================================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo "Pipeline: ${CI_PIPELINE_URL}"
      echo "Pipeline Source: ${CI_PIPELINE_SOURCE}"
      echo "All tags: $(git tag -l | head -20)"
      echo ""

      # Check if this is a hotfix branch
      if echo "$CI_COMMIT_BRANCH" | grep -qE "^hotfix/"; then
        echo "Hotfix branch detected - creating dev tag only"
        # Get version from .version.json (single source of truth)
        CURRENT_VERSION=$(jq -r '.current' .version.json 2>/dev/null || echo "0.3.0")
        # Extract major.minor from version (e.g., 0.3.0 -> 0.3)
        BRANCH_VERSION=$(echo "$CURRENT_VERSION" | sed -E 's/^([0-9]+\.[0-9]+)\.[0-9]+$/\1/')
        echo "Hotfix dev tag series: v${BRANCH_VERSION}.0-dev.x"
      else
        # Extract version from branch name (e.g., release/v0.1.x -> 0.1)
        BRANCH_VERSION=$(echo "$CI_COMMIT_BRANCH" | sed -E 's/release\/v?([0-9]+\.[0-9]+)\.x/\1/')

        if [ -z "$BRANCH_VERSION" ] || [ "$BRANCH_VERSION" = "$CI_COMMIT_BRANCH" ]; then
          echo "WARNING: Not a release branch format (release/v0.X.x)"
          exit 0
        fi

        echo "Release series: v${BRANCH_VERSION}.x"
      fi

      # USE .version.json AS SINGLE SOURCE OF TRUTH
      # This is the correct approach - no guessing from git tags!
      if [ -f .version.json ]; then
        BASE_VERSION=$(jq -r '.current' .version.json)
        echo "Version from .version.json: ${BASE_VERSION}"
        
        # Check if a stable release already exists for this version
        # If v0.3.1 stable exists, we should create v0.3.2-dev.* tags, not v0.3.1-dev.*
        STABLE_TAG="v${BASE_VERSION}"
        if git tag -l "$STABLE_TAG" | grep -q . && ! echo "$STABLE_TAG" | grep -qE "(dev|RC|rc|alpha|beta)"; then
          echo "Stable release ${STABLE_TAG} already exists"
          # Extract major.minor.patch and increment patch
          MAJOR_MINOR=$(echo "$BASE_VERSION" | sed -E 's/^([0-9]+\.[0-9]+)\.[0-9]+$/\1/')
          CURRENT_PATCH=$(echo "$BASE_VERSION" | sed -E 's/^[0-9]+\.[0-9]+\.([0-9]+)$/\1/')
          if [ "$MAJOR_MINOR" = "$BASE_VERSION" ] || [ "$CURRENT_PATCH" = "$BASE_VERSION" ]; then
            echo "ERROR: Invalid version format: $BASE_VERSION"
            exit 1
          fi
          NEXT_PATCH=$((CURRENT_PATCH + 1))
          BASE_VERSION="${MAJOR_MINOR}.${NEXT_PATCH}"
          echo "Bumping to next patch version for dev tags: ${BASE_VERSION}"
        fi
      else
        # Fallback only if .version.json doesn't exist
        echo "WARNING: .version.json not found, falling back to git tag calculation"
        LATEST_RELEASE=$(git tag -l "v${BRANCH_VERSION}.*" 2>/dev/null | grep -v -E "(dev|RC|rc|alpha|beta)" | sort -V | tail -1 || echo "")
        if [ -z "$LATEST_RELEASE" ]; then
          BASE_VERSION="${BRANCH_VERSION}.0"
        else
          CURRENT_PATCH=$(echo "$LATEST_RELEASE" | sed "s/v${BRANCH_VERSION}\.//" | grep -oE '^[0-9]+' || echo "0")
          NEXT_PATCH=$((CURRENT_PATCH + 1))
          BASE_VERSION="${BRANCH_VERSION}.${NEXT_PATCH}"
        fi
      fi
      echo "Dev tags will be: v${BASE_VERSION}-dev.*"

      # Get latest dev tag for this NEXT version (not hardcoded .0!)
      echo "Looking for dev tags matching: v${BASE_VERSION}-dev.*"
      LATEST_DEV_TAG=$(git tag -l "v${BASE_VERSION}-dev.*" | sort -V | tail -n1)
      echo "Latest dev tag found: ${LATEST_DEV_TAG:-none}"

      if [ -z "$LATEST_DEV_TAG" ]; then
        # No dev tags exist for next version, start with dev.1
        NEW_TAG="v${BASE_VERSION}-dev.1"
        echo "No existing dev tags for v${BASE_VERSION}, starting with ${NEW_TAG}"
      else
        echo "Latest dev tag: $LATEST_DEV_TAG"

        # Check if HEAD is already tagged
        HEAD_TAGS=$(git tag --points-at HEAD)
        if echo "$HEAD_TAGS" | grep -qE "^v${BASE_VERSION}-dev\."; then
          echo "HEAD already has dev tag: $HEAD_TAGS"
          exit 0
        fi

        # Extract dev number and increment
        DEV_NUM=$(echo "$LATEST_DEV_TAG" | sed -E "s/v${BASE_VERSION}-dev\.([0-9]+)/\1/")
        if [ -z "$DEV_NUM" ] || [ "$DEV_NUM" = "$LATEST_DEV_TAG" ]; then
          DEV_NUM=0
        fi
        NEW_DEV_NUM=$((DEV_NUM + 1))
        NEW_TAG="v${BASE_VERSION}-dev.${NEW_DEV_NUM}"
      fi

      echo ""
      echo "TAG: Creating new tag: $NEW_TAG"

      # Create annotated tag
      git tag -a "$NEW_TAG" -m "Release $NEW_TAG from $CI_COMMIT_BRANCH

      Commit: $CI_COMMIT_SHA
      Pipeline: $CI_PIPELINE_URL
      Branch: $CI_COMMIT_BRANCH"

      # Push tag
      echo "Pushing tag to remote..."
      echo "Tag to push: $NEW_TAG"

      # Use CI_JOB_TOKEN directly (simplest, most reliable)
      REMOTE_URL="https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"

      # Ensure remote is set correctly before pushing
      git remote set-url origin "$REMOTE_URL"
      echo "Remote URL configured with CI_JOB_TOKEN"
      
      if git push origin "$NEW_TAG" 2>&1; then
        echo "SUCCESS: Created and pushed tag: $NEW_TAG"
        
        # Create GitLab Release for dev tag
        echo ""
        echo "Creating GitLab Release for $NEW_TAG"
        
        RELEASE_DESCRIPTION="Dev build $NEW_TAG from $CI_COMMIT_BRANCH - Commit $CI_COMMIT_SHA - Pipeline $CI_PIPELINE_URL - Branch $CI_COMMIT_BRANCH - This is a development/pre-release tag and should not be used in production."
        
        RELEASE_PAYLOAD=$(jq -n \
          --arg name "Dev Release $NEW_TAG" \
          --arg tag "$NEW_TAG" \
          --arg desc "$RELEASE_DESCRIPTION" \
          '{
            name: $name,
            tag_name: $tag,
            description: $desc
          }')
        
        RELEASE_RESPONSE=$(curl -sS --max-time 30 --request POST \
          --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
          --header "Content-Type: application/json" \
          --data "$RELEASE_PAYLOAD" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/releases" 2>&1)
        
        if echo "$RELEASE_RESPONSE" | jq -e '.tag_name' > /dev/null 2>&1; then
          echo "GitLab Release created: https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}/-/releases/$NEW_TAG"
        else
          echo "WARNING: Failed to create GitLab Release (tag was created successfully)"
          echo "Response: $RELEASE_RESPONSE"
        fi
      else
        echo "ERROR: Failed to push tag"
        exit 1
      fi
  rules:
    # Hotfix branches can create dev tags
    - if: $CI_COMMIT_BRANCH =~ /^hotfix\//
      when: always
    # Release branches create dev tags on every push
    - if: $CI_COMMIT_BRANCH =~ /^release\/v[0-9]+\.[0-9]+\.x$/
      when: always
  allow_failure: false
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0

create-release:
  stage: release
  image: registry.gitlab.com/gitlab-org/cli:latest
  script:
    - |
      echo "ðŸ“‹ Creating GitLab Release for $CI_COMMIT_TAG"

      # Extract version number
      VERSION=$(echo "$CI_COMMIT_TAG" | sed 's/^v//')

      # Load changelog if available
      DESCRIPTION="Release $CI_COMMIT_TAG"
      if [ -f "CHANGELOG.md" ]; then
        # Extract this version's section from CHANGELOG
        DESCRIPTION=$(awk "/^## \[${VERSION}\]/,/^## \[/{if (/^## \[${VERSION}\]/) next; if (/^## \[/) exit; print}" CHANGELOG.md || echo "Release $CI_COMMIT_TAG")
      fi

      echo "Creating release with description:"
      echo "$DESCRIPTION"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "Release $CI_COMMIT_TAG"
    description: "Release $CI_COMMIT_TAG of components in $CI_PROJECT_PATH"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/  # Only semantic version tags
      when: on_success

