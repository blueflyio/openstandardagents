# Review App for OrbStack Kubernetes via GitLab Agent
# Deploys MR branches to Kubernetes cluster via GitLab Kubernetes Agent
# Uses Docker image built from website static export

.review_app_base:
  image: alpine/k8s:1.28.0
  before_script:
    - apk add --no-cache bash curl
    - |
      set -e
      # Verify kubectl is available
      kubectl version --client || (echo "ERROR: kubectl not available" && exit 1)
      
      # GitLab automatically injects kubeconfig when environment.kubernetes is set
      # Wait a moment for GitLab to inject it
      echo "Waiting for GitLab to inject kubeconfig..."
      sleep 2
      
      # Check if KUBECONFIG is set (GitLab sets this automatically)
      # Fallback to KUBECONFIG_DEV or KUBECONFIG_PROD if available
      # These may be file paths or base64-encoded content
      if [ -z "${KUBECONFIG}" ]; then
        KUBECONFIG_FILE=""
        if [ -n "${KUBECONFIG_DEV}" ]; then
          echo "Found KUBECONFIG_DEV, checking if it's a file path or content..."
          if [ -f "${KUBECONFIG_DEV}" ]; then
            echo "Using KUBECONFIG_DEV as file path"
            export KUBECONFIG="${KUBECONFIG_DEV}"
          else
            echo "KUBECONFIG_DEV appears to be content, writing to temp file..."
            KUBECONFIG_FILE=$(mktemp /tmp/kubeconfig.XXXXXX)
            echo "${KUBECONFIG_DEV}" | base64 -d > "${KUBECONFIG_FILE}" 2>/dev/null || echo "${KUBECONFIG_DEV}" > "${KUBECONFIG_FILE}"
            export KUBECONFIG="${KUBECONFIG_FILE}"
            echo "Wrote kubeconfig to ${KUBECONFIG_FILE}"
          fi
        elif [ -n "${KUBECONFIG_PROD}" ]; then
          echo "Found KUBECONFIG_PROD, checking if it's a file path or content..."
          if [ -f "${KUBECONFIG_PROD}" ]; then
            echo "Using KUBECONFIG_PROD as file path"
            export KUBECONFIG="${KUBECONFIG_PROD}"
          else
            echo "KUBECONFIG_PROD appears to be content, writing to temp file..."
            KUBECONFIG_FILE=$(mktemp /tmp/kubeconfig.XXXXXX)
            echo "${KUBECONFIG_PROD}" | base64 -d > "${KUBECONFIG_FILE}" 2>/dev/null || echo "${KUBECONFIG_PROD}" > "${KUBECONFIG_FILE}"
            export KUBECONFIG="${KUBECONFIG_FILE}"
            echo "Wrote kubeconfig to ${KUBECONFIG_FILE}"
          fi
        elif [ -f "${HOME}/.kube/config" ]; then
          echo "Using default kubeconfig from ${HOME}/.kube/config"
          export KUBECONFIG="${HOME}/.kube/config"
        else
          echo "ERROR: KUBECONFIG not set and no fallback available"
          echo ""
          echo "GitLab should automatically set KUBECONFIG when environment.kubernetes is set."
          echo "This means the GitLab Kubernetes Agent is not properly configured."
          echo ""
          echo "Required steps:"
          echo "  1. Register the agent in GitLab UI: Infrastructure > Kubernetes clusters > Connect a cluster"
          echo "  2. Ensure agent is running and connected (check agent status in GitLab)"
          echo "  3. Verify agent config.yaml has ci_access for this project with 'review' environment"
          echo "  4. The agent must be registered in the SAME project where CI runs (blueflyio/ossa/openstandardagents.org)"
          echo ""
          echo "Note: Found KUBECONFIG_DEV and KUBECONFIG_PROD variables, but GitLab agent kubeconfig is missing."
          echo "This suggests the agent is not registered or not connected for this project."
          exit 1
        fi
      else
        echo "Using GitLab-provided KUBECONFIG"
      fi
      
      # Verify we can connect
      echo "Verifying kubectl connection to cluster..."
      echo "Current context: $(kubectl config current-context 2>&1)"
      echo "KUBECONFIG: ${KUBECONFIG:-not set}"
      
      # Try cluster-info, but don't fail immediately - the cluster might be local/OrbStack
      if ! kubectl cluster-info >/dev/null 2>&1; then
        echo "WARNING: kubectl cluster-info failed, but continuing..."
        echo "This may be normal for local clusters (OrbStack)"
        echo "Testing with a simple command instead..."
        if ! kubectl get nodes >/dev/null 2>&1 && ! kubectl get namespaces >/dev/null 2>&1; then
          echo "ERROR: Cannot connect to Kubernetes cluster"
          echo "Both cluster-info and get commands failed"
          echo ""
          echo "Available contexts:"
          kubectl config get-contexts 2>&1 || echo "No contexts available"
          echo ""
          echo "Kubeconfig file exists: $([ -f "${KUBECONFIG}" ] && echo "yes" || echo "no")"
          echo "Kubeconfig file size: $(wc -c < "${KUBECONFIG}" 2>/dev/null || echo "0") bytes"
          exit 1
        fi
        echo "Connection verified via get command"
      else
        echo "Successfully connected to Kubernetes cluster"
      fi"

review:deploy:
  extends: .review_app_base
  stage: deploy
  dependencies:
    - build:website
    - build:docker
  script:
    - |
      set -e
      export REVIEW_NAMESPACE="review-${CI_MERGE_REQUEST_IID}"
      export REVIEW_URL="ossa-mr-${CI_MERGE_REQUEST_IID}.ossa.orb.local"
      export IMAGE_TAG="${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"
      
      # Cleanup function
      cleanup() {
        echo "Cleaning up on failure..."
        kubectl delete namespace ${REVIEW_NAMESPACE} --ignore-not-found || true
      }
      trap cleanup ERR
      
      # kubectl connection is already verified in before_script
      # Just confirm we're still connected before deploying
      if ! kubectl get namespaces >/dev/null 2>&1; then
        echo "ERROR: Lost connection to Kubernetes cluster"
        exit 1
      fi
      
      # Create namespace
      kubectl create namespace ${REVIEW_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
      
      # Create image pull secret (idempotent)
      kubectl create secret docker-registry gitlab-registry \
        --docker-server=${CI_REGISTRY} \
        --docker-username=gitlab-ci-token \
        --docker-password=${CI_JOB_TOKEN} \
        --namespace=${REVIEW_NAMESPACE} \
        --dry-run=client -o yaml | kubectl apply -f -
      
      # Deploy review app
      kubectl apply -n ${REVIEW_NAMESPACE} -f - <<EOF
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ossa-review
        labels:
          app: ossa-review
          mr: "${CI_MERGE_REQUEST_IID}"
      spec:
        replicas: 1
        selector:
          matchLabels:
            app: ossa-review
            mr: "${CI_MERGE_REQUEST_IID}"
        template:
          metadata:
            labels:
              app: ossa-review
              mr: "${CI_MERGE_REQUEST_IID}"
          spec:
            securityContext:
              runAsNonRoot: true
              runAsUser: 101
              fsGroup: 101
            imagePullSecrets:
            - name: gitlab-registry
            containers:
            - name: ossa-review
              image: ${IMAGE_TAG}
              ports:
              - containerPort: 80
                name: http
                protocol: TCP
              env:
              - name: NODE_ENV
                value: "review"
              - name: MR_NUMBER
                value: "${CI_MERGE_REQUEST_IID}"
              resources:
                requests:
                  memory: "256Mi"
                  cpu: "100m"
                limits:
                  memory: "512Mi"
                  cpu: "500m"
              livenessProbe:
                httpGet:
                  path: /
                  port: 80
                initialDelaySeconds: 10
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 3
              readinessProbe:
                httpGet:
                  path: /
                  port: 80
                initialDelaySeconds: 5
                periodSeconds: 5
                timeoutSeconds: 3
                failureThreshold: 3
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: ossa-review
        labels:
          app: ossa-review
          mr: "${CI_MERGE_REQUEST_IID}"
      spec:
        selector:
          app: ossa-review
          mr: "${CI_MERGE_REQUEST_IID}"
        ports:
        - port: 80
          targetPort: 80
          protocol: TCP
          name: http
      ---
      apiVersion: networking.k8s.io/v1
      kind: Ingress
      metadata:
        name: ossa-review
        labels:
          app: ossa-review
          mr: "${CI_MERGE_REQUEST_IID}"
        annotations:
          nginx.ingress.kubernetes.io/rewrite-target: /
      spec:
        ingressClassName: nginx
        rules:
        - host: ${REVIEW_URL}
          http:
            paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: ossa-review
                  port:
                    number: 80
      EOF
      
      echo "Waiting for deployment to be ready..."
      kubectl rollout status deployment/ossa-review -n ${REVIEW_NAMESPACE} --timeout=10m
      
      # Verify deployment
      if ! kubectl get deployment ossa-review -n ${REVIEW_NAMESPACE} | grep -q "1/1"; then
        echo "ERROR: Deployment not ready"
        kubectl describe deployment ossa-review -n ${REVIEW_NAMESPACE}
        kubectl logs -n ${REVIEW_NAMESPACE} -l app=ossa-review --tail=50
        exit 1
      fi
      
      echo "Review app deployed at http://${REVIEW_URL}"
      trap - ERR
      
  environment:
    name: review/mr-${CI_MERGE_REQUEST_IID}
    url: http://ossa-mr-${CI_MERGE_REQUEST_IID}.ossa.orb.local
    kubernetes:
      namespace: review-${CI_MERGE_REQUEST_IID}
    on_stop: review:stop
    auto_stop_in: 7 days
  rules:
    - if: $CI_MERGE_REQUEST_IID
      when: on_success
  allow_failure: false

review:stop:
  extends: .review_app_base
  stage: deploy
  script:
    - export REVIEW_NAMESPACE="review-${CI_MERGE_REQUEST_IID}"
    - kubectl delete namespace ${REVIEW_NAMESPACE} --ignore-not-found
    - echo "Review app stopped"
  environment:
    name: review/mr-${CI_MERGE_REQUEST_IID}
    action: stop
    kubernetes:
      namespace: review-${CI_MERGE_REQUEST_IID}
  rules:
    - if: $CI_MERGE_REQUEST_IID
      when: manual
  allow_failure: true
