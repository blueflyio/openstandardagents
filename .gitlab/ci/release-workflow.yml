# Release Branch Workflow Configuration
# Implements dev tag automation for release/* branches
#
# Workflow:
# 1. Feature branches merge into release/* branches
# 2. On merge: Auto-creates -dev tags (v0.3.0-dev1, v0.3.0-dev2, etc.)
# 3. On merge release/* → main: Creates final release tag

# ============================================================================
# DEV TAG AUTOMATION FOR release/* BRANCHES
# ============================================================================

create-dev-tag:release:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "DEV TAG AUTOMATION FOR release/* BRANCHES"
      echo "=========================================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo ""
      
      # Extract major.minor from branch name (e.g., release/v0.3.x -> 0.3)
      BRANCH_VERSION=$(echo "$CI_COMMIT_BRANCH" | sed -n 's|^release/v\([0-9]\+\.[0-9]\+\).*|\1|p')
      
      if [ -z "$BRANCH_VERSION" ]; then
        echo "Could not extract version from branch name: $CI_COMMIT_BRANCH"
        exit 0
      fi
      
      echo "Branch version: $BRANCH_VERSION"
      
      # Fetch main branch tags
      git fetch origin main:main --tags 2>/dev/null || true
      
      # Get latest release tag for this major.minor (e.g., v0.3.*)
      LATEST_RELEASE_TAG=$(git tag -l "v${BRANCH_VERSION}.*" 2>/dev/null | grep -v "dev" | sort -V | tail -1 || echo "")
      
      if [ -z "$LATEST_RELEASE_TAG" ]; then
        # No release tags yet, start with X.Y.0
        BASE_VERSION="${BRANCH_VERSION}.0"
      else
        # Extract version number (e.g., v0.3.1 -> 0.3.1)
        VERSION_NUM=$(echo "$LATEST_RELEASE_TAG" | sed 's/^v//')
        # Increment patch version (0.3.1 -> 0.3.2)
        MAJOR_MINOR=$(echo "$VERSION_NUM" | cut -d. -f1-2)
        PATCH=$(echo "$VERSION_NUM" | cut -d. -f3)
        NEXT_PATCH=$((PATCH + 1))
        BASE_VERSION="${MAJOR_MINOR}.${NEXT_PATCH}"
        echo "Latest release tag: ${LATEST_RELEASE_TAG}"
        echo "Next version: v${BASE_VERSION}"
      fi
      
      # Get latest dev tag for this version
      LATEST_DEV_TAG=$(git tag -l "v${BASE_VERSION}-dev*" 2>/dev/null | sort -V | tail -1 || echo "")
      
      if [ -z "$LATEST_DEV_TAG" ]; then
        # First dev tag for this version
        NEXT_NUM=1
      else
        # Extract number from latest tag (e.g., v0.3.2-dev1 -> 1)
        CURRENT_NUM=$(echo "$LATEST_DEV_TAG" | sed -n 's/.*-dev\([0-9]*\)/\1/p' | head -1)
        if [ -z "$CURRENT_NUM" ]; then
          CURRENT_NUM=0
        fi
        NEXT_NUM=$((CURRENT_NUM + 1))
      fi
      
      NEW_TAG="v${BASE_VERSION}-dev${NEXT_NUM}"
      
      # Check if tag already exists for this commit
      EXISTING_TAG=$(git tag --points-at "$CI_COMMIT_SHA" | grep "^v${BASE_VERSION}-dev" || echo "")
      if [ -n "$EXISTING_TAG" ]; then
        echo "Tag already exists for this commit: $EXISTING_TAG"
        echo "DEV_TAG_NAME=$EXISTING_TAG" >> dev-tag.env
        exit 0
      fi
      
      echo "Creating dev tag: $NEW_TAG"
      
      # Create annotated tag
      git tag -a "$NEW_TAG" -m "Dev build ${NEXT_NUM} for ${CI_COMMIT_BRANCH}

      Auto-generated dev tag
      - Version: ${BASE_VERSION}
      - Dev iteration: ${NEXT_NUM}
      - Commit: ${CI_COMMIT_SHA:0:8}
      - Pipeline: ${CI_PIPELINE_URL}
      
      This is a dev/pre-release tag and should not be used in production." "$CI_COMMIT_SHA"
      
      # Push tag
      if git push origin "$NEW_TAG" 2>/dev/null; then
        echo "Created dev tag: $NEW_TAG"
        echo "DEV_TAG_NAME=$NEW_TAG" > dev-tag.env
        echo "DEV_TAG_VERSION=$BASE_VERSION" >> dev-tag.env
        echo "DEV_TAG_BUILD=$NEXT_NUM" >> dev-tag.env
      else
        echo "Failed to push tag $NEW_TAG"
        git tag -d "$NEW_TAG" 2>/dev/null || true
        exit 1
      fi
  artifacts:
    reports:
      dotenv: dev-tag.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\// && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: false

# ============================================================================
# VERSION DETECTION FOR release/* → main MERGE
# ============================================================================

detect-release-version:
  stage: version-detect
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git
    - git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "VERSION DETECTION FOR release/* → main"
      echo "======================================"
      
      # Detect version from latest dev tags
      # Find the highest version with dev tags (e.g., if we have v0.3.2-dev1, v0.3.2-dev2, use v0.3.2)
      LATEST_DEV_TAG=$(git tag -l "v0.3.*-dev*" 2>/dev/null | sort -V | tail -1 || echo "")
      
      if [ -z "$LATEST_DEV_TAG" ]; then
        echo "No dev tags found"
        echo "RELEASE_VERSION=" > release-version.env
        echo "RELEASE_READY=false" >> release-version.env
        exit 0
      fi
      
      # Extract version from dev tag (e.g., v0.3.2-dev5 -> v0.3.2)
      BASE_VERSION=$(echo "$LATEST_DEV_TAG" | sed 's/-dev[0-9]*$//' | sed 's/^v//')
      RELEASE_VERSION="v${BASE_VERSION}"
      
      # Check if final version tag already exists
      if git tag -l "$RELEASE_VERSION" | grep -q "^${RELEASE_VERSION}$"; then
        echo "Version ${RELEASE_VERSION} already released"
        echo "RELEASE_VERSION=" > release-version.env
        echo "RELEASE_READY=false" >> release-version.env
        exit 0
      fi
      
      if [ -z "$LATEST_DEV_TAG" ]; then
        echo "No dev tags found for v${BASE_VERSION}"
        echo "RELEASE_VERSION=" > release-version.env
        echo "RELEASE_READY=false" >> release-version.env
        exit 0
      fi
      
      echo "Latest dev tag: $LATEST_DEV_TAG"
      echo "Ready for release: v${BASE_VERSION}"
      
      echo "RELEASE_VERSION=v${BASE_VERSION}" > release-version.env
      echo "RELEASE_READY=true" >> release-version.env
      echo "LATEST_DEV_TAG=$LATEST_DEV_TAG" >> release-version.env
  artifacts:
    reports:
      dotenv: release-version.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE =~ /Merge branch 'release\//
      when: on_success
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^release\//
      when: on_success

# ============================================================================
# CREATE FINAL RELEASE TAG ON MERGE TO main
# ============================================================================

create-release-tag:
  stage: release
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    - git fetch --unshallow --tags --force || git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set -e
      
      source release-version.env || true
      
      if [ "$RELEASE_READY" != "true" ] || [ -z "$RELEASE_VERSION" ]; then
        echo "Release not ready or version not detected"
        exit 0
      fi
      
      echo "CREATING FINAL RELEASE TAG"
      echo "=========================="
      echo "Version: $RELEASE_VERSION"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo ""
      
      # Check if tag already exists
      if git tag -l "$RELEASE_VERSION" | grep -q "^${RELEASE_VERSION}$"; then
        echo "Tag $RELEASE_VERSION already exists"
        exit 0
      fi
      
      # Create annotated release tag
      git tag -a "$RELEASE_VERSION" -m "Release ${RELEASE_VERSION}

      Production release from ${CI_COMMIT_BRANCH} branch
      - Version: ${RELEASE_VERSION}
      - Commit: ${CI_COMMIT_SHA:0:8}
      - Pipeline: ${CI_PIPELINE_URL}
      - Previous dev tag: ${LATEST_DEV_TAG:-none}
      
      This is a stable production release." "$CI_COMMIT_SHA"
      
      # Push tag
      if git push origin "$RELEASE_VERSION" 2>/dev/null; then
        echo "Created release tag: $RELEASE_VERSION"
      else
        echo "Failed to push tag $RELEASE_VERSION"
        git tag -d "$RELEASE_VERSION" 2>/dev/null || true
        exit 1
      fi
  needs:
    - detect-release-version:v0.3.x
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE =~ /Merge branch 'release\//
      when: on_success
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^release\//
      when: manual
  allow_failure: false
