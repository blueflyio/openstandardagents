# Release Branch Workflow Configuration
# Implements dev tag automation for release/* branches
#
# Workflow:
# 1. Feature branches merge into release/* branches
# 2. On merge: Auto-creates -dev tags (v0.3.0-dev1, v0.3.0-dev2, etc.)
# 3. On merge release/* → main: Creates final release tag

# ============================================================================
# DEV TAG AUTOMATION FOR release/* BRANCHES
# ============================================================================

create-dev-tag:release:
  stage: .post
  image: alpine:latest
  tags:
    - saas-linux-small-amd64
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git fetch --tags --force || true
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "DEV TAG AUTOMATION FOR release/* BRANCHES"
      echo "=========================================="
      echo "Branch: ${CI_COMMIT_BRANCH}"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo ""
      
      # Extract major.minor from branch name (e.g., release/v0.3.x -> 0.3)
      BRANCH_VERSION=$(echo "$CI_COMMIT_BRANCH" | sed -n 's|^release/v\([0-9]\+\.[0-9]\+\).*|\1|p')
      
      if [ -z "$BRANCH_VERSION" ]; then
        echo "Could not extract version from branch name: $CI_COMMIT_BRANCH"
        exit 0
      fi
      
      echo "Branch version: $BRANCH_VERSION"
      
      # Fetch main branch tags
      git fetch origin main:main --tags 2>/dev/null || true
      
      # Get latest release tag for this major.minor (e.g., v0.3.*)
      LATEST_RELEASE_TAG=$(git tag -l "v${BRANCH_VERSION}.*" 2>/dev/null | grep -v "dev" | sort -V | tail -1 || echo "")
      
      if [ -z "$LATEST_RELEASE_TAG" ]; then
        # No release tags yet, start with X.Y.0
        BASE_VERSION="${BRANCH_VERSION}.0"
      else
        # Extract version number (e.g., v0.3.0 -> 0.3.0)
        VERSION_NUM=$(echo "$LATEST_RELEASE_TAG" | sed 's/^v//')
        # Increment patch version (0.3.1 -> 0.3.2)
        MAJOR_MINOR=$(echo "$VERSION_NUM" | cut -d. -f1-2)
        PATCH=$(echo "$VERSION_NUM" | cut -d. -f3)
        NEXT_PATCH=$((PATCH + 1))
        BASE_VERSION="${MAJOR_MINOR}.${NEXT_PATCH}"
        echo "Latest release tag: ${LATEST_RELEASE_TAG}"
        echo "Next version: v${BASE_VERSION}"
      fi
      
      # Get latest dev tag for this version
      LATEST_DEV_TAG=$(git tag -l "v${BASE_VERSION}-dev*" 2>/dev/null | sort -V | tail -1 || echo "")
      
      if [ -z "$LATEST_DEV_TAG" ]; then
        # First dev tag for this version
        NEXT_NUM=1
      else
        # Extract number from latest tag (e.g., v0.3.2-dev1 -> 1)
        CURRENT_NUM=$(echo "$LATEST_DEV_TAG" | sed -n 's/.*-dev\([0-9]*\)/\1/p' | head -1)
        if [ -z "$CURRENT_NUM" ]; then
          CURRENT_NUM=0
        fi
        NEXT_NUM=$((CURRENT_NUM + 1))
      fi
      
      NEW_TAG="v${BASE_VERSION}-dev${NEXT_NUM}"
      
      # Check if tag already exists for this commit
      EXISTING_TAG=$(git tag --points-at "$CI_COMMIT_SHA" | grep "^v${BASE_VERSION}-dev" || echo "")
      if [ -n "$EXISTING_TAG" ]; then
        echo "Tag already exists for this commit: $EXISTING_TAG"
        echo "DEV_TAG_NAME=$EXISTING_TAG" >> dev-tag.env
        exit 0
      fi
      
      echo "Creating dev tag: $NEW_TAG"
      
      # Create annotated tag
      git tag -a "$NEW_TAG" -m "Dev build ${NEXT_NUM} for ${CI_COMMIT_BRANCH}

      Auto-generated dev tag
      - Version: ${BASE_VERSION}
      - Dev iteration: ${NEXT_NUM}
      - Commit: ${CI_COMMIT_SHA:0:8}
      - Pipeline: ${CI_PIPELINE_URL}
      
      This is a dev/pre-release tag and should not be used in production." "$CI_COMMIT_SHA"
      
      # Push tag
      if git push origin "$NEW_TAG" 2>/dev/null; then
        echo "Created dev tag: $NEW_TAG"
        echo "DEV_TAG_NAME=$NEW_TAG" > dev-tag.env
        echo "DEV_TAG_VERSION=$BASE_VERSION" >> dev-tag.env
        echo "DEV_TAG_BUILD=$NEXT_NUM" >> dev-tag.env
      else
        echo "Failed to push tag $NEW_TAG"
        git tag -d "$NEW_TAG" 2>/dev/null || true
        exit 1
      fi
  artifacts:
    reports:
      dotenv: dev-tag.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\// && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: false

# ============================================================================
# VERSION DETECTION FOR release/* → main MERGE
# ============================================================================

detect-release-version:
  stage: version-detect
  image: alpine:latest
  tags:
    - saas-linux-small-amd64
  before_script:
    - apk add --no-cache curl jq git
    - git fetch --tags --force || true
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "VERSION DETECTION FOR release/* → main"
      echo "======================================"
      
      # Detect version from latest dev tags
      # Find the highest version with dev tags (e.g., if we have v0.3.2-dev1, v0.3.2-dev2, use v0.3.2)
      LATEST_DEV_TAG=$(git tag -l "v0.3.*-dev*" 2>/dev/null | sort -V | tail -1 || echo "")
      
      if [ -z "$LATEST_DEV_TAG" ]; then
        echo "No dev tags found"
        echo "RELEASE_VERSION=" > release-version.env
        echo "RELEASE_READY=false" >> release-version.env
        exit 0
      fi
      
      # Extract version from dev tag (e.g., v0.3.2-dev5 -> v0.3.2)
      BASE_VERSION=$(echo "$LATEST_DEV_TAG" | sed 's/-dev[0-9]*$//' | sed 's/^v//')
      RELEASE_VERSION="v${BASE_VERSION}"
      
      # Check if final version tag already exists
      if git tag -l "$RELEASE_VERSION" | grep -q "^${RELEASE_VERSION}$"; then
        echo "Version ${RELEASE_VERSION} already released"
        echo "RELEASE_VERSION=" > release-version.env
        echo "RELEASE_READY=false" >> release-version.env
        exit 0
      fi
      
      if [ -z "$LATEST_DEV_TAG" ]; then
        echo "No dev tags found for v${BASE_VERSION}"
        echo "RELEASE_VERSION=" > release-version.env
        echo "RELEASE_READY=false" >> release-version.env
        exit 0
      fi
      
      echo "Latest dev tag: $LATEST_DEV_TAG"
      echo "Ready for release: v${BASE_VERSION}"
      
      echo "RELEASE_VERSION=v${BASE_VERSION}" > release-version.env
      echo "RELEASE_READY=true" >> release-version.env
      echo "LATEST_DEV_TAG=$LATEST_DEV_TAG" >> release-version.env
  artifacts:
    reports:
      dotenv: release-version.env
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE =~ /Merge branch 'release\//
      when: on_success
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^release\//
      when: on_success

# ============================================================================
# CREATE FINAL RELEASE TAG ON MERGE TO main
# ============================================================================

create-release-tag:
  stage: release
  image: alpine:latest
  tags:
    - saas-linux-small-amd64
  before_script:
    - apk add --no-cache curl jq git bash
    - git config user.email "ci@bluefly.io"
    - git config user.name "GitLab CI"
    - git fetch --tags --force || true
    - git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
  script:
    - |
      #!/bin/bash
      set -e
      
      if [ ! -f release-version.env ]; then
        echo "release-version.env not found, skipping tag creation"
        exit 0
      fi
      
      source release-version.env
      
      echo "CREATING FINAL RELEASE TAG"
      echo "=========================="
      echo "Version: $RELEASE_VERSION"
      echo "Commit: ${CI_COMMIT_SHA}"
      echo ""
      
      # Check if tag already exists
      if git tag -l "$RELEASE_VERSION" | grep -q "^${RELEASE_VERSION}$"; then
        echo "Tag $RELEASE_VERSION already exists"
        exit 0
      fi
      
      # Create annotated release tag
      git tag -a "$RELEASE_VERSION" -m "Release ${RELEASE_VERSION}

      Production release from ${CI_COMMIT_BRANCH} branch
      - Version: ${RELEASE_VERSION}
      - Commit: ${CI_COMMIT_SHA:0:8}
      - Pipeline: ${CI_PIPELINE_URL}
      - Previous dev tag: ${LATEST_DEV_TAG:-none}
      
      This is a stable production release." "$CI_COMMIT_SHA"
      
      # Push tag
      if git push origin "$RELEASE_VERSION" 2>/dev/null; then
        echo "Created release tag: $RELEASE_VERSION"
      else
        echo "Failed to push tag $RELEASE_VERSION"
        git tag -d "$RELEASE_VERSION" 2>/dev/null || true
        exit 1
      fi
  needs:
    - job: detect-release-version
      artifacts: true
  rules:
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE =~ /Merge branch 'release/
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^release//
      when: manual
  allow_failure: false

# ============================================================================
# VERSION SYNC AFTER PATCH DETERMINATION
# ============================================================================

sync-version-files:
  stage: version-detect
  image: node:${NODE_VERSION}-alpine
  tags:
    - saas-linux-small-amd64
  # NOTE: Cannot use needs: [create-dev-tag:release] as it runs in .post stage (after this stage)
  # Job gracefully handles missing dev-tag.env file
  variables:
    NPM_CONFIG_LEGACY_PEER_DEPS: "1"
  before_script:
    - npm ci --legacy-peer-deps
  script:
    - |
      #!/bin/bash
      set -e
      
      echo "SYNCING VERSION FILES AFTER PATCH DETERMINATION"
      echo "==============================================="
      
      # Source dev tag info from previous job
      source dev-tag.env || true
      
      if [ -z "$DEV_TAG_VERSION" ]; then
        echo "No dev tag version found, skipping version sync"
        exit 0
      fi
      
      echo "Detected version: $DEV_TAG_VERSION"
      echo "Syncing all version files..."
      
      # Set environment variable for CI version sync script
      export CI_DETERMINED_VERSION="$DEV_TAG_VERSION"
      export CI_BRANCH_VERSION=$(echo "$DEV_TAG_VERSION" | cut -d. -f1-2)
      export CI_PATCH_VERSION=$(echo "$DEV_TAG_VERSION" | cut -d. -f3)
      
      # Run CI version sync
      npx tsx scripts/ci-version-sync.ts
      
      # Commit version changes
      git config user.email "ci@bluefly.io"
      git config user.name "GitLab CI"
      git remote set-url origin https://oauth2:${GITLAB_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
      
      git add package.json .version.json README.md CHANGELOG.md 2>/dev/null || true
      
      if git diff --staged --quiet; then
        echo "No version changes to commit"
      else
        git commit -m "chore(version): sync version files to ${DEV_TAG_VERSION} [skip ci]" || echo "Commit failed or no changes"
        git push origin ${CI_COMMIT_BRANCH} || echo "Push failed"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release\// && $CI_PIPELINE_SOURCE == "push"
      when: on_success
  allow_failure: true

# ============================================================================
# CREATE GITLAB RELEASE FROM TAG
# ============================================================================

create-gitlab-release:
  stage: .post
  image: alpine:latest
  tags:
    - saas-linux-small-amd64
  before_script:
    - apk add --no-cache git bash curl jq
  script:
    - |
      #!/bin/bash
      set -e

      echo "CREATING GITLAB RELEASE FROM TAG"
      echo "================================="
      echo "Tag: ${CI_COMMIT_TAG}"
      echo ""

      # Extract version from tag (remove 'v' prefix)
      VERSION="${CI_COMMIT_TAG#v}"

      # Extract changelog for this version
      CHANGELOG=$(git show HEAD:CHANGELOG.md | sed -n "/## \[${VERSION}\]/,/## \[/p" | head -n -1)

      if [ -z "$CHANGELOG" ]; then
        echo "No changelog found for version ${VERSION}"
        CHANGELOG="Release ${CI_COMMIT_TAG}

See CHANGELOG.md for details."
      fi

      # Determine release name based on tag type
      if [[ "$CI_COMMIT_TAG" =~ -RC$ ]]; then
        RELEASE_NAME="OSSA ${CI_COMMIT_TAG} - Release Candidate"
      elif [[ "$CI_COMMIT_TAG" =~ -dev ]]; then
        RELEASE_NAME="OSSA ${CI_COMMIT_TAG} - Development Build"
      else
        RELEASE_NAME="OSSA ${CI_COMMIT_TAG}"
      fi

      echo "Creating GitLab Release: ${RELEASE_NAME}"

      # Create release using GitLab API
      curl --fail --request POST \
        --header "PRIVATE-TOKEN: ${GITLAB_PUSH_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{
          \"tag_name\": \"${CI_COMMIT_TAG}\",
          \"name\": \"${RELEASE_NAME}\",
          \"description\": $(echo "$CHANGELOG" | jq -Rs .)
        }" \
        "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/releases"

      echo "✅ Created GitLab Release: https://gitlab.com/blueflyio/openstandardagents/-/releases/${CI_COMMIT_TAG}"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+(-RC|-dev[0-9]*)?$/'
      when: on_success
  allow_failure: true
